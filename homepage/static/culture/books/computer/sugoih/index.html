「すごいHaskellたのしく学ぼう」

<p>(工事中 10%)</p>

<h2>売れた理由</h2>

<h3>キャッチーなタイトルと装丁</h3>

<p>
この本が売れている一番の理由はタイトルの「すごい」と「たのしく」にある。
Haskellというものが「何かすごそう」なのは多くのプログラマが知っている。
「でも難しいんでしょう?」が次にくる言葉だろう。
それを「たのしく」学べると言う。
「たのしく」と平仮名で書いてあるしイラストもジョークもゆるい感じだ。
そこで「簡単に学べそう」と思う。
そんなに厚くもないし、と。
</p>

<h3>親しみの持てる話り口</h3>

<p>
ちょいちょいゆるい感じのジョークもありなんとなく親しみも持てる。
</p>

<h3>既存Haskellerからの支持</h3>

<p>
Haskellを1通り学び終えてからこれを読むといろいろと発見がある。
そのため、既存のHaskellerからの支持は得やすくなっている。
知識の穴を埋めるのには良いかもしれない。
</p>

<p>
そのため既存のHaskellerが初心者に勧めがちだ。
</p>

<h2>総合的な問題点</h2>

<h3>基礎的なことの説明が不十分</h3>

<p>
例を挙げるうえでいろいろと構文等の知識が必要となる。
そのために、はじめにいろいろな知識が羅列されてしまっている。
</p>

<h3>たしかにアプリカティブやジッパーは魅力的だけど</h3>

<p>
魅力的ではあるけれど各論的な話である。
</p>

<h3>著者が書きたいことだけを書いている</h3>

<p>
著者が「ここを説明したい」というところだけが説明されている。
基本的なところの説明は不十分である。
</p>

<h3>学ぶ順番が熟慮されていない</h3>

<p>
「たのしく」学ぶためにはいろいろな例を挙げていくことが必要だ。
そのためには例を挙げるのに最小限必要なだけの知識からはじめて、
同様の考えかたですこしずつ知識を増やしていく必要がある。
そのような「学ぶ順番」の考慮が不十分だ。
</p>

<h4>基本的な内容と応用的な内容が混ざっている</h4>

<p>
これがわからなければHaskellはわからないという基本的な内容と、
より応用的で各論的な話とがごっちゃに説明されている。
</p>

<h3>イラストはとくに内容と関係ない</h3>

<p>
キャッチーなイラストは望ましいが、
とくに内容とは関係ないので理解を助ける役には立たない。
単なるアイキャンディーだ。
</p>

<h2>詳細: イントロから第10章まで</h2>

<h3>イントロダクション</h3>

<p>
以下の内容について説明していて良い。
</p>

<ul>
<li>宣言型言語: 「どうやって」ではなく「何であるか」</li>
<li>参照透過性: 副作用を持たない</li>
<li>遅延性</li>
<li>静的型付け</li>
<li>型推論</li>
<li>エレガントで簡潔</li>
</ul>

<p>前置きが短いのも良いと思う。</p>

<h3>第1章のリスト以前</h3>

<p>
対話環境でいろいろな値や関数適用等を試している。
手を動かして学び始められるので良い。
ファイルで関数を定義して対話環境に読み込む方法の説明も良い。
</p>

<h3>第1章のリストの説明について</h3>

<h4>リストの本質は「くりかえし」だ</h4>

<p>
これに関してはどちらが良いのか難しいところだ。
たしかにリストをデータ構造として提示することは初学者にはわかりやすい。
反面、配列を使うべきところにリストを使うことで効率上問題のあるコードを書き、
その反動でリストを軽視することにつながる。
</p>

<p>
個人的にはリストは「くりかえし」を置き換えるものととらえるべきと感じている。
</p>

<h4>リストの説明が雑</h4>

<p>
リストについてはその使いかたを含めて具体例を挙げてじっくりと説明する必要がある。
それはベストプラクティスに関する話でもある。
再帰を扱う前にリストによってできる範囲を理解しておくことが良いだろう。
Haskellによるコーディングの大きな部分を直接的な再帰よりもリストで行うという
ことを考えればリストについてじっくりと学ぶ必要があるのは当然のことだ。
</p>

<h4>リスト内包表記の説明が早すぎる</h4>

<p>
リスト内包表記をさきに説明するのはあまり良くない。
例を挙げるのには役立つがあまり早くに説明すると学習者の気がそれてしまう。
リストを扱う関数をいろいろと学んだあとが良い。
あるいはリストモナドの別の書きかた、くらいの扱いでも良いように思う。
</p>

<h3>第1章のタプルの説明について</h3>

<p>
タプルの説明をリストからの類推で行っているのは良くない。
2つはまったく違うものだ。
</p>

<h3>第2章 型の説明について</h3>

<p>
対話環境でいろいろな値の型を表示させているのは良い。
型変数の話は多相関数を学んでからでないと意味がよくわからないかもしれない。
</p>

<h4>関数について学んだあとが良いように思う</h4>

<p>
たしかに型は重要だ。
しかし、型の説明は関数の説明のあとで良いと思われる。
関数の説明をしたあとに、型の不一致によるエラーの例を出しながら
のほうがわかりやすいだろう。
</p>

<h4>型クラスの説明が早すぎる</h4>

<p>
第2章で型クラスの説明をしている。
そしていろいろと型クラスの例を挙げている。
たしかにHaskellの標準的な関数の多くは多相的であるので、
さきに説明しておきたい気持ちはわかるが、
ここでそれを説明するよりはとりあえずはしれっと使っておいて、
あとになって「実は多相的でした」とタネ明かしするほうが学習しやすいだろう。
</p>

<p>
型クラスの列挙は単なるつめこみになってしまっている。
「型クラスの良さ」がわからない。
</p>

<h3>関数の説明について</h3>

<h4>いきなりパターンマッチはどうかと</h4>

<p>
たしかにHaskellの仮引数はパターンだ。
しかし、まずは普通にパターンマッチを意識しないで関数を書くことを
学んだほうが良いだろう。
また、パターンマッチの説明をするなら、その2つの機能をセットで教えたい。
よってMaybe型を導入してJust値とNothing値への分岐とJust値からの値の取り出しを
同時に学んだほうが良いだろう。
</p>

<h4>つめこみすぎ</h4>

<p>
この章で学ぶ構文が多すぎる。
パターンマッチを内包表記内で使う例はここでは雑音だ。
その他、ガード、where節、let ... in ...式、case式などを1度につめこみすぎだ。
</p>

<h3>第4章 再帰</h3>

<h4>ジョークがやや不適切</h4>

<p>
「再帰が何なのかまだよく分からないなら、この段落をもう一度読んでください」は
再帰的なジョークではなく「くりかえし」のジョークになっている気がする。
正しくは「再帰とは『再帰』という言葉で表現されるものです」あたりか。
</p>

<h4>もっと例を挙げようよ</h4>

<p>
再帰関数の例は簡単なものを中心にもっとたくさん必要だ。
標準ライブラリの関数の再定義は良いとは思うが。
クイックソートの例は美しいがダメな例。
当時としてはしかたないが。
</p>

<h3>第5章 高階関数</h3>

<p>
カリー化やセクションについて説明してあるのは良い。
高階関数を実際に定義してみるのも良い。
</p>

<h4>zipWith, map, filter</h4>

<p>
これらの関数についてここで学ぶのは良いが、
個人的な考えではこのような「基本的」な関数については
まずは「使いかた」を学び、次にを「定義のしかた」を学ぶほうが良いかと思う。
いくつかの例で「使いかた」を身につけたうえで、
「ではその定義はどうなっているのか」という流れだ。
</p>

<h4>ラムダ式</h4>

<p>
ラムダ式、つまり無名関数をどこで扱うのかは難しい問題だ。
より基本的なものとしてはじめのほうで扱う方法がひとつ、
使用例を挙げるためにmap等の高階関数を学んでからがひとつ、だ。
意図を明確にするために関数定義のときにラムダ式をうまく使うという
示唆は非常に良い。
</p>

<h4>畳み込み</h4>

<p>
畳み込みの説明は良い。
が、しかしこの説明の前に、生の再帰で同じものを定義する例を置いたほうが良いのでは。
いきなりfoldl, foldrを出すのではなく、
いくつかの再帰的な定義の例を挙げ、それらが同じ枠組みを持っていることを示し、
そのうえでfoldl, foldrでまとめるといった形だ。
</p>

<h4>関数適用演算子</h4>

<p>
$(関数適用演算子)の説明は非常に良い。
「はるか右に閉じ括弧のある開き括弧」という説明はさすがだ。
</p>

<h4>関数合成とポイントフリースタイル</h4>

<p>
ここらへんの説明は非常に良い。
</p>

<h3>第6章 モジュール</h3>

<p>
ここでモジュールについて説明するのは「しかたないか」といった感じだ。
例を挙げるうえで標準的なモジュールを使いたくなるので。
ただ、ここではまだimportの構文だけ導入する程度でも良いのでは。
学習者は気を散らさずに「関数」に親しむことに集中したほうが良いと思う。
</p>

<h4>foldl'</h4>

<p>
関数foldl'についてはたしかにどこかで触れる必要がある。
しかし、ここではなくてfoldlのところで触れたほうが良い。
ただしfoldl'がPreludeに含まれていないためモジュールの説明を先に
する必要があった。
さきにimportのみにしぼって説明しておくべきだろう。
</p>

<h4>Data.Map</h4>

<p>
関数lookupを学んだらたしかにData.Mapに触れる必要がある。
しかし「入門」ということで考えたならリストでの辞書にはパフォーマンスの面で
問題があるということだけに触れておき、
紹介するにしてもリファレンス程度にしておいたほうが良いかと思われる。
まだ「代数的データ型」も学んでいないし。
ここでData.Mapを扱うのは混乱のもとになるだろう。
</p>

<h3>第7章 型や型クラスを自分で作ろう</h3>

<p>
代数的データ型の章だ。
これは大きなトピックのひとつだ。
この位置にあるのは、まあまあ妥当だ。
もうすこしリストを使っていろいろと遊んだあとでも良い気もするが、
どっちもどっちといった感じか。
</p>

<h4>列挙型の例が欲しい</h4>

<p>
自分で定義する列挙型の例があったほうが良い気がする。
また、newtypeで表現できるようなコンストラクタがひとつの例も欲しい。
そして、その2つが矛盾なくひとつのdata構文で表現できるよというアハ体験が
用意できるのでは。
ちなみにnewtypeもいつかは紹介しなくてはならないが、導入が難しいな。
</p>

<h4>レコード構文</h4>

<p>
レコード構文はもうすこし後で扱ったほうが良い気がする。
気が散りそうだ。
便利だし紹介はしたい気もするが。
</p>

<h4>型引数</h4>

<p>
型引数の説明はまあまあ良いように思う。
「データ型宣言に型クラス制約を付けないというとても強いコーディング規約」に
触れているのは非常に非常に良い。
</p>

<h4>つめこみすぎ</h4>

<p>
この章はすこしつめこみすぎだ。
インスタンスの自動生成、型シノニム、再帰的なデータ型、Functorなど。
「実際に使う直前に」説明すれば良いものや、
再帰的なデータ型やFunctorなど別に1章をとって説明すべきものなどが含まれている。
</p>

<p>
型の種についてはまだ説明しなくてもいいのではないだろうか。
種そのものは、そんなに難しい話ではないので説明しても良いかもしれない。
ファンクターの説明のあたりかな。
</p>

<h3>第8章 入出力</h3>

<p>
入出力(IO)をどこで説明するかはHaskellを教えるときの永遠のテーマだ。
Hello, world!を表示するために最初に教えたいが、
本当のことを知るには関数、代数的データ型、型クラス、モナド等々、
いくつもの知識が必要で、
むしろHello, world!の真相を知ったころにはHaskellの基本はほとんど学べた
ことになる。
この書籍では中間をねらったようだ。
モナドについて説明する前に「副作用の分離」という側面でIOを扱っている。
個人的な考えではむしろ「副作用の分離」はIOモナドという本質的にクリーンな
考えかたの副作用であると考えている。
IOモナドという美しい抽象化をしたら結果として副作用が分離された、といった感じだ。
</p>

<p>
「入出力をさきに学びたい」という需要がどのくらいあるのかという話だ。
他の言語を学んできた人達ならばそこまで入出力に飢えていないのではないだろうか。
</p>

<p>
僕ならばファンクターやモナドの考えかたに十分親しんでもらったあと、
それとは関係なくIOマシンの結合のしかたを考えていき、
あら不思議IOマシンはモナドの枠組みにおさまりますね、といった話にしたい。
</p>

<h3>第9章 入出力</h3>

<p>
8章と9章はHaskell自体を理解するには不要だ。
たしかにHaskellで何か面白いことをするには入出力は必要だ。
しかしHaskellの真髄を理解したうえでその土台のうえでこれらを学べば良いかと思う。
Haskell初心者であってもプログラミング初心者ではない層を仮定すれば、
あるいは完全なプログラミング初心者であれば、
入出力をそんなにあせることはないかと思われる。
</p>

<h4>random, bytestring</h4>

<p>
randomとbytestringの話題は何かものを作るときに必要だ。
Haskellの真髄を理解するには不要だ。
だからHaskellを理解したあとに紹介するのが良いかと思われる。
</p>

<h3>10章 関数型問題解決法</h3>

<p>道路網の例題はなかなか優れていると感じる。</p>

<h2>詳細: 第11章から第14章まで</h2>

<h3>全体的に</h3>

<p>
ファンクターからアプリカティブへ、そしてモナドへと強力になっていく概念を説明し、
そのうえでいくつかの一般的なモナドを説明している。
これは非常に示唆的ではあるが、初心者にとってわかりやすい導入かどうかは疑問だ。
むしろファンクターとモナドは別々の概念として説明したほうがわかりやすいと思う。
そのうえで中級的な話題としてモナドは実はファンクター+joinだよという話をし、
さらにファンクターとモナドとのあいだにアプリカティブがあり、
そのアプリカティブによってアプリカティブスタイルでコードが書けるという説明を
するといった感じか。
</p>

<p>
モノイドをこの流れで学習する必然性はないようにも思う。
Writerモナドの説明には必要だけど。
WriterモナドはとりあえずたとえばLoggerモナドとしてStringを使っておくとか。
もっとモナドまで一直線のほうが初学者にはわかりやすいように思う。
</p>

<h3>第11章 ファンクターからアプリカティブへ</h3>

<h4>ファンクター</h4>

<p>
ここでIOや関数をファンクターの例として挙げるのはどうなのだろうか。
もうすこし自作の型を作ったり練習したあとのほうが良さそうだ。
</p>

<p>
ファンクター則に触れているのは良い。
法則を破ってみる例を挙げているのも実際に手を動かせるので良い。
</p>

<h4>アプリカティブ</h4>

<p>
はじめの導入の<code>fmap (\f -&gt; f 9) a</code>の例はミスリーダブルだ。
この例はないほうがわかりやすいように思う。
</p>

<p><small>ちなみにミスリーダブルという言葉はない。多分。</small></p>

</p><small>
<code>(&lt;*&gt;)</code>のすごさは以下のように考えるとよりはっきりするかも。
<code>f (a -&gt; b -&gt; c &gt; d &gt; e) -&gt; f a -&gt; f (b -&gt; c -&gt; d -&gt; e)</code>
</small></p>

<p>
本当ならファンクターにはなりうるけどアプリカティブにはなりえない
データ構造の例を挙げられるとわかりやすいのだけど、にわかには思いつかない。
</p>

<p>ZipListについては「へー」という感じ。</p>

<p>アプリカティブ則について触れているのはとても良い。</p>

<p>sequenceAも良いと思うが入門には不要だ。</p>

<h3>第12章 モノイド</h3>

<p>
もしもモノイドを教えるのならばもっと前、ファンクターよりも前で良いと思う。
ここで教えるのはファンクター、アプリカティブ、モナドという流れの勢いをそぐ。
</p>

<h4>newtype</h4>

<p>
ここでnewtypeを教えるのはまあ良いような悪いようなといった感じ。
訳注のGeneralizedNewtypeDerivingは良い。
</p>

<p>
newtypeと遅延評価の関係の説明は非常に良い。
入門には不要だが、必ずどこかで学んでおいたほうが良い内容だ。
</p>

<p>
「Haskellは怒りを爆発させます(専門用語では例外を逃げるともいいます)」の
フレーズは好き。
</p>

<h4>モノイド</h4>

<p>モノイド則が紹介されているのは良い。</p>

<p>Orderingがモノイドだって話は「おー」って感じだ。</p>

<p>
Foldableは畳み込みをリストからより一般的なデータに拡張する。
これも入門には必要ないだろう。
けど、いつかは学んだほうが良さそうだ。
ただし、こういった抽象化の動物園はいくら学んでもきりがないという面もある。
</p>

<h3>第13章 モナドがいっぱい</h3>

<p>これは「ジブリがいっぱい」を意識してるのかな?</p>

<h4>アプリカティブの強化</h4>

<p>
ファンクター、アプリカティブ、モナドのような順で理解していくのは、
「モナドを理解する最も楽な道」ではない。
ファンクターとモナドは別々に学んだほうがわかりやすいように僕は思う。
以下の関係は確かにキャッチーだが、それは理解のしやすさとは関係ない。
</p>

<p><code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></p>

<p><code>(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</code></p>

<p><code>(=&lt;&lt;) :: (a -&gt; m b) -&gt; m a -&gt; m b</code></p>

<p>
さらにそれが本当にモナドの本質かと言えば、
そのような抽象の網目は複雑でどちらの方向やどちらの経路がより本質的か
という上下関係のようなものはない。
たとえばArrowのほうからMonadのほうへいくことも可能だ。
もちろん僕もArrowよりApplicativeのほうが好きだけど。
</p>

<p>
ただし7.10ではApplicativeの型クラス制約がつくこともある。
どうしよっかな。
アプリカティブは説明する必要がありそうだ。
</p>

<p>綱渡りの例はまあまあ良いかな。</p>

<p>
関数guardはMonadPlusが必要になる。
リスト内包表記を説明するのならこれも必要かもしれない。
</p>

<p>モナド則の説明は良い。</p>

<h3>第14章 もうちょっとだけモナド</h3>

<p>
Writer、Reader、State、Errorモナドを紹介している。
モナドを紹介するときにStateモナドをより具体的にしたものを
例として出すとわかりやすいだろう。
ここで差分リストを紹介しているが中級的な内容だ。
</p>

<p>
モナディック関数liftM, join, filterM, foldMを紹介している。
関数joinのところはすこし面白い。
</p>

<h2>詳細: 第15章</h2>

<p>
zipperはひとつの手法として興味深いし便利だし使いたい。
しかし入門的な話ではない。
</p>

<h2>詳細: 付録</h2>

<p>
Textの話とOverloadedStrings拡張の話、ViewPatterns拡張の話が出ている。
それぞれ役には立つがとくに本質的な話ではない。
</p>

<h2>アマゾンでの評価</h2>

<p>おおむね好評価だ。</p>

<h3>pro</h3>

<ul>
<li>モナドの説明が丁寧</li>
<li>内容が新しい</li>
<li>Functor -&gt; Applicative -&gt; Monad</li>
<li>短い練習問題</li>
<li>コード例が数学っぽくない</li>
<li>ポップな雰囲気</li>
<li>解説の範囲が広い
	<ul>
	<li>読み終えたら自分でコーディングできるかも</li>
	</ul></li>
</ul>

<h3>contra</h3>

<ul>
<li>翻訳がプログラミング初心者用ではない</li>
<li>真ん中あたりから訳文がとっちらかっている</li>
<li>サンプルコードが適切じゃない</li>
<li>型シグネチャの説明もキチンとされていない</li>
<li>著者が解っているところは詳しく、わかっていないところはさらっと</li>
</ul>

<h2>ブログ</h2>

<p><a href="http://bleis-tift.hatenablog.com/entry/20120524/1337860594"
	>bleisさんの書評</a></p>

<ul>
<li>ノリで「すごい」とだけ言う人たちがいる</li>
<li>その人たちに乗せられて買ってしまって挫折してしまう人が出てきそう</li>
<li>この本を読んでHaskellが分からなくても大丈夫です</li>
<li>この本は簡単な本ではありません</li>
<li>色々と言葉が足りないかな</li>
<li>タプルに関しては...リストと...まぎらわしいだけだと</li>
<li>この本だけでバリバリHaskellを使ってプログラムが書けるように...そうではない</li>
<li>「どう進めばいいか」に対するポインタが何一つない</li>
<li>素晴らしい本であることは間違いない</li>
</ul>

<p><a href="http://attonblog.blogspot.jp/2013/07/haskell.html"
	>attonさんの書評</a></p>

<ul>
<li>いろいろとさらえた感じ</li>
<li>data, class
	<ul>
	<li>この辺からあやしい</li>
	<li>型変数が無い型はenumみたい</li>
	<li>型変数があるやつはclass的に扱えば良いのかな</li>
	<li>自分でデータ型を定義とかしないと恩恵や実感湧かなそう</li>
	<li>classはなんかJavaのInterfaceチック</li>
	</ul></li>
<li>Functor, Applicative Functor
	<ul>
	<li>この辺までくると言われたことをやってる感じ</li>
	<li>Functorで包む利点ってなんなのかなー</li>
	</ul></li>
<li>Monad
	<ul>
	<li>よー分かんない感じになってくる</li>
	<li>自分なりにMonadを作ってみようとしたけれどghcに怒られる</li>
	</ul></li>
<li>Haskell分かってない</li>
</ul>

<p><a href="http://d.hatena.ne.jp/keigoi/20120526/sugoih"
	>keigoiさんの書評</a></p>

<ul>
<li>とっても親しみやすい内容と文体</li>
<li>構成についても、順序を踏んで丁寧に書かれている</li>
<li>日本語(マルチバイト文字)の扱いを付録で解説しているのもポイント高い</li>
<li>イントロはHaskellの概要をやさしい文体で、でもしっかり説明
	<ul>
	<li>純粋さと参照透明性の重要さ</li>
	<li>遅延評価</li>
	<li>型付け</li>
	<li>型推論</li>
	<li>「Haskellはエレガントで簡潔です」</li>
	</ul></li>
<li>翻訳が読みやすい</li>
<li>補足説明やNOTEが親切
	<ul>
	<li>型の周りのエラーの読み方</li>
	<li>数値リテラルは実はすごいやつで、整数にも浮動小数にもなれる</li>
	<li>項や型の読み方をその時点で必要な分だけ丁寧に説明して</li>
	<li>最も重要な「型」は2章で読み方とともに基本が丁寧に解説されます</li>
	<li>2.4節で型クラスの基本が分かってしまうのはお得感があるね</li>
	</ul></li>
<li>ヤマ場では挿絵が内容を説明する
	<ul>
	<li>foldとか再帰とか二分探索とか</li>
	</ul></li>
<li>前半のゴールともいれる「7.8 型クラス 中級講座」
	<ul>
	<li>JavaScriptを引き合いに出して、YesNoという型クラスを作って遊んでみる</li>
	<li>プログラミング的楽しさがよく出ている</li>
	</ul></li>
<li>実用も意識している
	<ul>
	<li>IOは8章でモナド無しで(do構文で)導入される</li>
	<li>ByteStringが9章で紹介され、文字列処理は高速にチューニングできるんだよ、と</li>
	</ul></li>
<li>逆ポーランド電卓と単純化した最短路問題を解きます
	<ul>
	<li>「たのしく」て、かつ手ごろ</li>
	</ul></li>
<li>Applicativeの次にモナド
	<ul>
	<li>Applicativeという中間ステップを踏めば、たしかに概念的なジャンプが少なくなる</li>
	<li>IOアクション同士をつなぐ方法としてApplicativeを最初に使っている</li>
	<li>pure (++) &lt;*&gt; getLine &lt;*&gt; getLine</li>
	<li>(++) str1 str2の関数適用の空白を&lt;*&gt;に置き換えればこの形になる</li>
	<li>IOアクションを合成する最初の方法として良い感じ</li>
	</ul></li>
<li>「綱渡り」
	<ul>
	<li>Applicativeではデメで、モナドが必要な理由が明らかになる</li>
	<li>「普通の値を取り、モナド値を返す関数」の必要性</li>
	</ul></li>
<li>後半戦の最初のヤマ場、すごいHaskellな所はリストモナドだ。納得</li>
<li>無いのはContモナドくらいのものだけど、あれ私はあんまり使わないし</li>
<li>pureなzipper
	<ul>
	<li>モナドなくてもHaskellすごい</li>
	</ul></li>
<li>15.5節、感動のフィナーレが</li>
<li>ApplicativeやZipperの章は真面目にやってなかったので役に立ちました</li>
<li>付録、マルチバイト文字とViewPatternとの組み合わせも面白い</li>
<li>訳語表があるのも信頼できます</li>
<li>Hackageの紹介を8章の訳注扱いにとどめるのではなく、
	付録とかでHaskellの有用なライブラリを紹介できたらいいかなと
	<ul>
	<li>DB、Web、コンパイリ、並列など面白いトピックは多い</li>
	<li>それ特有の難しさはある</li>
	<li>枯れやすいとか</li>
	</ul></li>
</ul>
