X.690: ASN.1のBER方式の共通部分の存在型を利用したコーディング

<p>(工事中 0%)</p>

<h2>動機</h2>

<p>
エンコードとデコードは実は、たいていにおいて、完全なペアにはならない。
簡単なことをしているときにはそのズレは顕在化しないが、
複雑なことをし始めると、それが牙をむく。
今回、僕はその野獣に苦しめられた。
そもそもエンコードとデコードとは違うものだと考える必要がある。
</p>

<h2>デコード</h2>

<p>
デコードする対象はBER方式だ。
DERだろうがCERだろうがBERとして扱ってやれば良い。
</p>

<h2>エンコード</h2>

<p>
エンコードする対象はDERとCERを代表として、無限に存在する。
その無限に存在するエンコード関数をひとつにまとめておいて、
それらの特殊ケースとしてDERとCERのエンコード関数を表現できたら最高だが。
</p>

<h3>選択の可能性</h3>

<p>
すくなくとも以下の選択の可能性がある。
</p>

<ul>
<li>長さを指定するかしないか</li>
<li>長さを表現する値の桁数をどうするか</li>
<li>Primitiveな表現を選ぶかConstructedな表現を選ぶか</li>
</ul>

<p>
組み合わせは無限大、だ。
すると以下の値を引数として取れば良いのかもしれない。
</p>

<ul>
<li>長さを表現する値の桁数を指定しない場合も含めてMaybe Integerで
	<ul>
	<li>桁数は最小値を意味することとする</li>
	<li>よって「できるだけ短く」は1を指定すれば良いことになるだろう</li>
	<li>0にしたときにエラーにするか1と同じ結果にするべきか</li>
	</ul></li>
<li>Primitiveを選ぶかConstructedを選ぶかのBool値</li>
</ul>

<p>
これらの引数をネストするデータ構造のすべての層で指定する必要がある。
そうすれば、すべてのエンコードのしかたを表現することが可能だ。
しかし「すべての層で」指定することが可能かどうかという問題がある。
データ構造と同じ樹構造を持つ指定子を使ってやる必要があるだろう。
若干面倒だが、これらでDERやCERを指定できるなら、
それは美しいと思う。
</p>

<p>指定子の型</p>

<pre><code>data Sel = Sel (Maybe Integer, Bool) [Sel]</code></pre>

<p>ここで、リストが空であった場合「以下同様」を意味するもととする。</p>

<p>与えられたデータがPrimitiveかConstructedかでSelを変化させる必要がある。</p>

<pre><code>data Sel = Sel (DataType -&gt; ((Maybe Integer, Bool), [Sel]))</code></pre>

<p>
<a href="/computer/web/rfc/x_690/8_1_common/coding/existential"
	>「存在型を利用」トップへ</a>
</p>
