X.690: ASN.1のBER方式の共通部分の存在型を利用したコーディング: モジュールに分ける

<p>(工事中 10%)</p>

<h2>動機</h2>

<h3>現在のモジュール内での層</h3>

<p>
現在のAsnableモジュール内ですでにある程度の層構造がある。
decodeTagやdecodeLength、IntegerとByteStringとの変換関数等は、
より下の層と考えられる。
そして、class Asnableやinstance Asnableはより上の層にすることができる。
つまり、すでに自然な切れ目があるということだ。
</p>

<h3>今後大きくなる</h3>

<h4>orphan instance問題</h4>

<p>
<a href="http://maoe.hatenadiary.jp/entry/20100902/1283358286"
>maoeさんのブログ: Orphan Instances</a>参照。
</p>

<p>
orphan instanceという問題児がいる。
これはクラスが定義されている場所でも、データ型が定義されている場所でもない
場所にあるインスタンス宣言であり、予期しない問題を引き起こす。
</p>

<h3>orphan instnace問題の予防</h3>

<p>
orphan instance問題を予防するためには、よく使われる型については、
クラス宣言をしたモジュールでインスタンス宣言してやる必要がある。
このため、クラス宣言をしたモジュールはある程度肥大化する宿命にある。
</p>

<h3>Asnableクラス</h3>

<p>
AsnableモジュールではAsnableクラスを宣言している。
よって、このモジュール内によく使われる型に対するインスタンス宣言を
つめ込む必要がある。
</p>

<h3>だからモジュールを分割する</h3>

<p>
上述の2つの理由、「自然な切れ目がある」「今後大きくなる」ことより、
モジュールを2つに分けることが適当と判断した。
</p>

<h2>問題勃発</h2>

<h3>前置き</h3>

<p>
コーディングは紆余曲折ある。
一直線に進むことなんてない。
チュートリアルが一直線に進むのは、教師が自分のなかで紆余曲折した結果だ。
ASN.1のデコード・エンコードなんて簡単だと思ったので、
チュートリアル的に開発してやろうと思ったのだが、
僕の好みを満足させようとするとなかなか複雑になる。
まあ、紆余曲折のまま、このページは進めて、
後から「そのまま残す」か「一直線」に直すかを決めることにしよう。
</p>

<h3>モジュールを分けたい</h3>

<p>
BER形式の部分集合としてDER形式とCER形式とがある。
なのでBerモジュールをimportするDerモジュールとCerモジュールとを作りたい。
</p>

<h3>デコードとエンコードに対象性を持たせたい</h3>

<p>
BER形式でデコードした結果をDER形式でエンコードしたい。
これらは相互に可能であって欲しい。
しかし、今の設計でそれをするとBerモジュール内にDerモジュールに依存する
部分が出てきてしまう。
</p>

<h3>上記2つの矛盾</h3>

<p>
BerモジュールのうえにDer, Cerモジュールを乗せたいが、
BerモジュールがDerモジュールに依存する部分が出てきてしまう。
</p>

<h3>問題の一般化</h3>

<p>
符号Aの部分集合としての符合Bがある。
符号Aをデコードしてデータ型Tを得られる。
またデータ型Tをエンコードして符号Bを得られる。
このとき、符合Aのデコードはデータ型Tに依存する。
データ型Tは符合Bに存在する。
しかし符号Aは符号Bに依存しないほうが良い。
妥協なしでこれを解決できるか。
あるいは妥協するとすれば何を妥協するべきか。
</p>

<h3>うまくいかない解1</h3>

<p>
符合Aをデコードして型Taを作る。
型Taを型Tbに変換したうえで符号Bにエンコードする。
そういう方法が考えられる。
しかし、存在型を利用しているので、
型Taを型Tbに変換しようとしても、
型Ta自体に符号Bにエンコード可能という性質が必要になる。
</p>

<h3>解2</h3>

<p>
型T自体にエンコード規則を含めてしまうという方法も考えられる。
すると、流れとしては以下のようになる。
符合Aを型Tにデコードする。
この時点で型Tは空のエンコード規則を持っている。
型Tに符号Bのエンコード規則を与えてやる。
型Tを符号Bにエンコードする。
このやりかたならうまくいくような気がする。
つまりたとえばBool等のエンコードのやりかたにバリエーションのないものでは、
その型に共通のエンコードルールを用意し、
SEQUENCE等のエンコードのやりかたにバリエーションのあるものには、
値ごとに別々のエンコードルールを用意してやるというやりかた。
そして、たとえばDerモジュールは型Tの値に対してエンコード規則を
再帰的に与えてやるようなコードを作る。
つまりBerクラスにはgetEncodeRuleとsetEncodeRuleが必要になるだろう。
</p>

<p>
解2のやりかたで、ひとつやってみることにしよう。
</p>

<p>
<a href="/computer/web/rfc/x_690/8_1_common/coding/existential/decode_rule.html"
	>「ルールをクラスに」へもどる</a>
<a href="/computer/web/rfc/x_690/8_1_common/coding/existential"
	>「存在型を利用」トップへ</a>
</p>
