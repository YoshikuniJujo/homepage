X.690: ASN.1のBER方式の共通部分のコーディング

<p>(工事中 15%)</p>

<h2>工事予定</h2>

<p><a href="/computer/haskell/coding/binary_analyzer"
	>バイナリ解析器</a>を使うように書き直していく</p>

<p><a href="/computer/haskell/coding/binary_analyzer/coding/ListLike.hs"
	>ListLike.hs</a>
<a href="/computer/haskell/coding/binary_analyzer/coding/Analyzer.hs"
	>Analyzer.hs</a></p>

<h2>目標</h2>

<p>
ASN.1のBER方式の仕様のデータ型に関係ない共通部分まで読んだので、
ここまでの内容のみをHaskellコード化してみることにする。
</p>

<h2>使用するモジュール</h2>

<p><a href="/computer/haskell/coding/binary_analyzer"
>バイナリ解析器の作成</a>で作った以下のモジュールを使用する。</p>

<ul>
<li><a href="/computer/haskell/coding/binary_analyzer/coding/ListLike.hs"
	>ListLike.hs</a></li>
<li><a href="/computer/haskell/coding/binary_analyzer/coding/Analyzer.hs"
	>Analyzer.hs</a></li>
</ul>

<h2>データ型の決定</h2>

<pre><code>data Asn1 = Asn1 Asn1Tag ByteString
	deriving Show</code></pre>
<pre><code>data Asn1Tag = Asn1Tag TagClass DataClass Integer
	deriving Show</code></pre>
<pre><code>data TagClass =
	Universal | Application | ContextSpecific | Private
	deriving Show</code></pre>
<pre><code>data DataClass = Primitive | Constructed
	deriving Show</code></pre>

<p>参考: <a href="https://hackage.haskell.org/package/bytestring"
	>bytestringパッケージ</a></p>

<h2>デコード関数</h2>

<p>用意したテスト用ファイルで試しながらデコード関数を作成していく。</p>

<p>テスト用ファイル: <a href="/computer/web/rfc/x_690/example/test_ASN_1_cert.der"
>test_ASN_1_cert.der</a>(<a
href="/computer/web/rfc/x_690/example/test_ASN_1_cert.der.hex.txt"
>16進ダンプ</a>)</p>

<pre><code>decode1 :: (ListLike a, Element a ~ Word8) =&gt; Analyzer Asn1
decode1 = Asn1 &lt;$&gt; decodeTag &lt;*&gt; decodeContents</code></pre>

<pre><code>decodeTag :: (ListLike a, Element a ~ Word8) =&gt; Analyzer a Asn1Tag
decodeTag = undefined</code></pre>

<pre><code>decodeContents :: (ListLike a, Element a ~ Word8) =&gt; Analyzer ByteString
decodeContents = undefined</code></pre>

<p><a href="/computer/web/rfc/x_690/8_1_common/DecodeAsn1Common.hs"
	>DecodeAsn1Common.hs</a></p>

<h2>エンコード関数</h2>
