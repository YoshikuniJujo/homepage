X.690: ASN.1のBER方式の共通部分のコーディング

<p>(工事中 20%)</p>

<h2>目標</h2>

<p>
ASN.1のBER方式の仕様のデータ型に関係ない共通部分まで読んだので、
ここまでの内容のみをHaskellコード化してみることにする。
</p>

<h2>使用するモジュール</h2>

<p><a href="/computer/haskell/coding/binary_analyzer"
>バイナリ解析器の作成</a>で作った以下のモジュールを使用する。</p>

<ul>
<li><a href="/computer/haskell/coding/binary_analyzer/coding/ListLike.hs"
	>ListLike.hs</a></li>
<li><a href="/computer/haskell/coding/binary_analyzer/coding/AnalyzerE.hs"
	>Analyzer.hs</a></li>
</ul>

<h2>データ型の決定</h2>

<p>
Asn1はタグ(Asn1Tag)と内容(ByteString)から成る。
Asn1Tagはタグのクラス(TagClass)とデータのクラス(DataClass)とタグの番号から成る。
</p>

<pre><code>data Asn1 = Asn1 Asn1Tag ByteString
	deriving Show</code></pre>
<pre><code>data Asn1Tag = Asn1Tag TagClass DataClass Integer
	deriving Show</code></pre>
<pre><code>data TagClass =
	Universal | Application | ContextSpecific | Private
	deriving Show</code></pre>
<pre><code>data DataClass = Primitive | Constructed
	deriving Show</code></pre>

<h2>デコード関数</h2>

<h3>テスト用のファイル</h3>

<ul>
<li>テスト用証明書: <a
href="/computer/web/rfc/x_690/example/test_ASN_1_cert.der"
>test_ASN_1_cert.der</a>(<a
href="/computer/web/rfc/x_690/example/test_ASN_1_cert.der.hex.txt"
>16進ダンプ</a>)</li>
<li>テスト用Mainモジュール: <a
href="/computer/web/rfc/x_690/8_1_common/testDecodeAsn1Common.hs"
>testDecodeAsn1Common.hs</a></li>
</ul>

<h3>関数群の作成</h3>

<p>用意したテスト用ファイルで試しながらデコード関数を作成していく。</p>

<p><a href="/computer/web/rfc/x_690/8_1_common/DecodeAsn1Common.hs"
	>DecodeAsn1Common.hs</a></p>

<h4>タグのデコード</h4>

<h5>タグの1バイト目のデコード</h5>

<p>
タグの1バイト目を解析する。
8,7ビット目がタグのクラスを、
6ビット目はデータのクラスを表す。
残りの5から1ビットが0x1fであれば、
タグの番号は続くバイト列で決まる。
そうでなければ、この部分がタグの番号を示す。
</p>

<pre><code>decodeTag1 :: (ListLike a, Element a ~ Word8) =>
	Analyzer a (TagClass, DataClass, Maybe Word8)
decodeTag1 = do
	w &lt;- token
	let	tc = case w `shiftR` 6 of
			0 -&gt; Universal
			1 -&gt; Application
			2 -&gt; ContextSpecific
			3 -&gt; Private
			_ -&gt; error "never occur"
		dc = case (w .&amp;. 0x3f) `shiftR` 5 of
			0 -&gt; Primitive
			1 -&gt; Constructed
			_ -&gt; error "never occur"
		tn = case w .&amp;. 0x1f of
			0x1f -&gt; Nothing
			n	| n &lt; 0x1f -&gt; Just n
				| otherwise -&gt; error "never occur"
	return (tc, dc, tn)
</code></pre>

<p>試してみる。</p>

<pre><code>% ghci testDecodeAsn1Common.hs
*Main&gt; runAnalyzer decodeTag1 cert
Just ((Universal,Constructed,Just 16), "\130\ETXN0\130\STX
<a href="/computer/web/rfc/x_690/8_1_common/result1.txt"
>...</a>
\155\186\ACK\172")</code></pre>

<h5>タグの残りのバイトをデコード</h5>

<p>
8ビット目が1であれば後続のバイトが存在し、
0であればそこで終了。
読み込んできた値を保持しておき、
次のバイトがあれば保持してあった値を7ビット左シフトしたうえで、
そのバイトの値を足していく。
</p>

<pre><code>decodeTagR :: (ListLike a, Element a ~ Word8) =&gt;
	Integer -&gt; Analyzer a Integer
decodeTagR n = do
	w &lt;- token
	if testBit w 7
		then decodeTagR $ n `shiftL` 7 .|. fromIntegral (w .&amp;. 0x7f)
		else return $ n `shiftL` 7 .|. fromIntegral w</code></pre>

<p>
1バイト目のデコードの結果の長さのフィールドがJust [番号]であれば、
その[番号]がそのままタグの番号となり、Nothingならば残りのバイトを読み込む。
</p>

<pre><code>decodeTag :: (ListLike a, Element a ~ Word8) =&gt;
	Analyzer a Asn1Tag
decodeTag = do
	(tc, dc, mtn) &lt;- decodeTag1
	maybe (Asn1Tag tc dc &lt;$&gt; decodeTagR 0)
		(return . Asn1Tag tc dc . fromIntegral) mtn</code></pre>

<p>試してみる。</p>

<pre><code>% ghci testDecodeAsn1Common.hs
*Main> runAnalyzer decodeTag cert
Just ((Universal,Constructed,16), "\130\ETXN0\130\STX
<a href="/computer/web/rfc/x_690/8_1_common/result2.txt">...</a>
\155\186\ACK\172")</code></pre>

<h5>タグ番号とデータ形式のエラーチェック</h5>

<p>以下のような制約がある。</p>

<ul>
<li>番号が30以下の場合、1バイト形式で型番号を指定する</li>
<li>複数バイトでの指定のとき最上位バイトは0x00ではない</li>
</ul>

<p>これらの制約をdecodeTagRに織り込む。</p>

<h6>最上位バイトの制約</h6>

<pre><code>decodeTagR :: ...
decodeTagR 0 = do
	w &lt;- token
	when (w == 0x80) $ fail
		"Redundant byte for tag number"
	if testBit w 7
		then decodeTagR $ fromIntegral (w .&amp;. 0x7f)
		else return $ fromIntegral w
decodeTagR n = do
	...</code></pre>

<h6>30以下の場合の制約</h6>

<pre><code>decodeTagR0 :: (ListLike a, Element a ~ Word8) =&gt;
	Analyzer a Integer
decodeTagR0 = do
	n &lt;- decodeTagR 0
	when (n &lt;= 30) $ fail
		"Use single byte for tag number 0 - 30"
	return n</code></pre>

<pre><code>decodeTag :: ...
decodeTag = do
	(tc, dc, mtn) &lt;- decodeTag1
	maybe (Asn1Tag tc dc &lt;$&gt; decodeTagR0)
		(return . Asn1Tag tc dc . fromIntegral) mtn</code></pre>

<h6>変更後のモジュール</h6>
<p><a href="/computer/web/rfc/x_690/8_1_common/DecodeAsn1Common_1.hs"
>DecodeAsn1Common.hs</a></p>

<p>エラー用のテストデータを用意する。</p>

<p>試してみる。</p>

<h2>エンコード関数</h2>
