A*アルゴリズム

<p>(工事中 0%)</p>

<h2>はじめに</h2>

<p>
ダイクストラ法を改良したものである。
RPGなどのマップ上で障害物を考慮した場合の最短距離を求める場合等に使える。
</p>

<h2>基本的な考えかた</h2>

<p>
ダイクストラ法ではある地点から行けるすべてのノードへの距離を求める。
そのなかで最も近いノードを見つける。
そのノードにはそれよりも距離が短くなる経路は存在し得ない。
そのノードから他のノードへの距離を求め、
それともともとの距離との短いほうを新しい距離とする。
これをくりかえすことで最短距離を求めることができる。
</p>

<p>
それぞれのノードからゴールまでの予測値が計算でき、
その予測値が実際の値より大きくならないことが保証されている場合に、
A*アルゴリズムによってダイクストラ法よりも効率的に最短距離を求めることができる。
</p>

<!-- <p>
どのノードを選ぶかにヒューリスティックな手法を用いるのがA*のミソである。
</p> -->

<p>
また、単なるマス目上の移動であれば幅優先探索でも線形時間で解ける。
しかし幅優先探索では障害物が少なくスカスカな地図において効率があまり良くない。
</p>

<h2>アルゴリズム</h2>

<h3>ダイクストラ法との相違点</h3>

<p>
次に選択するノードを選ぶときに、
スタートからの距離の暫定値ではなく
スタートからの距離の暫定値とヒューリスティック関数によって
求められたゴールまでの距離の予測値との和によって
選択するノードを決める。
</p>

<h2>Haskellによる実装</h2>

<h3>型</h3>

<p>
「距離」は足し算と大小比較ができれば良いので(Ord d, Num d) =&gt; d
で良いだろう。
</p>

<p>
ノードはアイデンティティが分かれば良いだけなので(Eq n) =&gt; nとなるか。
</p>

<p>
「経路」は今いる場所と次の場所から距離が求まれば良いので
n -&gt; n -&gt; Maybe dがひとつ考えられる。
ただこの場合、ノードの数とくらべて経路の数が比較的少ない場合には、
非効率となるかもしれない。
n -&gt; [n]のように次のノードをしぼりこむ関数も追加で欲しいかもしれない。
経路の数が多くなると非効率的になるが、
ここでは簡単のため両者を合わせてn -&gt; [(n, d)]のようにしよう。
</p>

<p>
あとはヒューリスティック関数の型を考えよう。
ノードから与えられたゴールまでの予測値を出せば良い。
n -&gt; n -&gt; dで良いかと思う。
</p>

<p>
結果として作るべき関数の型は以下のようになるだろう。
</p>

<p><code>astar :: (Eq n, Ord d, Num d) =&gt; (n -&gt; [(n, d)]) -&gt;<br/>
	<span class="indent2"> (n -&gt; n -&gt; d) -&gt;
		n -&gt; n -&gt; Maybe d</span></code></p>

<p>
とりあえずは経路の情報は捨ててしまい最短距離だけを求めることにする。
</p>
