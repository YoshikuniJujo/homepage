差分リスト

<h2>リストの構造</h2>

<p>
リストというデータ構造がある。
先頭要素と残りのリストという形で要素の並びを表現する。
[1, 2, 3]という並びを考えると、
これは 1 : [2, 3]というようになっている。
そして[2, 3]の部分もやはり、2 : [3]となる。
最後は空リストが残るので[3]の部分は3 : []と考えられる。
</p>

<p>
このような形をしているので「先頭へのアクセス」「先頭への追加」「先頭の削除」の
効率が良く、後ろへのアクセスになればなるほど効率が低下する。
</p>

<h2>リストの結合</h2>

<p>2つのリストl1, l2を結合する場合、以下のように考えれば良い。</p>

<p>「l1の先頭以外の部分とl2を結合したものがl1とl2を結合したものである」</p>

<p>これをHaskellで書くと以下のようになる。</p>

<pre><code>l1 ++ l2 = head l1 : (tail l1 ++ l2)</code></pre>

<p>
tail l1 ++ l2の部分もまた(tail l1)の先頭部分と残りの部分とに分けて考えれば良い。
このようにしていくと、残りの部分が空リストになるときがくる。
そしたら空リストとl2を結合したものはl2に等しいので、再帰はそこで止まることになる。
この再帰的な操作はl1の要素数分だけくりかえされることになる。
</p>

<h2>複数のリストの結合</h2>

<p>
4つのリストas, bs, cs, dsがありそれぞれの長さが3, 4, 9, 2だったとする。
このとき以下の2つの結合のしかたを比較してみよう。
</p>

<pre><code>((as ++ bs) ++ cs) ++ ds</code></pre>

<pre><code>as ++ (bs ++ (cs ++ ds))</code></pre>

<p>
リストの結合にかかる時間は前のほうのリストの長さに比例するので、
ひとつめの結合方法でかかる時間は以下のようになる。
<p>

<pre><code>3 + (3 + 4) + (3 + 4 + 9) = 26</code></pre>

<p>それに対してふたつめの結合方法では</p>

<pre><code>3 + 4 + 9 = 16</code></pre>

<p>つまり右側のリスト同士を先に結合したほうが効率が良いということだ。</p>

<h2>右側からの結合を強制する</h2>

<h3>関数を差分リストとして考える</h3>

<p>
差分リストを使って右側からの結合を強制したい。
Haskellでは差分リストを関数で表現することができる。
</p>

<pre><code>type DiffList a = [a] -&gt; [a]</code></pre>

<p>
リストを取ってリストを返す関数である。
リストの前に別のリストの要素を追加する関数であれば、
この関数はリストの「差分」を保持していると考えられる。
</p>

<h3>リストを差分リストに変換する</h3>

<p>リストxsを「リストxsを何かのリストの前に追加する関数」に変換する。</p>

<pre><code>fromList xs = \ys -&gt; xs ++ ys</code></pre>

<p>演算子の部分適用を使えば以下のようになる。</p>

<pre><code>fromList xs = (xs ++)</code></pre>

<h3>差分リストをリストに変換する</h3>

<p>差分リストを普通のリストにするには空リストに差分を適用すれば良い。</p>

<pre><code>toList dxs = dxs []</code></pre>

<h3>差分リスト同士の結合を考える</h3>

<p>
2つの差分リストを結合するということは、
後のほうに来る差分リストを適用してから前のほうに来る差分リストを適用する
ということだ。
</p>

<pre><code>dxs `append` dys = \zs -&gt; dxs (dys zs)</code></pre>

<p>
これは単なる関数結合と同じことなので、以下のようにも書ける。
</p>

<pre><code>append = (.)</code></pre>

<h3>リストの結合を差分リストの結合にする</h3>

<p>以下のような結合を考える。</p>

<pre><code>as ++ bs ++ cs ++ ds</code></pre>

<p>上で定義した関数を使って差分リストに変換してから結合する。</p>

<pre><code>fromList as `append` fromList bs
	`append` fromList cs `append` fromList ds $ []</code></pre>

<p>fromList xsは(xs ++)と同じであり、appendは(.)と同じなので以下のようになる。<p>

<pre><code>(as ++) . (bs ++) . (cs ++) . (ds ++) $ []</pre></code>

<p>
このようにすれば(as ++) . (bs ++)を先に行ったとしても、
結果的にはリストの結合は右結合となる。
</p>

<h2>結論</h2>

<p>
直接リストを結合した場合、左から先に結合するか右から先に結合するかで、
実行効率は大きく変化してしまう。
しかし、差分リストを利用して結合すると、どのように結合しても、
最終的なリストの結合は右結合となり、効率が良い。
</p>

<p>
Haskellでは関数とデータの境界がないので、
関数をそのまま差分リストとして扱うことができる。
</p>

<small><a href="/computer/programming/algorithm/difference_list/lecture19.hs"
	>lecture19.hs</a></small>

<p>
<a href="/computer/programming/algorithm">「アルゴリズム」のトップへもどる</a>
</p>
