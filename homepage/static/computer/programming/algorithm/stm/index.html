STM(ソフトウェアトランザクショナルメモリ)

<h2>仲裁更新という問題</h2>

<h3>木の実の数を数えるという例</h3>

<p>
以下の流れのなかで本来は23 -> 43となるはずの記録が
23 -> 35となってしまっている。
</p>

<ol>
<li>Aさんが記録を見て「現在の木の実の個数」を調べる</li>
<li>木の実の個数は23である</li>
<li>Aさんは23に8を足して31を記録しようとする</li>
<li>31を記録する前にBさんが「現在の木の実の個数」を調べる</li>
<li>木の実の個数の記録はまだ23である</li>
<li>Bさんは23に12を足して35を記録しようとする</li>
<li>Aさんが実際に31を記録する</li>
<li>Bさんが実際に35を記録する</li>
</ol>

<p><a href="/computer/programming/algorithm/interceding_update.html">詳細</a></p>

<h2>STMという解決</h2>

<p>
<p><a href="/computer/programming/algorithm/lock"
>ロックによる解決</a>には様々な問題があった。
その問題のうちいくつかはSTMによって解決される。
</p>

<h3>基本的な考えかた</h3>

<p>
ロックでは「ロック状態」と「非ロック状態」をスレッド間をまたぐ大局的な
状態として共有することで仲裁更新を避けた。
STMでは扱う値の変更前の値を保存することで「矛盾なく更新できるかどうか」という
判断をローカルに行う。
</p>

<p>
つまり、ローカルなコピーを作成することで、共有される状態を減らしたということ。
スレッドの独立性を高めることで、並行実行に伴う様々な問題を解決すると同時に、
操作の並列性を高め、実行効率の向上も期待できる。
</p>

<h3>上記の例の場合</h3>

<p>上の例をSTMで実行すると以下のようになる。</p>

<ol>
<li>Aさんが共有の記録を見て「現在の木の実の個数」を調べる</li>
<li>木の実の個数は23である</li>
<li>Aさんのメモ帳に「演算前の値」として23を記録する</li>
<li>Aさんのメモ帳に23に8を足した31を記録する</li>
<li>共有の記録へのコピー前にBさんが「現在の木の実の個数」を調べる</li>
<li>木の実の個数は23である</li>
<li>Bさんのメモ帳に「演算前の値」として23を記録する</li>
<li>Bさんのメモ帳に23に12を足した35を記録する</li>
<li>Aさんが共有の記録を見て「現在の木の実の個数」を調べる</li>
<li>メモしておいた「演算前の値」と同じである</li>
<li>矛盾は生じないのでメモ帳から31を共有の記録にコピー</li>
<li>Bさんが共有の記録を見て「現在の木の実の個数」を調べる</li>
<li>メモしておいた「演算前の値」と異なる</li>
<li>よってメモ帳の35という値は破棄される</li>
<li>Bさんのメモ帳に新しい「演算前の値」として31を記録</li>
<li>Bさんのメモ帳に31に12を足した43を記録する</li>
<li>共有の記録を見て「現在の見の実の個数」を調べる</li>
<li>メモしておいた「演算前の値」と同じ31である</li>
<li>矛盾は生じないのでメモ帳から43を共有の記録にコピーする</li>
</ol>

<h4>Aさんのしたこと</h4>

<ol>
<li>共有の記録を見て「現在の木の実の個数」を調べる</li>
<li>木の実の個数(23)を「演算前の値」としてメモする</li>
<li>23に8を足した値(31)を「演算後の値」としてメモする</li>
<li>共有の記録を見て「現在の木の実の個数」を調べる</li>
<li>メモしておいた「演算前の値」(23)と同じである</li>
<li>矛盾は生じないのでメモしておいた値(31)を共有の記録にコピーする</li>
</ol>

<h4>Bさんのしたこと</h4>

<ol>
<li>共有の記録を見て「現在の木の実の個数」を調べる</li>
<li>木の実の個数(23)を「演算前の値」としてメモ</li>
<li>23に12を足した値(35)を「演算後の値」としてメモ</li>
<li>共有の記録を見て「現在の木の実の個数」を調べる</li>
<li>メモしておいた「演算前の値」(23)と異なる値(31)である</li>
<li>矛盾が生じるのでメモしておいた値(35)を破棄する</li>
<li>新しい「演算前の値」(31)をメモ帳に書く</li>
<li>31に12を足した値(43)を「演算後の値」としてメモする</li>
<li>共有の記録を見て「現在の木の実の個数」を調べる</li>
<li>メモしておいた「演算前の値」(31)と同じである</li>
<li>矛盾は生じないのでメモしておいた値(43)を共有の記録にコピーする</li>
</ol>

<h3>一般的には</h3>

<p>
STMによって管理する変数を変更する場合には、
まずは変更前の値をローカルに保存する。
それ以外にもうひとつ値のローカルなコピーを作成し、
それに対して演算を行う。
演算結果を共有の値にもどす前に、
変更前の値のローカルコピーともとの値とが同じであることを確認する。
同じであれば演算結果を共有の値として記録する。
そうでなければ、変更前の値のローカルコピーを作成するところからやりなおす。
</p>

<h3>図書館問題</h3>

<p>
ここでは便宜上「図書館問題」と呼んでおくが、以下のような問題がある。
図書館の司書が本の整理をするという例である。
</p>

<ol>
<li>整理前の図書館の状態を保存しておく</li>
<li>それとは別に図書館のローカルコピーを作成する</li>
<li>ローカルコピーを整理し始める</li>
<li>蔵書の整理にはかなり時間がかかる</li>
<li>整理している間に図書館の本を借りる人がいる</li>
<li>司書は整理前の図書館の状態と現在の状態とを比較</li>
<li>両者が食い違っているので最初からやり直す</li>
</ol>

<p>
長時間かかる作業の途中に短時間で終わる作業が挿入されることで、
長時間かかる作業のやり直しがしばしば発生し終了しなくなるということだ。
</p>

<h4>解決策</h4>

<p>
すべての場合に適用できる一般的な解決方法は(多分)ない。
</p>

<h5>作業を分割する</h5>

<p>
「蔵書の整理」という長時間かかる作業を粒度のより細かい作業に分割する。
まずは大雑把な分類を行い、さらに中分類、小分類を行い、
そのそれぞれについて整理を行っていく等。
それぞれの作業にかかる時間が「貸し出し」にかかる時間と同程度になれば、
図書館問題は解決する。
</p>

<h5>「同じ」の意味を変える</h5>

<p>
蔵書を整理する際には本の内容は必要ない。
なので、整理する対象が実際の書籍であったとしても、
本の代わりになる「代本」であったとしても問題ない。
つまり、「貸し出し」された書籍の代わりに書籍の情報を記録した代本を
置いておき、代本と書籍を同じものと見なせば、
「蔵書の整理」と「貸し出し」とは直交する作業とすることができる。
</p>

<small>参考: <a href="http://www.amazon.co.jp/Coders-Word-プログラミングの技をめぐる探求-Peter-Seibel/dp/4274068471"
>Peter Seibel「Coders at Work」ISBN: 978-4274068478</a></small>
