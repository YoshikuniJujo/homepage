巡回冗長検査(CRC)

<p>(工事中 0%)</p>

<h2>計算方法</h2>

<h3>一言でいうと</h3>

<p>特殊な剰余。</p>

<h3>2進数のわり算</h3>

<p>
2進数のわり算の余りを考えてみよう。
たとえば10011010 / 1010を考える。
まずはじめの4ビット1001は1010より小さい。
次の1ビットを追加して10011から1010を引く。
結果は1001となる。
次の1ビットを追加して10010から1010を引く。
すると1000となる。
同様に10001から1010を引いて111、
さらに1110から1010を引いて100となる。
</p>

<p>
これは10進数で考えると154 / 10のあまりが4ということだ。
</p>

<h3>引き算のかわりにxorを</h3>

<p>
2進数での計算では「1ビットずらして引き算」をくりかえしていた。
この「引き算」をxorとしてみよう。
</p>

<p>
上の例の10011010 / 1010では以下のようになる。
1001と1010のxorで0011となる。
2ビットずらして1110と1010のxorで0100となる。
1ビットずらして1001と1010のxorで0011となる。
1ビットずらして110が答えとなる。
</p>

<pre><code>    10011010
xor 1010
------------
    00111010
xor   1010
------------
    00010010
xor    1010
------------
    00000110</code></pre>

<p>この計算をmodulo 2と呼ぶ。</p>

<h2>すなおな実装</h2>

<p>modulo 2の計算のすすめかたは以下のようになる。</p>

<ol>
<li>わられる数の1となっている最上位のビットを探す</li>
<li>そのビットとわる数の最上位ビットの位置をあわせる</li>
<li>わられる数とわる数のそれぞれのビットについてxorをしたものでわられる数を更新</li>
<li>わる数とわられる数の最下位ビットの位置があっていれば終了</li>
<li>そうでなければ1へもどる</li>
</ol>

<h2>わる数の最上位ビットはいらない</h2>

<p>
わる数の最上位ビットは1だ。
そしてxorをするときには必ずわられる数の対応する位置のビットも1だ。
つまりxorした結果その位置のビットは必ず0となる。
よってxorする必要はなく単に捨ててしまえば良い。
これを考慮すると計算のしかたは以下のようになる。
</p>

<p>
ここでは「わる数'」を今まで考えてきた「わる数」の最上位ビットを捨てたものとする。
</p>

<ol>
<li>わられる数を最上位ビットbとその残りrにわける</li>
<li>bが0ならばrをわられる数とする</li>
<li>bが1ならばrとわる数'とを先頭をあわせてxorしたものをわられる数とする</li>
<li>最下位ビットの位置がそろっていればわられる数を結果とする</li>
<li>そうでなければ1へもどる</li>
</ol>

<h2>持ちまわる値を小さく</h2>

<p>
実用的には「わられる数」は非常に大きな値となる。
これを状態として持ちまわるのは非効率的だ。
持ちまわる必要があるのは実際にはわる数'がnビットであるならば
「わられる数」のうち先頭nビットだけでいい。
「わられる数」の残りは必要に応じて読みこんでいく。
</p>

<ol>
<li>先頭nビットを読みこむ</li>
<li>先頭nビットを最上位ビットbと残りrにわける</li>
<li>わられる数から1ビット読みこみ残りrの最下位に追加しsとする
	<ul>
	<li>ただし、読みこめなければ先頭nビットが結果となる</li>
	</ul></li>
<li>bが0ならばsを新しい先頭nビットとする</li>
<li>bが1ならばsとわる数'をxorしたものを新しい先頭nビットとする</li>
<li>2へもどる</li>
</ol>

<h2>テーブルを使う</h2>

<p>
わる数'がnビットであり、わられる数をたとえば8ビットずつ読みこむとする。
8ビット読みこんだところでわかるのは続くnビットが
この8ビットに対する操作によってどう変換されるか、だ。
テーブルを作成するために0から255の256通りの8ビット値eに対して
続くnビットに対して何をxorすることになるかを求める必要がある。
続くnビットに対してxorする値をtとする。
</p>

<ol>
<li>はじめにtにeを代入する</li>
<li>3から6を8回くりかえす</li>
<li>tを最上位ビットbと残りrにわける</li>
<li>rを左シフトする</li>
<li>bが0ならばrをtとする</li>
<li>bが1ならばrとわる数'とをxorしてtとする</li>
</ol>

<p>
テーブルが作れたら以下のようにする。
</p>

<ol>
<li>8ビット読みだす</li>
<li>テーブルから対応する値を読みこみtに代入</li>
<li>tを先頭8ビットeと残りrにわける</li>
<li>rを8ビット左シフトする</li>
<li>8ビット読みだしeとのxorをとりe'とする</li>
<li>e'に対応する値をテーブルから読みこみsとする</li>
<li>sとrとをxorしtに代入する</li>
<li>3へもどる</li>
</ol>

<p>
上記では終了条件が省略されている。
今までの計算と同じ結果とするにはわられる数の残りがnビットになった時点で
tとその残りとをxorすることになる。
</p>

<h2>わられる数の末尾にnビットの0を追加</h2>

<p>
上記の終了条件よりも「読みこめなくなった時点でtを結果とする」のほうが
コードがシンプルになる。
このようにすると意味的にはわられる数の末尾にnビットの0を追加したのと同じことになる。
</p>

<h2>先頭nビットを補数にする</h2>

<p>
上記の手続きは以下のように単純化することができる。
</p>

<ol>
<li>tに0を代入する</li>
<li>tを先頭8ビットeと残りrにわける</li>
<li>rを8ビット左シフトする</li>
<li>8ビット読みだしeとのxorをとりe'とする</li>
<li>e'に対応する値をテーブルから読みこみsとする</li>
<li>sとrとをxorしtに代入する</li>
<li>2へもどる</li>
</ol>

<p>
ここでtの初期値を0ではなく2 ^ n - 1(つまりすべてのビットが1)とする。
そうするとわられる数の先頭の0の個数によってチェックサムが変わってくる。
データの先頭に0が追加または削除されてしまうといったエラーを検出可能となる。
</p>

<p>
この操作は数学的な意味としては
わられる数の先頭のnビットのそれぞれのビット値を反転(0 -&gt; 1, 1 -&gt; 0)
するということになる。
</p>

<h2>リトルエンディアン</h2>

<p>
実際のCRCはリトルエンディアンで実装しやすい規格になっている。
つまり今までは最上位ビットから計算していたのを、
最下位ビットから順に計算していくようにすれば良い。
</p>

<!--

<h2>前処理と後処理</h2>

<h3>前処理</h3>

<ol>
<li>バイトごとにビット順序を反転する</li>
<li>4バイトの0を後置する</li>
<li>上位4バイトのビット値を反転する</li>
<li>ビッグエンディアンとして数値化</li>
</ol>

<h3>modulo 2</h3>

<ol>
<li>定められた除数(CRC-32では0x104c11db7)でmodulo 2の剰余を計算</li>
</ol>

<h3>後処理</h3>

<ol>
<li>ビット値を反転する</li>
</ol>

<h2>コーディングの工夫</h2>

<h3>ビット操作の工夫</h3>

<h4>ビットの反転</h4>

<p>
ビット演算はMSB(最上位ビット)からよりも
LSB(最下位ビット)から行っていくほうが簡単だ。
前処理のビット順序の反転はこのために行っている。
</p>

<h4>わる数の最上位ビットは不要</h4>

<p>
上から順に探していき1となるビットがあったときにxorをする。
そのビットとわる数の最上位ビット(1である)とのxorとなるので結果は
つねに0となる。
よってxorをする必要はなく1であるかどうかを確認したら読み捨てて良い。
つまり定数としてはCRC-32ならば0x04c11db7で良いことになる。
</p>

<h4>入力データ自体のビットの位置の反転はしない</h4>

<p>
前処理で入力データをバイト単位でビットの位置の反転をする。
しかし、実際のデータで反転するのではなく、
「反転して保存されている」とみなす。
そのように見なすので定数も反転して保存される。
CRC-32ならば0x04c11db7が0xedb88320となる。
</p>

<h3>テーブルによる最適化</h3>

<p>
1ビットずつの計算では効率が悪い。
8ビットずつまとめて計算する。
8ビットずつずらしながら変換を重ね合わせていく。
8ビットの値は256通りあるので、それらのすべてに対して、
以降の変換のしかたを示すテーブルを作成しておく。
</p>

-->

<h2>Haskellでの実装</h2>

<ul>
<li><a href="/computer/haskell/coding/error_detection/crc_theory"
	>CRCの理論</a>: 同じことをHaskellで説明</li>
<li><a href="/computer/haskell/coding/error_detection/crc32"
	>CRC-32</a>: zlib, PNGで使用されている</li>
</ul>
