巡回冗長検査(CRC)

<p>(工事中 0%)</p>

<h2>計算方法</h2>

<h3>一言でいうと</h3>

<p>特殊な剰余。</p>

<h3>2進数のわり算</h3>

<p>
2進数のわり算の余りを考えてみよう。
たとえば10011010 / 1010を考える。
まずはじめの4ビット1001は1010より小さい。
次の1ビットを追加して10011から1010を引く。
結果は1001となる。
次の1ビットを追加して10010から1010を引く。
すると1000となる。
同様に10001から1010を引いて111、
さらに1110から1010を引いて100となる。
</p>

<p>
これは10進数で考えると154 / 10 = 4ということだ。
</p>

<h3>引き算のかわりにxorを</h3>

<p>
2進数での計算では「1ビットずらして引き算」をくりかえしていた。
この「引き算」をxorとしてみよう。
</p>

<p>
上の例の10011010 / 1010では以下のようになる。
1001と1010のxorで0011となる。
2ビットずらして1110と1010のxorで0100となる。
1ビットずらして1001と1010のxorで0011となる。
1ビットずらして110が答えとなる。
</p>

<pre><code>    10011010
xor 1010
------------
    00111010
xor   1010
------------
    00010010
xor    1010
------------
    00000110</code></pre>

<h2>前処理と後処理</h2>

<h3>前処理</h3>

<ol>
<li>バイトごとにビット順序を反転する</li>
<li>4バイトの0を後置する</li>
<li>上位4バイトのビット値を反転する</li>
<li>ビッグエンディアンとして数値化</li>
</ol>

<h3>modulo 2</h3>

<ol>
<li>定められた除数(CRC-32では0x104c11db7)でmodulo 2の剰余を計算</li>
</ol>

<h3>後処理</h3>

<ol>
<li>ビット値を反転する</li>
</ol>

<h2>コーディングの工夫</h2>

<h3>ビット操作の工夫</h3>

<h4>ビットの反転</h4>

<p>
ビット演算はMSB(最上位ビット)からよりも
LSB(最下位ビット)から行っていくほうが簡単だ。
前処理のビット順序の反転はこのために行っている。
</p>

<h4>わる数の最上位ビットは不要</h4>

<p>
上から順に探していき1となるビットがあったときにxorをする。
そのビットとわる数の最上位ビット(1である)とのxorとなるので結果は
つねに0となる。
よってxorをする必要はなく1であるかどうかを確認したら読み捨てて良い。
つまり定数としてはCRC-32ならば0x04c11db7で良いことになる。
</p>

<h4>入力データ自体のビットの位置の反転はしない</h4>

<p>
前処理で入力データをバイト単位でビットの位置の反転をする。
しかし、実際のデータで反転するのではなく、
「反転して保存されている」とみなす。
そのように見なすので定数も反転して保存される。
CRC-32ならば0x04c11db7が0xedb88320となる。
</p>

<h3>テーブルによる最適化</h3>

<p>
1ビットずつの計算では効率が悪い。
8ビットずつまとめて計算する。
8ビットずつずらしながら変換を重ね合わせていく。
8ビットの値は256通りあるので、それらのすべてに対して、
以降の変換のしかたを示すテーブルを作成しておく。
</p>

<h2>Haskellでの実装</h2>

<ul>
<li><a href="/computer/haskell/coding/error_detection/crc32"
	>CRC-32</a>: zlib, PNGで使用されている</li>
</ul>
