支払いのしかたは何通り?

<p>(工事中 0%)</p>

<h2>205円を作る</h2>

<p>きっかり205円を作るには何通りの組み合わせがあるだろうか。</p>

<ul>
<li>100円玉2枚と5円玉1枚</li>
<li>100円玉2枚と1円玉5枚</li>
<li>100円玉1枚と50円玉2枚と5円玉1枚</li>
<li>100円玉1枚と50円玉2枚と1円玉5枚</li>
<li>100円玉1枚と50円玉1枚と10円玉5枚と5円玉1枚</li>
<li>100円玉1枚と50円玉1枚と10円玉5枚と1円玉5枚</li>
<li>...</li>
<li>100円玉1枚と5円玉1枚と1円玉105枚</li>
<li>100円玉1枚と1円玉110枚</li>
<li>50円玉4枚と5円玉1枚</li>
<li>50円玉4枚と1円玉5枚</li>
<li>50円玉3枚と10円玉5枚と5円玉1枚</li>
<li>...</li>
<li>1円玉210枚</li>
</ul>

<p>かなりの数の組み合わせがありそうだ。これを再帰を使って考えてみよう。</p>

<h2>どう考えるか</h2>

<p>単純だが巧妙な再帰的な考えかたがある。</p>

<h3>基底部</h3>

<p>今回は基底を3つ考える。組み合わせの数は</p>

<ul>
<li>金額が0円のとき1通り</li>
<li>金額が負のとき0通り</li>
<li>金額が0円ではなくかつ使える通貨が存在しなければ0通り</li>
</ul>

<p>となる。</p>

<h3>再帰部</h3>

<p>100円玉、50円玉、10円玉、5円玉、1円玉の5種類の通貨で
205円を作る組み合わせの数は</p>

<ul>
<li>すくなくとも1枚の100円玉を使う組み合わせの数と</li>
<li>100円玉を使わない組み合わせの数</li>
</ul>

<p>
との和である。
「すくなくとも1枚の100円玉を使って205円を作る組み合わせの数」は
「5種類の通貨で105円を作る組み合わせの数」に等しい。
「5種類の通貨で105円を作った」状態を考えてみよう。
そのなかには100円を使っているものも使っていないものもある。
そのすべてに100円を追加してやれば
「すくなくとも1枚の100円玉を使って205円を作る」組み合わせができる。
</p>

<h3>どれかの基底へ</h3>

<p>
再帰によってどれかの基底に近づいていくことを説明する。
「すくなくとも1枚のm円玉を使ってa円にする組み合わせ」は
「a - m円をつくるすべての組み合わせ」と等しいのでm円ぶん金額が減少する。
「m円玉を使わない組み合わせ」は使える通貨が減少する。
金額か使える通貨のどちらかが減少するので最終的にはどれかの基底に到達する。
</p>

<h2>コード</h2>

<h3>引数と返り値</h3>

<p>
金額と使える通貨の2つの値を変化させながらの再帰的定義である。
求める関数の引数と返り値は以下のようになるだろう。
</p>

<ul>
<li>引き数1: 使える通貨のリスト</li>
<li>引き数2: 金額</li>
<li>返り値: 組み合わせの数</li>
</ul>

<h3>型</h3>

<p>金額の表現と組み合わせの数にInteger型の値を使うことにする。</p>

<p><code>changes :: [Integer] -&gt; Integer -&gt; Integer</code></p>

<h3>基底部</h3>

<p><code>change _ a | a &lt; 0 = 0<br/>
change _ 0 = 1<br/>
change [] _ = 0</code></p>

<h3>再帰部</h3>

<p><code>change ma@(m : ms) a = change ma (a - m) + change ms a</code></p>

<h2>自分用のコメント</h2>

<p>
この例題はもっとあとじゃないとだめだ。
パターンマッチでの@の使用はトリビアルなことだからいいけど、
リストをけずっていく再帰のしかたについてはもっとあとで学ぶ。
関数foldrやfoldlで表現できない例として紹介するべきだろう。
それとメモ化によってO(2^n)からO(m * n)くらいまで実効効率を改善できるはずだ。
メモ化の例として出したほうが良いかもしれない。
</p>
