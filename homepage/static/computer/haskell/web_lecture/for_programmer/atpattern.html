構文: @パターン

<h2>先頭の要素を2つにする</h2>

<p>先頭の要素を2つにする関数を考えよう。</p>

<h2>できた</h2>

<p><code>dupHead :: [a] -&gt; [a]<br/>
dupHead (x : xs) = x : x : xs<br/>
dupHead _ = []</code></p>

<p>いいね。できた。でも... </p>

<h2>二重化</h2>

<p>
気にいらない。
パターンマッチ(x : xs)でxとxsにわけたものを再びリストにまとめている。
わけたものをまたまとめるなんて無駄だ。
</p>

<h2>そこで@パターンですよ</h2>

<p>
@パターンを使えば変数を束縛したうえでその中身へのパターンマッチができる。
</p>

<p><code>dupHead xa@(x : _) = x : xa</code></p>

<p>引数のリストで変数xaを束縛したうえでさらに(x : _)でマッチしている。</p>

<h2>いいね</h2>

<p>Haskellは理論的に美しいだけではなく表記も美しい。</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/taketo_unfoldr.html"
	>「関数takeToの関数unfoldrによる定義」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/zipwith.html"
	>「関数zipWithの紹介」へ</a>
</p>
