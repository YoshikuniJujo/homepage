関数合成

<h2>演算子(.)</h2>

<h3>動作</h3>

<p>
演算子(.)は関数を合成する。
f . gは引数にgを適用した結果にfを適用する関数だ。
3足して2をかける関数は以下のように書ける。
</p>

<code>(* 2) . (+ 3)</code>

<p>試してみよう。</p>

<code>% ghci<br/>
Prelude&gt; ((* 2) . (+ 3)) 8<br/>
22</code>

<h3>定義</h3>

<p>演算子(.)の定義は以下のようになる。</p>

<p><code>(.) f g x = f (g x)</code></p>

<img
height="130"
alt="[関数dotの図]"
src="/computer/haskell/web_lecture/for_programmer/images/function_dot.svg"
/>

<p>
第3引数xに第2引数である関数gを適用した結果に第1引数であるfを適用する。
演算子であることを強調したければ以下のように書く。
</p>

<p><code>(f . g) x = f (g x)</code></p>

<p>あるいは</p>

<p><code>f . g = \x -&gt; f (g x)</code></p>

<img
height="130"
alt="[演算子dotの図]"
src="/computer/haskell/web_lecture/for_programmer/images/operator_dot.svg"
/>

<h3>使い道</h3>

<p>RSA暗号の例のxxcryptは以下のような定義だ。</p>

<code>xxcrypt n ed mc = mc ^ ed `mod` n</code>

<p>部分適用と関数合成で以下のように書き換えられる。</p>

<code>xxcrypt n ed = (`mod` n) . (^ ed)</code>

<p>「ed乗してnの剰余を取る」。</p>

<h3>型</h3>

<p>(.)の型はどうなるだろう。以下のような式を作る。</p>

<p><code>f . g</code></p>

<p>わかりやすさのために関数的な書きかたにする。</p>

<p><code>(.) f g</code></p>

<p>
g、fの順に適用するのでgの返り値とfの引数は同じ型だ。
gの型をa -&gt; bとしfの型をb -&gt; cとする。
結果としてできるf . gはgの引数を引数としfの返り値を返り値とする。
</p>

<p><code>f :: b -&gt; c<br/>
g :: a -&gt; b<br/>
f . g :: a -&gt; c</code></p>

<p>演算子(.)はf, gを引数としf . gを返り値とする。</p>

<p><code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code></p>

<h2>まとめ</h2>

<p>
いくつかの多相関数を見た。
多相関数とくに高階多相関数は制御構造と考えることができる。
Haskellでは独自の制御構造を単なる関数として定義可能だ。
</p>

<h2>課題</h2>

<ol>
<li>小文字にしてから文字コードを求める関数を関数合成によって定義せよ
	<ul>
	<li>Data.CharモジュールのtoLower, ordを使用する</li>
	</ul></li>
</ol>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/apply.html"
	>「関数適用」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/flip.html"
	>「引数を入れ替える」へ</a>
</p>
