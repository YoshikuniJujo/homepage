構文: リスト内包表記

<h2>はじめに</h2>

<p>
リスト内包表記というリストを変換するための表記法がある。
関数concatMapを使った表現に脱糖される。
</p>

<h2>mapの入れ子</h2>

<p>
リスト[1, 2, 3]と[4, 5]のすべての組み合わせでかけ算したい。
関数mapを入れ子にする。
</p>

<p><code>% ghci<br/>
Prelude&gt; map (\x -&gt; map (\y -&gt; x * y) [4, 5]) [1, 2, 3]<br/>
[[4,5],[8,10],[12,15]]</code></p>

<p>
「すべての組み合わせ」が欲しいので平坦なリストのほうが良い。
</p>

<p><code>Prelude&gt; concat $ map (\x -&gt; map (\y -&gt; x * y) [4, 5]) [1, 2, 3]<br/>
[4,5,8,10,12,15]</code></p>

<h2>concatMapの連鎖</h2>

<p>concatMapを使う。</p>

<p><code>% ghci<br/>
Prelude&gt; concatMap (\x -&gt; map (\y -&gt; x * y) [4, 5]) [1, 2, 3]<br/>
[4,5,8,10,12,15]</code></p>

<p>
[1, 2, 3]と[4, 5]と[6, 7]のすべての組み合わせでかけ算がしたい。
concatMapを入れ子にすれば良い。
</p>

<p><code>Prelude&gt; concatMap (\x -&gt; concatMap (\y -&gt; map (\z -&gt; x * y * z) [6, 7]) [4, 5]) [1, 2, 3]<br/>
[24,28,30,35,48,60,70,72,84,90,105]</code></p>

<p>
<code>concatMap (\y -&gt; map (\z -&gt; x * y * z) [6, 7]) [4, 5]</code>
の部分が何をするか考えてみよう。
[4, 5]と[6, 7]のすべての組み合わせのかけ算にxをかけたものを
数値のリストとして返す。
変数xを1, 2, 3でそれぞれ束縛してこの動作を行い、
結果のリストをconcatすれば良い。
</p>

<p>
3重、4重と次々に入れ子にしていける。
読みやすさのためにすこし書きかたを変えてみよう。
:{と:}は対話環境で複数行に分けるための括弧だ。
</p>

<p><code>Prelude&gt; :{<br/>
Prelude| (`concatMap` [1, 2, 3]) $ \x -&gt;<br/>
Prelude| (`concatMap` [4, 5]) $ \y -&gt;<br/>
Prelude| (`map` [6, 7]) $ \z -&gt;<br/>
Prelude| x * y * z<br/>
Prelude| :}<br/>
[24,28,30,35,48,60,70,72,84,90,105]</code></p>

<p>すこし工夫すると最後のmapをconcatMapにそろえられる。</p>

<p><code>Prelude&gt; :{<br/>
Prelude| (`concatMap` [1, 2, 3]) $ \x -&gt;<br/>
Prelude| (`concatMap` [4, 5]) $ \y -&gt;<br/>
Prelude| (`concatMap` [6, 7]) $ \z -&gt;<br/>
Prelude| [x * y * z]<br/>
Prelude| :}<br/>
[24,28,30,35,48,60,70,72,84,90,105]</code></p>

<p>このように表記すると入れ子というよりも連鎖といった感じになる。</p>

<h2>リスト内包表記</h2>

<p>
「すべての組み合わせで...する」という枠組みはしばしば出てくるので、
簡単に書ける構文糖が用意されている。
上記のconcatMapの連鎖を以下のように書くことができる。
</p>

<p><code>Prelude&gt; [ x * y * z | x &lt;- [1, 2, 3], y &lt;- [4, 5], z &lt;- [6, 7] ]<br/>
[24,28,30,35,48,60,70,72,84,90,105]</code></p>

<h2>ろ過</h2>

<p><code>Prelude&gt; [ x | x &lt;- [1, 2, 3, 4, 5] ]<br/>
[1,2,3,4,5]<br/>
Prelude&gt; [ x | x &lt;- [1, 2, 3, 4, 5], y &lt;- [] ]<br/>
[]</code></p>

<p>
[1, 2, 3, 4, 5]と[]のすべての組み合わせについて前者を返す。
空は何と組み合わせても空だ。
</p>

<p><code>Prelude&gt; [ x |
	x &lt;- [1, 2, 3, 4, 5],
	y &lt;- if even x then [111] else [] ]<br/>
[2,4]</code></p>

<p>
[1, 2, 3, 4, 5]のうち偶数とは[111]との組み合わせについて、
奇数では[]との組み合わせについて前者を返す。
これはろ過ということになる。
[111]は[123]でも['a']でも[False]でも何でも良い。
要素が1のリストであればどれでも同じ結果になる。
</p>

<h3>ユニット型</h3>

<p>
Haskellの型のうち最も単純な型はユニット型と呼ばれる型だ。
Bool型はTrueとFalseのふたつの値を持つ。
それに対してユニット型はひとつの値のみを持つ。
ユニット型の型は()と表記し値も()と表記される。
</p>

<p><code>Prelude&gt; let x = ()<br/>
Prelude&gt; x<br/>
()<br/>
Prelude&gt; :t x<br/>
x :: ()</code></p>

<p>
ユニット型はタプルとの類推で考えるとわかりやすい。
単なる値を1要素タプルと考える。
3要素タプルからユニット型まで順に並べてみる。
</p>

<p><code>(x, y, z), (x, y), (x), ()</code></p>

<p>ユニット型は0要素タプルと考えることができる。</p>

<h3>ユニット型でろ過</h3>

<p><code>Prelude&gt; [ x |
	x &lt;- [1, 2, 3, 4, 5],
	_ &lt;- if even x then [()] else [] ]<br/>
[2,4]</code></p>

<p>
ユニット型を使えば謎の値を書かなくてすむ。
この値には意味がない(つまり情報量が0)ということを明示的に示せる。
</p>

<h3>構文糖</h3>

<p>
もうすこし甘くしよう。
ろ過はよく使われるのでさらに砂糖をまぶすことができる。
if式の条件部分だけを直接置くことができる。
</p>

<p><code>Prelude&gt; [ x | x &lt;- [1, 2, 3, 4, 5], even x ]<br/>
[2,4]</code></p>

<h2>まとめ</h2>

<p>
concatMapを連鎖させていくことで
「すべての組み合わせに対して」演算を行うことができる。
このようなパターンは頻出なので構文糖が用意されている。
「リスト内包表記」と呼ばれる。
途中にろ過をはさむことができるがこれはより簡潔に書けるようになっている。
</p>

<h2>課題</h2>

<ol>
<li>1から5の整数で三角形をつくれる3つ組をすべて求めよ</li>
<li>上記で順番をいれかえたものを同じと考える版を作成せよ</li>
</ol>

<!--
<h2>条件によってろ過</h2>

<p>
同じ枠組みを使って条件を指定したろ過が可能だ。
x, y, zの総和が13以下のものだけをとりだそう。
</p>

<p><code>Prelude&gt; :{<br/>
Prelude| (`concatMap` [1, 2, 3]) $ \x -&gt;<br/>
Prelude| (`concatMap` [4, 5]) $ \y -&gt;<br/>
Prelude| (`concatMap` [6, 7]) $ \z -&gt;<br/>
Prelude| (`concatMap` if x + y + z &lt;= 13 then [()] else []) $ \_ -&gt;<br/>
Prelude| [x * y * z]<br/>
Prelude| :}</code></p>
-->

<a href="/computer/haskell/web_lecture/for_programmer/filter_concatmap.html"
	>「関数concatMapによる関数filterの定義」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/parser_prelude.html"
	>「パーサ: はじめに」へ</a>
</p>
