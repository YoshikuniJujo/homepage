関数takeWhile, dropWhile, span

<p>(工事中 0%)</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/codes/takewhiles.hs"
	>takewhiles.hs</a></p>

<h2>関数takeWhile</h2>

<h3>動作</h3>

<p>条件を満たすかぎりリストから値をとりだし続ける。</p>

<p><code>% ghci<br/>
Prelude&gt; takeWhile even [4, 10, 8, 2, 5, 4, 1, 3, 2, 9]<br/>
[4,10,8,2]</code></p>

<h3>型</h3>

<p><code>takeWhileRaw, takeWhileF, takwWhileU :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>

<h3>生の再帰</h3>

<p><code>takeWhileRaw p (x : xs) | p x = x : takeWhileRaw p xs<br/>
takeWhileRaw _ _ = []</code></p>

<p>
先頭の値が条件を満たせば残りのリストに同じ関数を適用した結果の先頭に
その値を追加したものが返り値となる。
</p>

<h3>関数foldr</h3>

<p><code>takeWhileF p = foldr (\x -&gt; if p x then (x :) else const []) []</code></p>

<p>
xが条件を満たせばそれを追加しそうでないならつねに空リストを返す関数で
たたみこみを行っている。
</p>

<h3>関数unfoldr</h3>

<p><code>takeWhileU p = unfoldr $ \l -&gt; case l of<br/>
	<span class="indent1">x : xs | p x -&gt; Just (x, xs)</span><br/>
	<span class="indent1">_ -&gt; Nothing</span></code></p>

<p>
リストが空リストではなく先頭の値xが条件を満たすならば結果のリストにxを追加し、
残りのリストを次の処理にわたす。
</p>

<h2>関数dropWhile</h2>

<h3>動作</h3>

<p>条件を満たすあいだリストから値を落とす。</p>

<p><code>Prelude&gt; dropWhile even [4, 10, 8, 2, 5, 4, 1, 3, 2, 9]<br/>
[5,4,1,3,2,9]</code></p>

<h3>型</h3>

<p><code>dropWhileRaw, dropWhileF :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>

<h3>生の再帰</h3>

<p><code>dropWhileRaw p (x : xs) | p x = dropWhileRaw p xs<br/>
dropWhileRaw _ xs = xs</code></p>

<p>
先頭が条件を満たすならばそれを落として同じ処理を続ける。
そうでないならそのままのリストを返す。
</p>

<h3>関数foldr</h3>

<p>
foldrを使うためには「条件を満たさないものがまだない」ということを
示すフラグが必要になる。
</p>

<p><code>step x f True<br/>
	<span class="indent1">| p x = f True</span><br/>
	<span class="indent1">| otherwise = x : f False</span><br/>
step x f False = x : f False</code></p>

<p><code>dropWhileB p (x : xs) b = step x (dropWhileB p xs) b<br/>
dropWhileB _ _ _ = []</code></p>

<p>step x (dropWhileB p xs) bを展開してみる。</p>

<p><code>dropWhileB p (x : xs) True<br/>
	<span class="indent1">| p x = dropWhileB p xs True</span><br/>
	<span class="indent1">| otherwise = x : dropWhileB p xs False</span><br/>
dropWhileB p (x : xs) False = x : dropWhileB p xs False<br/>
dropWhileB _ _ _ = []</code></p>

<p>
まずは展開前と展開後のコードをよく見くらべてみよう。
同じであることがわかるだろうか。
次に展開後のコードの動きを追ってみよう。
値xが条件pを満たさなくなったあとは第3引数のBool値はずっとFalseのままになる。
うえのコードの仮引数bを消す。
</p>

<p><code>dropWhileB p (x : xs) = step x (dropWhileB p xs)<br/>
dropWhileB _ _ = const []</code></p>

<p>foldrで表現できる。</p>

<p><code>dropWhileB p = foldr step (const [])</code></p>

<p>フラグの初期値としてTrueを与える。</p>

<p><code>dropWhileF p = foldr step (const []) True</code></p>

<p>ローカル関数で書き直す。</p>

<p><code>dropWhileF p xs = foldr s (const []) xs True<br/>
	<span class="indent1">where</span><br/>
	<span class="indent1">s x f True</span><br/>
		<span class="indent2">| p x = f True</span><br/>
		<span class="indent2">| otherwise = x : f False</span><br/>
	<span class="indent1">s x f False = x : f False</span></code></p>

<h2>関数span</h2>

<h3>動作</h3>

<h3>型</h3>

<h3>生の再帰</h3>

<h2>まとめ</h2>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/take_def.html"
	>「関数take, drop, splitAt」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer"
	>「1から学ぶHaskell」トップへ</a>
</p>
