関数takeWhile, dropWhile, span

<p><a href="/computer/haskell/web_lecture/for_programmer/codes/takewhiles.hs"
	>takewhiles.hs</a></p>

<h2>関数takeWhile</h2>

<h3>動作</h3>

<p>条件を満たすかぎりリストから値をとりだし続ける。</p>

<p><code>% ghci<br/>
Prelude&gt; takeWhile even [4, 10, 8, 2, 5, 4, 1, 3, 2, 9]<br/>
[4,10,8,2]</code></p>

<h3>型</h3>

<p><code>takeWhileRaw, takeWhileF, takwWhileU :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>

<h3>生の再帰</h3>

<p><code>takeWhileRaw p (x : xs) | p x = x : takeWhileRaw p xs<br/>
takeWhileRaw _ _ = []</code></p>

<p>
先頭の値が条件を満たせば残りのリストに同じ関数を適用した結果の先頭に
その値を追加したものが返り値となる。
</p>

<h3>関数foldr</h3>

<p><code>takeWhileF p = foldr (\x -&gt; if p x then (x :) else const []) []</code></p>

<p>
xが条件を満たせばそれを追加しそうでないならつねに空リストを返す関数で
たたみこみを行っている。
</p>

<h3>関数unfoldr</h3>

<p><code>takeWhileU p = unfoldr $ \l -&gt; case l of<br/>
	<span class="indent1">x : xs | p x -&gt; Just (x, xs)</span><br/>
	<span class="indent1">_ -&gt; Nothing</span></code></p>

<p>
リストが空リストではなく先頭の値xが条件を満たすならば結果のリストにxを追加し、
残りのリストを次の処理にわたす。
</p>

<h2>関数dropWhile</h2>

<h3>動作</h3>

<p>条件を満たすあいだリストから値を落とす。</p>

<p><code>Prelude&gt; dropWhile even [4, 10, 8, 2, 5, 4, 1, 3, 2, 9]<br/>
[5,4,1,3,2,9]</code></p>

<h3>型</h3>

<p><code>dropWhileRaw, dropWhileF :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>

<h3>生の再帰</h3>

<p><code>dropWhileRaw p (x : xs) | p x = dropWhileRaw p xs<br/>
dropWhileRaw _ xs = xs</code></p>

<p>
先頭が条件を満たすならばそれを落として同じ処理を続ける。
そうでないならそのままのリストを返す。
</p>

<h3>関数foldr</h3>

<p>
foldrを使うためには「条件を満たさないものがまだない」ということを
示すフラグが必要になる。
</p>

<p><code>step x f True<br/>
	<span class="indent1">| p x = f True</span><br/>
	<span class="indent1">| otherwise = x : f False</span><br/>
step x f False = x : f False</code></p>

<p><code>dropWhileB p (x : xs) b = step x (dropWhileB p xs) b<br/>
dropWhileB _ _ _ = []</code></p>

<p>step x (dropWhileB p xs) bを展開してみる。</p>

<p><code>dropWhileB p (x : xs) True<br/>
	<span class="indent1">| p x = dropWhileB p xs True</span><br/>
	<span class="indent1">| otherwise = x : dropWhileB p xs False</span><br/>
dropWhileB p (x : xs) False = x : dropWhileB p xs False<br/>
dropWhileB _ _ _ = []</code></p>

<p>
まずは展開前と展開後のコードをよく見くらべてみよう。
同じであることがわかるだろうか。
次に展開後のコードの動きを追ってみよう。
値xが条件pを満たさなくなったあとは第3引数のBool値はずっとFalseのままになる。
うえのコードの仮引数bを消す。
</p>

<p><code>dropWhileB p (x : xs) = step x (dropWhileB p xs)<br/>
dropWhileB _ _ = const []</code></p>

<p>foldrで表現できる。</p>

<p><code>dropWhileB p = foldr step (const [])</code></p>

<p>フラグの初期値としてTrueを与える。</p>

<p><code>dropWhileF p = foldr step (const []) True</code></p>

<p>ローカル関数で書き直す。</p>

<p><code>dropWhileF p xs = foldr s (const []) xs True<br/>
	<span class="indent1">where</span><br/>
	<span class="indent1">s x f True</span><br/>
		<span class="indent2">| p x = f True</span><br/>
		<span class="indent2">| otherwise = x : f False</span><br/>
	<span class="indent1">s x f False = x : f False</span></code></p>

<h2>関数span</h2>

<h3>動作</h3>

<p>リストを条件を満たさなくなるまでと残りとにわける。</p>

<p><code>Prelude&gt; span even [4, 10, 8, 2, 5, 4, 1, 3, 2, 9]<br/>
([4,10,8,2],[5,4,1,3,2,9])</code></p>

<h3>型</h3>

<p><code>spanRaw, spanF :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])</code></p>

<h3>生の再帰</h3>

<p><code>spanRaw p (x : xs) | p x = (x : t, d) where (t, d) = spanRaw p xs<br/>
spanRaw _ xs = ([], xs)</code></p>

<p>
先頭の値が条件を満たすうちはタプルの第1要素に値を追加する。
そうでなければ第1要素は空リストで第2要素は与えられたリストとするタプルを返す。
</p>

<h3>関数foldr</h3>

<p><code>step p x f True | p x = (x : t, d) where (t, d) = f True<br/>
step _ x f _ = ([], x : d) where (_, d) = f False</code></p>

<p><code>spanB :: (a -&gt; Bool) -&gt; [a] -&gt; Bool -&gt; ([a], [a])<br/>
spanB p (x : xs) b = step p x (spanB p xs) b<br/>
spanB _ _ _ = ([], [])</code></p>

<p>step p x (spanB p xs) bを展開する。</p>

<p><code>spanB p (x : xs) True | p x = (x : t, d) where (t, d) = spanB p xs True<br/>
spanB p xs _ = ([], x : d) where (_, d) = spanB p xs False</code></p>

<p>
うえの式としたの式が等しいことを確認する。
そのうえでしたの式の動きを見てみよう。
p xを満たすうちはタプルの第1要素に値が追加しれていくが、
p xを満たさなかった時点からはBool値はずっとFalseのままとなり、
第2要素に値が追加されていくということだ。
仮引数bを消す。
</p>

<p><code>spanB p (x : xs) = step p x (spanB p xs)<br/>
spanB _ _ = const ([], [])</code></p>

<p>関数foldrで表せる。</p>

<p><code>spanB p = foldr (step p) (const ([], []))</code></p>

<p>ブール値の初期値としてTrueを与える。</p>

<p><code>spanF p = foldr (step p) (const ([], [])) True</code></p>

<p>ローカル関数を使う。</p>

<p><code>spanF p xs = foldr s (const ([], [])) xs True
	<span class="indent1">where</span><br/>
	<span class="indent1">s x f True | p x = (x : t, d) where (t, d) = f True</span><br/>
	<span class="indent1">s x f _ = ([], x : d) where (_, d) = f False</span></code></p>

<h2>まとめ</h2>

<p>
関数takeWhile, dropWhile, spanを生の再帰と関数foldrで定義した。
関数dropWhileやspanには補助的にブール値が必要になる。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/take_def.html"
	>「関数take, drop, splitAt」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/filter_unfoldr.html"
	>「関数unfoldrとdropWhileによるfilterの定義」へ</a>
</p>
