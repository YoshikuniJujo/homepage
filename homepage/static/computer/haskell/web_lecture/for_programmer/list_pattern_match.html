リストのパターンマッチ

<p>(工事中 5%)</p>

<h2>リストは再帰的なデータ構造</h2>

<h3>リストの先頭に要素を追加</h3>

<p>リストの先頭に要素を追加するには演算子(:)を使う。</p>

<p><code>% ghci<br/>
Prelude&gt; 8 : [3, 5, 7]<br/>
[8, 3, 5, 7]<br/>
Prelude&gt; 'H' : "ello"<br/>
"Hello"</code></p>

<h3>空リスト</h3>

<p>要素数0のリストを'[]'のように表記する。</p>

<p><code>Prelude&gt; []<br/>
[]</code></p>

<h3>リストの構造</h3>

<p>先頭への追加演算子と空リストを使ってリストを作成することができる。</p>

<p><code>Prelude&gt; 8 : 3 : 5 : 7 : []<br/>
[8, 3, 5, 7]</code></p>

<p>
このリストは内部的に8 : 3 : 5 : 7: []という形で保存されていると考えて良い。
[8, 3, 5, 7]という表記はコンパイラが読みやすい形に直してくれただけで、
リストは本質的にx : y : z : ... : []という形のデータ構造だ。
</p>

<h3>再帰的</h3>

<p>
x : y : z : ... : []という構造は'要素 : [リスト]'という形である。
リストとは何かと聞かれたら以下のように答えられる。
「リストとはリストの先頭に要素を加えたもの、または空リストである」。
リストが再帰的に定義されていることがわかる。
以下の疑似コードを見てみよう。
</p>

<p><code>[a] = (a : [a]) or []</code></p>

<p>
Maybe a型の値がJust aまたはNothingだったのと同じように
[a]型の値はa : [a]または[]である。
</p>

<h2>リストへのパターンマッチ</h2>

<p>(作成中)</p>

<h2>関数head</h2>

<p>(作成中)</p>

<h2>関数tail</h2>

<p>(作成中)</p>

<h2>関数null</h2>

<p>(作成中)</p>

<h2>まとめ</h2>

<p>(作成中)</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/binary_tree.html"
	>「二分樹を下へたどる」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer"
	>「1から学ぶHaskell」トップへ</a>
</p>
