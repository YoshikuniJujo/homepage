リストのパターンマッチ

<h2>リストは再帰的なデータ構造</h2>

<h3>リストの先頭に要素を追加</h3>

<p>リストの先頭に要素を追加するには演算子(:)を使う。</p>

<p><code>% ghci<br/>
Prelude&gt; 8 : [3, 5, 7]<br/>
[8, 3, 5, 7]<br/>
Prelude&gt; 'H' : "ello"<br/>
"Hello"</code></p>

<h3>空リスト</h3>

<p>要素数0のリストを'[]'のように表記する。</p>

<p><code>Prelude&gt; []<br/>
[]</code></p>

<h3>リストの構造</h3>

<p>リストは先頭への追加演算子と空リストで作れる。</p>

<p><code>Prelude&gt; 8 : 3 : 5 : 7 : []<br/>
[8, 3, 5, 7]</code></p>

<p>
このリストは実は内部的に8 : 3 : 5 : 7: []という形で保存されていると考えられる。
[8, 3, 5, 7]という表記は対話環境で読みやすい形に直してくれただけだ。
リストは本質的にx : y : z : ... : []という構造のデータだ。
</p>

<h3>構文糖</h3>

<p>
[x, y, ... ,z]のような形での入力は構文糖である。
x : y : ... : z : []という形に解釈される。
また演算子':'は右結合であり、丸括弧を省略せずに書けば、
x : (y : (... : (z : []) ...))となる。
</p>

<h3>再帰的</h3>

<p>
x : y : z : ... : []という構造は'要素 : リスト'という形である。
リストとは何かと聞かれたら以下のように答えられる。
「リストとはリストの先頭に要素を加えたもの、または空リストだ」。
再帰的な定義だ。
疑似コードを示す。
</p>

<p><code>[a] = (a : [a]) or []</code></p>

<p>
Maybe a型の値がJust aまたはNothingだったのと同じように
[a]型の値はa : [a]または[]だ。
</p>

<h2>リストへのパターンマッチ</h2>

<p>リストは次の2つのどちらかだ。</p>

<ul>
<li>要素 : リスト</li>
<li>空リスト</li>
</ul>

<p>以下に示す2つのパターンでパターンマッチする。</p>

<ul>
<li>x : xs</li>
<li>[]</li>
</ul>

<p>
対象となるリストが空リストでなければx : xsにマッチし
リストの先頭の要素がxを束縛しリストの残りの部分がxsを束縛する。
「先頭の要素」と「残りの要素から成るリスト」を取り出すことになる。
空リストは[]にマッチする。
</p>

<h3>構文糖</h3>

<p>
パターンマッチにもリストの作成と同様の構文糖が使える。
以下のような表現でのパターンマッチができる。
</p>

<p><code>[x]<br/>
[x, y, z]</code></p>

<h2>関数head</h2>

<p>リストの先頭を取り出す関数headがある。</p>

<p><code>Prelude&gt; head [3, 4, 5]<br/>
3<br/>
Prelude&gt; head "Hello"<br/>
'H'</code></p>

<p>同じ動作をする関数myHeadを定義する。</p>

<p><code>myHead :: [a] -&gt; a<br/>
myHead (x : _) = x</code></p>

<h2>関数tail</h2>

<p>リストの残りの部分を取り出す関数もある。</p>

<p><code>Prelude&gt; tail [3, 4, 5]<br/>
[4,5]<br/>
Prelude&gt; tail "Hello"<br/>
"ello"</code></p>

<p>同様に関数myTailを定義する。</p>

<p><code>myTail :: [a] -&gt; [a]<br/>
myTail (_ : xs) = xs</code></p>

<h2>試してみる</h2>

<p><a href="/computer/haskell/web_lecture/for_programmer/16_list_pattern_match/myHeadTail.hs"
	>myHeadTail.hs</a></p>

<p><code>% ghci myHeadTail.hs<br/>
*Main&gt; myHead [3, 4, 5]<br/>
3<br/>
*Main&gt; myTail [3, 4, 5]<br/>
[4,5]<br/>
*Main&gt; myHead []<br/>
*** Exception: myHeadTail.hs:2:1-18: Non-exhaustive patterns in function myHead<br/>
<br/>
*Main&gt; myTail []<br/>
*** Exception: myHeadTail.hs:5:1-20: Non-exhaustive patterns in function myTail<br/>
<br/></code></p>

<p>
空リストに対しては「パターンが存在しない」というエラーが発生する。
</p>

<h2>部分関数</h2>

<p>
関数とはある集合から別の集合に値を対応づけるものだ。
たとえば逆数を求める関数は2を0.5に4を0.25に対応づける。
逆数関数は実数0に対して対応する値を持たない。
対応する値を持たない値がもとの集合にあるような関数は
「全域関数ではない部分関数」である。
</p>

<p>
headやtailは空リストに対して定義できないので全域関数ではない。
このような関数は慎重に使わないと予期せぬエラーの原因となる。
</p>

<h2>エラー値</h2>

<p>
パターンマッチを書かない場合上記のようにNon-exhaustive patternsという
エラーメッセージが表示される。
より明示的にエラー値を返すことができる。
定義済みのエラー値としてundefined値と関数errorとがある。
</p>

<p><code>*Main&gt; undefined<br/>
*** Exception: Prelude.undefined<br/>
*Main&gt; error "Beep! Beep!"<br/>
*** Exception: Beep! Beep!</code></p>

<p>
undefinedはコーディングの途中にスタブとして使うのに便利だ。
関数errorを使うと自分の好きなエラーメッセージを表示させられる。
関数errorは「起こり得ない場合」に使うことが望ましい。
</p>

<p>
myHeadのエラーメッセージをユーザーフレンドリーにしてみよう。
</p>

<p><code>myHead (x : _) = x<br/>
myHead _ = error "Bonehead!"</code></p>

<h2>関数null</h2>

<p>関数nullはリストが空かどうかをチェックする関数だ。</p>

<p><code>*Main&gt; null [1, 2, 3]<br/>
False<br/>
*Main&gt; null []<br/>
True<br/>
*Main&gt; null "hello"<br/>
False<br/>
*Main&gt; null ""<br/>
True</code></p>

<p>
リストに対するパターンマッチを行う。
わかりやすさのために冗長な書きかたをする。
</p>

<p><code>myNull :: [a] -&gt; Bool<br/>
myNull [] = True<br/>
myNull (_ : _) = False</code></p>

<p>
これは「空リストなら真、リストに要素をひとつ足したリストなら偽」ということだ。
もっと簡潔に書き直す。
</p>

<p><code>myNull [] = True<br/>
myNull _ = False</code></p>

<p>
「空リストなら真、そうでないなら偽」ということだ。
</p>

<h2>まとめ</h2>

<p>
リストは「リストの先頭に要素を足したものまたは空リスト」だ。
再帰的に定義される。
</p>

<p>
空でないリストはx : xsのように作られこの形で保存される。
リストはx : xsの形でパターンマッチできる。
[x, y, ..., z]のような表記は構文糖だ。
空リストは[]のように書き[]でパターンマッチできる。
</p>

<p>
リストを分解して使う関数はパターンマッチを使って書ける。
</p>

<p><code>fun (x : xs) = [xやxsを使った式]<br/>
fun [] = [空リストの場合の式]</code></p>

<p>[]の代わりにワイルドカードが使える。</p>

<p><code>fun (x : xs) = [xやxsを使った式]<br/>
fun _ = [空リストの場合の式]</code></p>

<p>空リストへのマッチを先にすることもできる。</p>

<p><code>fun [] = [空リストの場合の式]<br/>
fun (x : xs) = [xやxsを使った式]</code></p>

<h2>課題</h2>

<ol>
<li>与えられたリストの要素が複数であることを確認する関数pluralを定義せよ
	<ul>
	<li>英語の「複数形」の基準に従い空リストはTrueとする</li>
	</ul></li>
</ol>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/binary_tree.html"
	>「二分樹を下へたどる」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/sum.html"
	>「リストの総和」へ</a>
</p>
