関数take, drop, splitAt

<p><a href="/computer/haskell/web_lecture/for_programmer/codes/takes.hs"
	>takes.hs</a></p>

<h2>関数take</h2>

<h3>動作</h3>

<p>リストから指定した数の要素をとりだす。</p>

<p><code>% ghci<br/>
Prelude&gt; take 4 "monkey"<br/>
"monk"</code></p>

<h3>型</h3>

<p><code>takeRaw, takeU :: Int -&gt; [a] -&gt; [a]</code></p>

<h3>生の再帰</h3>

<p><code>takeRaw n (x : xs) | n &gt; 0 = x : takeRaw (n - 1) xs<br/>
takeRaw _ _ = []</code></p>

<p>x : xsからn個とるのは値xをxsからn - 1個とったリストに追加することだ。</p>


<h3>関数unfoldr</h3>

<p><code>takeU = curry . unfoldr $ \nl -&gt; case nl of<br/>
	<span class="indent1">(n, x : xs) | n &gt; 0 -&gt; Just (x, (n - 1, xs))</span><br/>
	<span class="indent1">_ -&gt; Nothing</span></code></p>

<p>結果としてxを出し、nを1減らしもとのリスト(x : xs)から要素をひとつ削る。</p>

<h2>関数drop</h2>

<h3>動作</h3>

<p>指定された数だけ頭から要素を落とす。</p>

<p><code>Prelude&gt; drop 3 "monkey"<br/>
"key"</code></p>

<h3>型</h3>

<p><code>dropRaw, dropF :: Int -&gt; [a] -&gt; [a]</code></p>

<h3>生の再帰</h3>

<p><code>dropRaw n (x : xs) | n &gt; 0 = dropRaw (n - 1) xs<br/>
dropRaw _ xs = xs</code></p>

<p>
nが0より大きいときリスト(x : xs)からn個落としたリストは
リストxsからn - 1個落としたリストに等しい。
もとのリストが空リストまたはnが0以下ならば空リストとなる。
</p>

<h3>関数foldr</h3>

<p><code>step _ f n | n &gt; 0 = f $ n - 1<br/>
step x f _ = x : f 0</code></p>

<p><code>fdrop :: [a] -&gt; Int -&gt; [a]<br/>
fdrop (x : xs) n = step x (fdrop xs) n<br/>
fdrop _ _ = []</code></p>

<p>これも同じようにstep x (fdrop xs) nを展開してみよう。</p>

<p><code>fdrop (x : xs) n | n &gt; 0 = fdrop xs (n - 1)<br/>
fdrop (x : xs) _ = x : fdrop xs 0<br/>
fdrop _ _ = []</code></p>

<p>仮引数nを消す。</p>

<p><code>fdrop (x : xs) = step x (fdrop xs)<br/>
fdrop _ _ = const []</code></p>

<p>関数foldrで表現する。</p>

<p><code>dropF = flip $ foldr s (const [])<br/>
	<span class="indent1">where</span><br/>
	<span class="indent1">s _ f n | n &gt; 0 = f $ n - 1</span><br/>
	<span class="indent1">s x f _ = x : f 0</span></code></p>

<h4>何が起きたのか</h4>

<p>
関数(step x)はnが1以上では「リスト[x1, x2, ...]からnだけ落とした関数」を
「リスト[x, x1, x2, ...]からnだけ落とした関数」に変換する。
nが0以下のときは「リスト[x1, x2, ...]から0だけ落とした関数」を
「リスト[x, x1, x2, ...]から0だけ落とした関数」に変換している。
後者の変換は返り値に(x :)することで行っている。
</p>

<h2>関数splitAt</h2>

<h3>動作</h3>

<p>リストの先頭n個をとりだし、その残りとともにタプルとして返す。</p>

<p><code>Prelude&gt; splitAt 3 "monkey"<br/>
("mon", "key")</code></p>

<h3>型</h3>

<p><code>splitAtRaw, splitAtF :: Int -&gt; [a] -&gt; ([a], [a])</code></p>

<h3>生の再帰</h3>

<p><code>splitAtRaw n (x : xs) | n &gt; 0 = (x : t, d)<br/>
	<span class="indent1">where (t, d) = splitAtRaw (n - 1) xs<br/>
splitAtRaw _ xs = ([], xs)</span></code></p>

<h3>関数foldr</h3>

<p><code>step x f n | n &gt; 0 = (x : t, d) where (t, d) = f (n - 1)<br/>
step x f _ = ([], x : d) where (_, d) = f 0</code></p>

<p><code>fsplitAt :: [a] -&gt; Int -&gt; ([a], [a])<br/>
fsplitAt (x : xs) n = step x (splitAt xs) n<br/>
fsplitAt _ _ = ([], [])</code></p>

<p>同様に展開する。</p>

<p><code>fsplitAt (x : xs) n | n &gt; 0 = (x : t, d)<br/>
	<span class="indent1">where (t, d) = fsplitAt xs (n - 1)</span><br/>
fsplitAt (x : xs) _ = ([], x : d)<br/>
	<span class="indent1">where (_, d) = fsplitAt xs 0</span><br/>
fsplitAt _ _ = ([], [])</code></p>

<p>仮引数nを消す。</p>

<p><code>fsplitAt (x : xs) = step x (splitAt xs)<br/>
fsplitAt _ = const ([], [])</code></p>

<p>関数foldrで定義する。</p>

<p><code>splitAtF = flip $ foldr s (const ([], []))<br/>
	<span class="indent1">where</span><br/>
	<span class="indent1">s x f n | n &gt; 0 = (x : t, d) where (t, d) = f (n - 1)</span><br/>
	<span class="indent1">s x f _ = ([], x : d) where (_, d) = f 0</span></code></p>

<h2>まとめ</h2>

<p>
関数take, drop, partitionをそれぞれ生の再帰とたたみこみで定義した。
リストを関数にたたみこむという考えたかに注意する。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/filter_def.html"
	>「関数filter, partition」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/takewhile_def.html"
	>「関数takeWhile, dropWhile, span」へ</a>
</p>
