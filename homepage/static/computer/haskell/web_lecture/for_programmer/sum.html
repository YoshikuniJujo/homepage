リストの要素の総和

<h2>はじめに</h2>

<p>
再帰関数を学びリストのパターンマッチを学んだ。
これでリストを引数としてとる再帰関数が定義できる。
リストの総和を求める関数sumを再定義してみよう。
</p>

<h2>関数sum</h2>

<p><code>% ghci<br/>
Prelude&gt; sum [3, 8, 2]<br/>
13</code></p>

<h2>関数mySum</h2>

<h3>型</h3>

<p>関数mySumはInteger型のリストからその総和を求める。</p>

<p><code>mySum :: [Integer] -&gt; Integer</code></p>

<h3>定義</h3>

<p>
リストとは「リストの先頭に要素を追加したもの」または「空リスト」だ。
リストを引数に取る関数はその2つでパターンマッチする。
</p>

<h4>空リスト</h4>

<p><code>mySum [] = ...</code></p>

<p>
空のリストの総和は何だろうか。
[3, 8, 2]の総和は13、[8, 2]の総和は10、[2]の総和は2である。
リストからひとつ数を消すとその消した数のぶんだけ総和が減少する。
よって[]の総和は[2]の総和から2を引いた値ならば良い。0だ。
空リストの総和は0である。
というよりも「空リストの総和を0とすると統一感がある」ということだ。
</p>

<p><code>mySum [] = 0</code></p>

<h4>空でないリスト</h4>

<p>
空でないリストについて考えてみよう。
[3, 8, 2]の総和は[8, 2]の総和に3を足したもの、
[8, 2]の総和は[2]の総和に8を足したもの、
[2]の総和は[]の総和に2を足したもの。
以下のような関係が成り立つ。
</p>

<p><code>mySum [3, 8, 2] == 3 + mySum [8, 2]<br/>
mySum [8, 2] == 8 + mySum [2]<br/>
mySum [2] == 2 + mySum []<br/>
mySum [] == 0</code></p>

<p>これを逆にたどればmySum [3, 8, 2]は13となる。</p>

<p><code>mySum [x1, x2, ..., x3] == x1 + mySum [x2, ..., x3]</code></p>

<p>先頭の要素と残りのリストはパターン(x : xs)によるマッチでとりだせる。</p>

<p><code>mySum (x : xs) = x + mySum xs</code></p>

<h3>出来上がり</h3>

<p><a href="/computer/haskell/web_lecture/for_programmer/17_sum/mySum.hs"
	>mySum.hs</a></p>

<p><code>mySum :: [Integer] -&gt; Integer<br/>
mySum [] = 0<br/>
mySum (x : xs) = x + mySum xs</code></p>

<h2>まとめ</h2>

<p>
リストの総和を求める再帰関数を作成した。
「空リストの総和は0である」と
「リストの総和は先頭の数と残りのリストの総和の和である」とを定義する。
リストを引数に取る再帰関数の多くがこの形で定義できる。
再帰関数を定義するときは以下のように考える。
</p>

<ul>
<li>基底ケースは何か</li>
<li>定義されている関数がすでに存在するものと考える</li>
<li>その関数をその関数自体でどう表現できるか
	<ul>
	<li>このとき引数が基底に近づくようにする</li>
	</ul></li>
</ul>

<p>
リストでは多くは空リストが基底となる。
そして先頭の要素を削除すると基底に近づく。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/list_pattern_match.html"
	>「リストのパターンマッチ」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/product.html"
	>「リストの要素の総積」へ</a>
</p>
