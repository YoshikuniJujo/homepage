データ構造としてのリスト

<h2>「くりかえし」の具象化</h2>

<p>
先に「くりかえし」の具象化としてのリストを取り上げたのは、
それがリストの本質だからである。
すくなくとも、それを意識して使うことで
リストの不適切な使いかたを避けることができるし、
反動としてリストを軽視することも避けることができる。
</p>

<h2>データ構造としてのリスト</h2>

<p>
リストはデータ構造でもある。
いろいろなデータをリストという形で保存して使うことができる。
しかし、リストを配列と同じように考えると、
まちがったアルゴリズムを設計してしまうことになる。
</p>

<p>
リストの本質が「くりかえし」の具象化であるということを意識することで、
これを避けることができる。
</p>

<p>
避けるべきである設計として、大きなリストへのランダムアクセスがある。
リストへのアクセスは要素の位置nに対してO(n)時間かかる。
これは配列においてO(1)であるのと比較するととても非効率だ。
なので、ランダムアクセスの必要な大きな並びにはリストは使わないほうが良い。
</p>

<p>
データ構造としてリストを採用するのに適するのは以下の場合である。
</p>

<ul>
<li>データは1回だけ順次アクセスすれば良い、または</li>
<li>要素数のすくない並びである、または</li>
<li>テスト用のプロトタイプを作成している</li>
</ul>

<p>
このようなときは、リストを使うことで、
その柔軟性やわかりやすさなどの恩恵を受けることができる。
</p>

<h2>リストのリテラル表記</h2>

<p>
短いリストであれば、以下のようにリテラル表記で表せば良い。
</p>

<pre><code>[3, 7, 8, 2, 9]</code></pre>

<p>要素となる値を先頭から順にコンマで区切って並べたものを角括弧で囲めば良い。</p>

<pre><code>% ghci
Prelude&gt; [3, 7, 8, 2, 9]
[3,7,8,2,9]
Prelude&gt; [True, False, False, True]
[True,False,False,True]
Prelude&gt; [1 + 2, 3 + 4, 5 + 6]
[3,7,11]</code></pre>

<h2>文字列はリストだった</h2>

<p>
Haskellでのデフォルトの文字列は単なる文字のリストである。
よって文字列を使うときは上記の条件を考える必要がある。
「文字列が文字のリストである」ことは以下のように確認できる。
</p>

<pre><code>Prelude&gt; "hello"
"hello"
Prelude&gt; ['h', 'e', 'l', 'l', 'o']
"hello"</code></pre>

<h2>リストの型</h2>

<p>
きちんと理解するには代数的データ型と多相型について学ぶ必要がある。
今のところはリストの型は要素の型を'['と']'で囲んだものと覚えておけば良い。
</p>

<pre><code>is :: [Integer]
is = [23, 15, 4, 9]</code></pre>

<pre><code>bs :: [Bool]
bs = [True, False, False, True]</code></pre>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/list_efficiency.html"
	>「空間効率」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/inf_list.html"
	>「無限リスト」へ</a>
</p>
