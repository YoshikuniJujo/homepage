データ構造としてのリスト

<h2>「くりかえし」の具象化</h2>

<p>
「くりかえし」としてのリストをさきに取り上げたのはそれがリストの本質だからだ。
それを意識して使うことでリストの不適切な使いかたを避けられる。
不適切な使いかたで痛い目にあい反動としてリストを軽視することは
Haskell中級者にありがちだ。
</p>

<h2>データ構造としてのリスト</h2>

<p>
リストはデータ構造でもある。
データをリストという形で保存して使うことができる。
しかし、リストを配列と同じように考えると非効率な設計となる。
リストの本質が「くりかえし」の具象化であるということを意識する。
</p>

<p>
避けるべき設計のひとつは大きなリストへのランダムアクセスだ。
リストへのアクセスは要素の位置nに対してO(n)時間かかる。
これは配列のO(1)と比較して効率が悪い。
ランダムアクセスの必要な大きな並びにはリストは使わない。
</p>

<p>
データ構造としてリストを採用するのに適するのは
</p>

<ul>
<li>データには1回だけ順次アクセスする、または</li>
<li>要素数がすくない、または</li>
<li>テスト用のプロトタイプである</li>
</ul>

<p>
このようなときはリストを使う。
柔軟性やわかりやすさなどのリストの長所が生きてくる。
</p>

<h2>リストのリテラル表記</h2>

<p>短いリストならリテラルとして書く。</p>

<p><code>[3, 7, 8, 2, 9]</code></p>

<p>要素の値を先頭から順にコンマで区切って並べ角括弧で囲む。</p>

<p><code>% ghci<br/>
Prelude&gt; [3, 7, 8, 2, 9]<br/>
[3,7,8,2,9]<br/>
Prelude&gt; [True, False, False, True]<br/>
[True,False,False,True]<br/>
Prelude&gt; [1 + 2, 3 + 4, 5 + 6]<br/>
[3,7,11]</code></p>

<h2>文字列はリストだ</h2>

<p>
Haskellのデフォルトの文字列は文字のリストだ。
デフォルトの文字列を使うときは上記の「リストを使うべき」である条件を考えよう。
「文字列が文字のリストである」ことを確認してみる。
</p>

<p><code>Prelude&gt; "hello"<br/>
"hello"<br/>
Prelude&gt; ['h', 'e', 'l', 'l', 'o']<br/>
"hello"</code></p>

<h2>リストの型</h2>

<p>
きちんと理解するのは代数的データ型と多相型について学んだあとだ。
リストの型は要素の型を'['と']'で囲んだものと覚えておく。
</p>

<p><code>is :: [Integer]<br/>
is = [23, 15, 4, 9]</code></p>

<p><code>bs :: [Bool]<br/>
bs = [True, False, False, True]</code></p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/list_efficiency.html"
	>「空間効率」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/inf_list.html"
	>「無限リスト」へ</a>
</p>
