データ構造としてのリスト

<h2>「くりかえし」の具象化</h2>

<p>
「くりかえし」としてのリストをさきに取り上げたのは、それがリストの本質だからだ。
それを意識して使うことでリストの不適切な使いかたを避けられる。
不適切な使いかたで痛い目にあい反動としてリストを軽視することは、
Haskell中級者にありがちだ。
</p>

<h2>データ構造としてのリスト</h2>

<p>
リストはデータ構造でもある。
データをリストという形で保存して使うことができる。
しかし、リストを配列と同じように考えると非効率な設計となりかねない。
リストの本質が「くりかえし」の具象化であるということを意識しよう。
</p>

<p>
避けるべき設計として大きなリストへのランダムアクセスがある。
リストへのアクセスは要素の位置nに対してO(n)時間かかる。
これは配列のO(1)と比較してとても効率が悪い。
ランダムアクセスの必要な大きな並びにはリストは使わない。
</p>

<p>
データ構造としてリストを採用するのに適するのは
</p>

<ul>
<li>データには1回だけ順次アクセスする、または</li>
<li>要素数がすくない、または</li>
<li>テスト用のプロトタイプである</li>
</ul>

<p>
このようなときはリストを使おう。
柔軟性やわかりやすさなどの恩恵が受けられる。
</p>

<h2>リストのリテラル表記</h2>

<p>短いリストならリテラル表記で表す。</p>

<p><code>[3, 7, 8, 2, 9]</code></p>

<p>要素の値を先頭から順にコンマで区切って並べ、角括弧で囲む。</p>

<p><code>% ghci<br/>
Prelude&gt; [3, 7, 8, 2, 9]<br/>
[3,7,8,2,9]<br/>
Prelude&gt; [True, False, False, True]<br/>
[True,False,False,True]<br/>
Prelude&gt; [1 + 2, 3 + 4, 5 + 6]<br/>
[3,7,11]</code></p>

<h2>文字列はリストだ</h2>

<p>
Haskellのデフォルトの文字列は単なる文字のリストだ。
デフォルトの文字列を使うときは上記の条件を考えよう。
「文字列が文字のリストである」ことを確認する。
</p>

<p><code>Prelude&gt; "hello"<br/>
"hello"<br/>
Prelude&gt; ['h', 'e', 'l', 'l', 'o']<br/>
"hello"</code></p>

<h2>リストの型</h2>

<p>
きちんと理解するには代数的データ型と多相型について学ぶ必要がある。
ここではリストの型は要素の型を'['と']'で囲んだものと覚えておこう。
</p>

<p><code>is :: [Integer]<br/>
is = [23, 15, 4, 9]</code></p>

<p><code>bs :: [Bool]<br/>
bs = [True, False, False, True]</code></p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/list_efficiency.html"
	>「空間効率」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/inf_list.html"
	>「無限リスト」へ</a>
</p>
