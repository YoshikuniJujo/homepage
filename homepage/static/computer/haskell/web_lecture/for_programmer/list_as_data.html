データ構造としてのリスト

<h2>「くりかえし」の具象化</h2>

<p>
「くりかえし」としてのリストをさきに見たのはそれがリストの本質だからだ。
それを意識して使うことでリストの不適切な使いかたが避けられる。
不適切な使いかたで痛い目にあい反動でリストを軽視するのはHaskell中級者にありがちだ。
</p>

<h2>データ構造としてのリスト</h2>

<p>
リストはデータ構造でもある。
データをリストという形で保存することができる。
しかし、リストを配列と同じように考えると非効率な設計となる。
リストの本質が「くりかえし」の具象化であるということを意識する。
</p>

<p>
避けるべき設計のひとつは大きなリストへのランダムアクセスだ。
リストへのアクセスは要素の位置nに対してO(n)時間かかる。
これは配列のO(1)と比較して効率が悪い。
ランダムアクセスの必要な大きな並びにはリストは使わない。
</p>

<p>データ構造としてリストを採用するのに適するのは</p>

<ul>
<li>データには1回だけ順次アクセスする、または</li>
<li>要素数がすくない、または</li>
<li>テスト用のプロトタイプ</li>
</ul>

<p>のときだ。柔軟性やわかりやすさなどのリストの長所が生きてくる。</p>

<h2>リストのリテラル表記</h2>

<p>短いリストならリテラルとして書く。</p>

<p><code>[3, 7, 8, 2, 9]</code></p>

<p>要素の値を先頭から順にコンマで区切って並べ角括弧で囲む。</p>

<p><code>% ghci<br/>
Prelude&gt; [3, 7, 8, 2, 9]<br/>
[3,7,8,2,9]<br/>
Prelude&gt; [True, False, False, True]<br/>
[True,False,False,True]<br/>
Prelude&gt; [1 + 2, 3 + 4, 5 + 6]<br/>
[3,7,11]</code></p>

<h2>文字列はリストだ</h2>

<p>
Haskellのデフォルトの文字列は文字のリストだ。
デフォルトの文字列を使うときは上記の「リストを使うべき」である条件を考えよう。
</p>

<p><code>Prelude&gt; "hello"<br/>
"hello"<br/>
Prelude&gt; ['h', 'e', 'l', 'l', 'o']<br/>
"hello"</code></p>

<h2>リストの型</h2>

<p>
代数的データ型と多相型について学んだあとに説明する。
リストの型は要素の型を角括弧でかこむ。
</p>

<p><code>is :: [Integer]<br/>
is = [23, 15, 4, 9]</code></p>

<p><code>bs :: [Bool]<br/>
bs = [True, False, False, True]</code></p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/list_efficiency.html"
	>「空間効率」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/inf_list.html"
	>「無限リスト」へ</a>
</p>
