1から学ぶHaskell: プログラマ向けのHaskell入門

<p>(工事中 20%)</p>

<h2>はじめに</h2>

<p>純粋関数型言語Haskellを学ぶのは海の向こうの国を知ることだ。</p>

<a href="/computer/haskell/web_lecture/for_programmer/images/the_functional_language.svg"
><img
width="350"
alt="[ザ・関数型言語のロゴ]"
src="/computer/haskell/web_lecture/for_programmer/images/the_functional_language.svg"/></a>

<p>
第一級関数、参照透過性、遅延性、静的型付けなどが特徴だ。
デザインの美しさを犠牲にすることなく優れた実用性を実現している。
</p>

<h2>対象</h2>

<p>
プログラムを組んだことがあり
「関数」「変数」「引数」「返り値」の意味がわかる人が対象だ。
</p>

<h2>勉強会</h2>

<p>
現在、勉強会実施中です。
DoorKeeperでチェック!!!
お問い合わせはSlackにて。
</p>

<ul>
<li><a href="https://shinjukuhs.doorkeeper.jp"
	>DoorKeeper: shinjuku.hs</a></li>
<li><a href="https://haskelldojo.slack.com">Slack: Haskell Dojo</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/meeting/index.html"
	>勉強会について</a></li>
</ul>

<h2>関数</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/whats_function.html"
	>関数とは何か</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/touch_ghci.html"
	>対話環境に触れる</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/make_function.html"
	>関数を作る</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/partial_application.html"
	>部分適用</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/function_literal.html"
	>関数リテラル</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/higher_order.html"
	>高階関数</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/operator.html"
	>演算子</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/bool.html"
	>Bool値</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/maybe.html"
	>Maybe値</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/pattern_match.html"
	>パターンマッチ</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/guard0.html"
	>ガード</a></li>
</ul>

<h2>型</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/whats_type.html"
	>型とは何か</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/function_type.html"
	>関数の型</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/type_declaration.html"
	>型宣言</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/type_annotation.html"
	>型注釈</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/type_driven.html"
	>型駆動開発</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/import.html"
	>モジュールの読み込み</a></li>
</ul>

<h2>多相関数</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/polymorphic.html"
	>多相関数とは</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/fromMaybe.html"
	>Maybe値からの値のとりだし</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/id.html"
	>そのままにする関数</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/const.html"
	>値を無視する関数</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/apply.html"
	>関数適用</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/dot.html"
	>関数合成</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/flip.html"
	>引数を入れ替える</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/on.html"
	>2つの引数に同じ関数を適用</a></li>
</ul>

<h2>ここまでのまとめ</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/function_summary.html"
	>関数</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/type_summary.html"
	>型</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/polymorphic_summary.html"
	>多相関数</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/dollarToDot.html"
	>追加: ($)の連続を(.)に置き換える</a></li>
</ul>

<h2>タプル</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/dist_tuple.html"
	>原点からの距離の例</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/convert.html"
	>型変換</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/curry.html"
	>カリー化</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/uncurry.html"
	>非カリー化</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/tuple_sugar.html"
	>タプルにおける構文糖</a></li>
</ul>

<h2>リストによる「くりかえし」</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/enum_accum.html"
	>列挙と蓄積</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/filter.html"
	>ろ過</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/map.html"
	>転写</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/list_efficiency.html"
	>「くりかえし」の空間効率</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/list_as_data.html"
	>データ構造としてのリスト</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/inf_list.html"
	>無限リスト</a></li>
</ul>

<h2>確認のための例題: モンテカルロ法</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/about_montecarlo.html"
	>モンテカルロ法の説明</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/integer_int.html"
	>2種類の整数型</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/randoms.html"
	>疑似乱数列の生成</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/montecarlo_coding.html"
	>モンテカルロ法のコーディング</a></li>
</ul>

<h2>追加の構文1</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/letin.html"
	>構文: let ... in ...式</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/where.html"
	>構文: where節</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/case.html"
	>構文: case式</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/ifthenelse.html"
	>構文: if式</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/fst_snd.html"
	>関数fst, snd</a> (new)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/type_synonym.html"
	>構文: 型シノニム</a> (new)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/layoutrule.html"
	>構文: レイアウトルール</a></li>
</ul>

<h2>再帰関数の基本</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/whats_rec_fun.html"
	>再帰関数とは</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/leibniz_formula.html"
	>ライプニッツの公式(円周率を求める)</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/binary_tree.html"
	>二分樹を下にたどる</a></li>
</ul>

<h2>リストを引数とする再帰関数</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/list_pattern_match.html"
	>リストのパターンマッチ</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/sum.html"
	>リストの要素の総和</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/product.html"
	>リストの要素の総積</a></li></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/length.html"
	>リストの長さ</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/fold_right.html"
	>たたみこみ(右)</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/fold_left.html"
	>たたみこみ(左)</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/polish.html"
	>ポーランド記法電卓</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/polish_fold_right.html"
	>ポーランド記法電卓とたたみこみ(右)</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/rev_polish.html"
	>逆ポーランド記法電卓</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/rev_polish_fold_left.html"
	>逆ポーランド記法電卓とたたみこみ(左)</a></li>
</ul>

<h2>リストを作成する再帰関数</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/enum_integer.html"
	>整数の列挙</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/collatz.html"
	>コラッツ数列</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/iterate.html"
	>関数iterateの定義</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/factorization.html"
	>素因数分解</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/unfoldr.html"
	>関数unfoldrの定義</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/taketo_unfoldr.html"
	>関数takeToの関数unfoldrによる定義</a></li>
</ul>

<h2>リストの再帰的定義</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/atpattern.html"
	>構文: @パターン</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/zipwith.html"
	>関数zipWithの紹介</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/fibonacci.html"
	>フィボナッチ数列</a></li>
</ul>

<h2>リストを扱う標準的な関数の定義</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/list_fun_defs.html"
	>リストを扱う関数の定義について</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/map_def.html"
	>関数map</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/filter_def.html"
	>関数filter, partition</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/take_def.html"
	>関数take, drop, splitAt</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/takewhile_def.html"
	>関数takeWhile, dropWhile, span</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/filter_unfoldr.html"
	>関数unfoldrと関数dropWhileを使った関数filterの定義</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/zip_def.html"
	>関数zip, zipWith, unzip</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/plusplus_def.html"
	>関数(++), concat, reverse</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/repeat_def.html"
	>関数repeat, replicate, cycle</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/concatMap.html"
	>関数concatMap</a> (edit)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/filter_concatmap.html"
	>関数concatMapによる関数filterの定義</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/list_comprehensions1.html"
	>構文: リスト内包表記1</a> (new)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/list_comprehensions2.html"
	>構文: リスト内包表記2</a></li>
</ul>

<h2>確認のための例題: 単純なパーサ</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/parser_prelude.html"
	>パーサ: はじめに</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/parser_basic.html"
	>基本的な関数</a> (edit)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/parser_list.html"
	>リストのパース</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/parser_numbers.html"
	>数の並びのパース</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/parser_calculator.html"
	>計算機</a></li>
</ul>

<h2>代数的データ型</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/adt_enum.html"
	>列挙型: トランプのスートと色</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/deriving_show.html"
	>deriving Show</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/men_and_items.html"
	>人間と商品</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/cartesian_polar.html"
	>直交座標と極座標での点の表現</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/point_is_point.html"
	>点は点だ</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/value_const_as_fun.html"
	>関数としての値構築子</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/value_const_operator.html"
	>値構築演算子</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/polymorphic_type.html"
	>多相型</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/tuple_def.html"
	>タプル</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/maybe_def.html"
	>Maybe型</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/either_def.html"
	>Either型</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/adt_recursive.html"
	>再帰的な型</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/poly_rec_type.html"
	>再帰的な多相型</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/adt_list.html"
	>リスト</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/record_syntax.html"
	>構文: レコード構文</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/adt_import.html"
	>構文: 代数的データ型のインポート</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/make_module.html"
	>構文: モジュールの作成</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/adt_export.html"
	>構文: 代数的データ型のエクスポート</a></li>
</ul>

<h2>確認のための例題: NML(Nano Markup Language)</h2>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/nml.html"
	>NML(1): 構文解析</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nml2.html"
	>NML(2): 他の型への変換</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nml3.html"
	>NML(3): 他の型からの変換</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nml4.html"
	>NML(4): 表示</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/deriving_read.html"
	>構文: deriving Read</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/interact.html"
	>関数: 簡易的なIO</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/main.html"
	>関数: main</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nml5.html"
	>NML(5): スタンドアロンなデコーダ、エンコーダ</a></li>
</ul>

<h2>番外編: ボットを作ってみよう</h2>

<p>
Slack等の管理を普段から行っていてHubotの設定に慣れている人向けの章だ。
そうでない人はこの章はとばそう。
</p>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/bot_prelude.html"
	>はじめに</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/bot_install.html"
	>Hubotのインストール</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/bot_oneliner.html"
	>Haskellのワンライナー</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nsc_prelude.html"
	>Nano Scheme: はじめに</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nsc_maybe.html"
	>Nano Scheme: Maybe型の演算</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nsc_map.html"
	>Nano Scheme: Map型</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nsc_integer.html"
	>Nano Scheme: 整数値の表示</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nsc_evalsym.html"
	>Nano Scheme: 変数の評価</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nsc_list.html"
	>Nano Scheme: リスト</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nsc_calc.html"
	>Nano Scheme: 四則演算</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nsc_defsym.html"
	>Nano Scheme: 変数定義</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nsc_lambda.html"
	>Nano Scheme: 関数定義と呼び出し</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nsc_if.html"
	>Nano Scheme: 構文if</a> (工事中 30%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/nsc_ltt.html"
	>Nano Scheme: 演算子&lt;の定義</a> (工事中 30%)</li>
</ul>

<p>参考: <a href="/computer/haskell/web_lecture/for_programmer/codes/others/conv.hs"
	>conv.hs</a></p>

<h2>型クラス</h2>

<p>
[方針] はじめは「型クラスとは」から始めようかと思ったが、
むしろ自分で型クラスを作っていくなかでそれらの説明を随時していくほうが
わかりやすい気がする。
まずは型クラスをひとつつくり、それに対するインスタンスとなる型を作る。
そのなかで構文や型クラスの意味を説明していこう。
すでにすこしだけ書いた
「<a href="/computer/haskell/web_lecture/for_programmer/whats_type_class.html"
	>型クラスとは</a> (工事中 30%)」や
「<a href="/computer/haskell/web_lecture/for_programmer/touch_type_class.html"
	>型クラスに触れる</a> (工事中 50%)」は
随時入れていく説明の参考にする。
「<a href="/computer/haskell/web_lecture/for_programmer/make_type_class.html"
	>型クラスを作る</a> (工事中 10%)」は分解した。
</p>

<p>
型クラスにおける型引数に型変数しか使えないあたり
(FlexibleInstancesやOverlappingInstances)についての考察が必要だ。
</p>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/boollike_spec.html"
	>条件分岐をわかりにくくする</a> (工事中 70%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/boollike_class.html"
	>型クラスBoolLike</a> (工事中 90%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/boollike_basic_types.html"
	>基本的な型を型クラスBoolLikeのインスタンスにする</a> (工事中 90%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/boollike_iff.html"
	>アドホック多相関数iff</a> (工事中 90%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/boollike_complex_types.html"
	>複合的な型を型クラスBoolLikeのインスタンスにする</a> (工事中 90%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/newtype.html"
	>構文: newtype</a> (工事中 0%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/typeclass_as_spec.html"
	>仕様としての型クラス: 実装と仕様をわける</a> (工事中 10%)</li>
<li>クラス関数のデフォルト定義
	<ul>
	<li>デフォルト定義が役に立つ例を作る</li>
	<li>あるクラス関数が定義されていたとして
		<ul>
		<li>それを使ったデフォルトの定義か</li>
		<li>別の定義か</li>
		</ul>を選べると便利な例を考える</li>
	</ul></li>
<li>「その型」をクラス関数の引数で2回使う例</li>
<li>型クラス: Eq</li>
<li>型クラスの定義にクラス制約をつける例</li>
<li>型クラス: Ord</li>
<li>型クラス: Enum</li>
<li>返り値の多相性を持つクラス関数についての話も</li>
<li>値そのものの多相性の話(型クラスBounded以外に必要なら)</li>
<li>型クラス: Bounded</li>
<li>構文: 複数の型クラス制約</li>
<li>アルゴリズム: 差分リスト</li>
<li>型クラス: Show</li>
<li>型クラス: Read</li>
<li>自作の型を既存の型クラスのインスタンスにする
	<ul>
	<li>スタバのドリンクのサイズの例</li>
	<li>derivingできる型クラスのすべてに対して手動でインスタンスにする</li>
	<li>そのあと、これ全部derivingでできます、って感じか</li>
	</ul></li>
<li>derivingの説明
	<ul>
	<li>derivingできる型クラスの一覧
		<ul>
		<li>Eq, Ord, Enum, Ix, Bounded, Show, Read</li>
		</ul></li>
	<li>Ix以外をざっくりと説明する</li>
	</ul></li>
<li>..</li>
</ul>

<h2>確認のための例題: オートマトンの例</h2>

<ul>
<li></li>
</ul>

<h2>モノイド</h2>

<ul>
<li>...</li>
<li>構文: newtype</li>
<li>...</li>
</ul>

<h2>ファンクター</h2>

<ul>
<li>型の種類(kind)</li>
<li>種類* -&gt; *に対する型クラス</li>
<li>..</li>
</ul>

<h2>アプリカティブファンクター</h2>

<ul>
<li>..</li>
</ul>

<h2>モナド</h2>

<ul>
<li>..</li>
<li>モナドであればアプリカティブファンクターでもある</li>
<li>..</li>
</ul>

<h2>IOモナド</h2>

<ul>
<li>..</li>
</ul>

<h2>作ってみよう</h2>

<p>
<a href="/computer/haskell/web_lecture"
	>「Haskellを学ぶ」トップへ</a>
<a href="/computer/haskell/web_lecture/for_programmer/paradigm_history.html"
	>「パラダイムの歴史」から読み始める</a>
</p>

<hr/>

<h2>下書き</h2>

<h3>番外編</h3>

<h4>関数foldrによる定義</h4>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/about_def_by_foldr.html"
	>関数foldrによる定義について</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/take_foldr.html"
	>関数foldrで関数takeを定義</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/drop_foldr.html"
	>関数foldrで関数dropを定義</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/splitat_foldr.html"
	>関数foldrで関数splitAtを定義</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/dropwhile_foldr.html"
	>関数foldrで関数dropWhileを定義</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/span_foldr.html"
	>関数foldrで関数spanを定義</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/zip_foldr.html"
	>関数foldrで関数zipを定義</a></li>
<li><a href="/computer/haskell/web_lecture/for_programmer/zipwith_foldr.html"
	>関数foldrで関数zipWithを定義</a></li>
</ul>

<h3>...</h3>

<ul>
<li>...</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/moneys.html"
	>支払いのしかたは何通り?</a> (new: 工事中 0%)</li>
<li>...</li>
</ul>

<h3>関数fix</h3>

<p><small><a href="/computer/haskell/web_lecture/for_programmer/fix_memo.html"
	>関数fixのメモ</a></small></p>

<ul>
<li><a href="/computer/haskell/web_lecture/for_programmer/fix.html"
	>関数fix</a> (工事中 50%)</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/mut_rec_fix.html"
	>相互再帰と関数fix</a> (工事中 0%)</li>
<li>let ... in ...の脱糖 (工事中 0%)</li>
</ul>

<ul>
<li>無名再帰</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/letin_recursive.html"
	>構文: let ... in ...と再帰(スタブ)</a></li>
<li>...</li>
</ul>

<h3>構文</h3>

<ul>
<li>文字列の複数行への分割</li>
</ul>

<h2>メモ</h2>

<ul>
<li>let ... in ...の説明をもうすこし考える
	<ul>
	<li>ごまかさずにしかも難しくしないのは可能か</li>
	</ul></li>
<li>GADTも面白い</li>
<li>TypeFamiliesについても中級編あたりで</li>
<li><a href="/computer/haskell/web_lecture/for_programmer/memo_type.html"
	>型についての再考</a></li>
</ul>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/todo.html"
	>todo</a>
<a href="/todo.html"
	>全体のtodo</a>
<a href="/computer/haskell/web_lecture/for_programmer/yjslide3_chapter2.txt"
	>chapter2.txt</a>
</p>
