たたみこみ(左)

<h2>結合則</h2>

<p><code>x `op` (y `op` z) == (x `op` y) `op` z</code></p>

<p>
すべてのx, y, zについて上記の式が成り立つとき演算子`op`は結合則を満たす。
足し算やかけ算は結合則を満たす。
</p>

<p><code>x + (y + z) == (x + y) + z<br/>
x * (y * z) == (x * y) * z</code></p>

<p>引き算やわり算は結合則を満たさない。</p>

<p><code>x - (y - z) /= (x - y) - z<br/>
x / (y / z) /= (x / y) / z</code></p>

<h2>左結合での計算</h2>

<p>
足し算は結合則を満たすのでリストの要素の総和を左結合で計算することができる。
</p>

<p>5 + (3 + (7 + 2)) == ((5 + 3) + 7) + 2</p>

<h2>蓄積変数</h2>

<p>
[5, 3, 7, 2]というリストを考える。
このリストは5 : [3, 7, 2]ということだ。
右結合での演算の場合[3, 7, 2]の総和を誰かに頼んでそれに5を足せば良い。
</p>

<p>
しかし左結合での演算ではそうはいかない。
[3, 7, 2]というリストだけをもらっても次の人は何もできない。
そこで5と[3, 7, 2]とをわけて次の人にわたす。
そしてその人はもらった5と3を足して8にして8と[7, 2]を次の人にわたす。
その人は8と7を足して15としそれと[2]を次の人にわたす。
さらに17と[]がわたされた人は17を結果として返す。
</p>

<p>
右結合での計算ではリストだけをわたしていけば良かったが、
左結合での計算ではリスト以外に5, 8, 15, 17と変化していく変数を
わたしていく必要がある。
このように変化していく変数を今までの変化の結果をためていくという意味で
蓄積変数と呼ぶ。
</p>

<h2>左結合の総和</h2>

<p><code>sumIter :: Integer -&gt; [Integer] -&gt; Integer<br/>
sumIter s [] = s<br/>
sumIter s (x : xs) = sumIter (s + x) xs</code></p>

<p>
上記の例では5と[3, 7, 2]をわけて蓄積変数の初期値を5とした。
このやりかただと空リストの場合が定義できない。
初期値を0として0と[5, 3, 7, 2]をわたすようなやりかたのほうが良いだろう。
</p>

<p><code>sumIter 0 [5, 3, 7, 2]<br/>
-&gt; sumIter (0 + 5) [3, 7, 2]<br/>
-&gt; sumIter ((0 + 5) + 3) [7, 2]<br/>
-&gt; sumIter (((0 + 5) + 3) + 7) [2]<br/>
-&gt; sumIter ((((0 + 5) + 3) + 7) + 2) []<br/>
-&gt; (((0 + 5) + 3) + 7) + 2<br/>
-&gt; 17</code></p>

<p>mySumはsumIterを使って定義できる。</p>

<p><code>mySum = sumIter 0</code></p>

<h2>反復的処理</h2>

<p>sumIterの定義を見ると以下のような置き換えとなっていることがわかる。</p>

<p><code>sumIter s (x : xs) -&gt; sumIter (s + x) xs</code></p>

<p>それぞれの引数について以下のように変化させて同じ関数を適用している。</p>

<p>蓄積含数: s -&gt; s + x<br/>
リスト: x : xs -&gt; xs</p>

<p>
蓄積変数にx足してリストから1要素けずるという操作を行うループと考えることができる。
よってこのような処理を反復的処理と呼ぶ。
もしもSchemeを学んだことがあるのならば末尾再帰という言葉を思い出そう。
</p>

<h2>再帰的処理</h2>

<p>右結合のほうはどうだろうか。</p>

<p><code>mySum (x : xs) = x + mySum xs</code></p>

<p>
これは単純に引数だけを変化させた形ではない。
内側の関数mysumを実行したあとにxを足す必要がある。
このように単純なループにはならない処理を再帰的処理と呼ぶ。
</p>

<h2>関数foldl</h2>

<p>
左からのたたみこみに関しても抽象化した関数が定義されている。
関数foldlだ。
</p>

<h3>使いかた</h3>

<p>適用する演算子(関数)と蓄積変数の初期値とリストをとりたたみこみの結果を返す。</p>

<p><code>% ghci<br/>
Prelude&gt; foldl (+) 0 [5, 3, 7, 2]<br/>
17</code></p>

<h3>定義</h3>

<p><code>myFoldl _ s [] = s<br/>
myFoldl op s (x : xs) = myFoldl op (s `op` x) xs</code></p>

<p>
蓄積変数sをs `op` xに更新してリストからはxを削る。
これを同じ関数の引数にすることでループしている。
リストが空になったらそのときの蓄積変数の値が全体の値となる。
</p>

<h3>型</h3>

<p>
蓄積変数の型は結果の値と同じ型でありさらにopの第1引数でもあり返り値でもある。
opの第2引数の型はリストの要素の型と同じである。
</p>

<p><code>myFoldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</code></p>

<h2>空間効率</h2>

<p>
今回定義したmySumは右結合のものも左結合のものも空間効率は悪い。
遅延評価なので足し算は必要とされるまで行われない。
つまり右結合であればx1 + (x2 + (x3 + ...))のような形に
左結合であれば(..((x1 + x2) + x3) + ...)のような形に一度完全に展開されて
それから足し算が評価されていく。
</p>

<h3>正格評価</h3>

<p>
右結合のほうはどうしようもない。
しかし左結合のほうはちょっとした変更で空間効率を改善することができる。
以下のような形で展開が行われるsumIter'を考える。
</p>

<p><code>sumIter' 0 [5, 3, 7, 2]<br/>
sumIter' 5 [3, 7, 2]<br/>
sumIter' 8 [7, 2]<br/>
sumIter' 15 [2]<br/>
sumIter' 17 []<br/>
17</code></p>

<p>
これなら空間効率はO(1)に保たれる。
このように引数の評価を先に行うことを「正格評価」と呼ぶ。
正格評価についてはここではくわしく説明しない。
このような形でたたみこみを行う関数foldl'が用意されている。
</p>

<h2>使いわけ</h2>

<p>
今まで挙げてきた例はすべてfoldl'で書いたほうが良い。
なぜなら足し算やかけ算などではいずれにしても値を求めるのに
リストすべての値が必要だからだ。
foldrが威力を発揮するのは途中で計算がやめられるような場合だ。
foldrならば無限リストを扱うこともできる。
</p>

<h2>自分用のメモ</h2>

<p><code>foldl' op v xs = foldr (\x k -&gt; \y -&gt; k $! y `op` x) id xs v</code></p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/product.html"
	>「たたみこみ(右)」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer"
	>「1から学ぶHaskell」トップへ</a>
</p>
