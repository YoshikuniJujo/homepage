たたみこみ(左)

<h2>結合則</h2>

<p><code>x `op` (y `op` z) == (x `op` y) `op` z</code></p>

<p>
すべてのx, y, zについてうえの式が成り立てば演算子`op`は結合則を満たす。
足し算やかけ算がそうだ。
</p>

<p><code>x + (y + z) == (x + y) + z<br/>
x * (y * z) == (x * y) * z</code></p>

<p>引き算やわり算は結合則を満たさない。(/=)は不等式を表す。</p>

<p><code>x - (y - z) /= (x - y) - z<br/>
x / (y / z) /= (x / y) / z</code></p>

<h2>左結合での計算</h2>

<p>
足し算は結合則を満たすのでリストの要素の総和は右結合でも左結合でも計算できる。
</p>

<p>5 + (3 + (7 + 2)) == ((5 + 3) + 7) + 2</p>

<h2>蓄積変数</h2>

<p>
[5, 3, 7, 2]というリストを考える。
このリストは5 : [3, 7, 2]ということだ。
右結合での演算の場合[3, 7, 2]の総和を誰かに頼んでそれに5を足す。
</p>

<p>
左結合での演算ではそうはいかない。
[3, 7, 2]というリストだけをもらっても次の人は何もできない。
そこで5と[3, 7, 2]とを次の人にわたす。
その人はもらった5と3を足して8にして8と[7, 2]を次の人にわたす。
その人は8と7を足した15と[2]を次の人にわたす。
17と[]がわたされた人は17を結果として返す。
</p>

<p>
右結合での計算ではリストだけをわたせば良いが、
左結合での計算ではリスト以外に5, 8, 15, 17と変化していく変数をわたす必要がある。
この変数を今までの変化の結果をためていくという意味で蓄積変数と呼ぶ。
</p>

<h2>左結合の総和</h2>

<p><code>sumIter :: Integer -&gt; [Integer] -&gt; Integer<br/>
sumIter s [] = s<br/>
sumIter s (x : xs) = sumIter (s + x) xs</code></p>

<p>
例では5と[3, 7, 2]をわけて蓄積変数の初期値を5とした。
これだと空リストに対して定義できない。
初期値を0として0と[5, 3, 7, 2]をわたすやりかたのほうが良い。
</p>

<p><code>sumIter 0 [5, 3, 7, 2]<br/>
-&gt; sumIter (0 + 5) [3, 7, 2]<br/>
-&gt; sumIter ((0 + 5) + 3) [7, 2]<br/>
-&gt; sumIter (((0 + 5) + 3) + 7) [2]<br/>
-&gt; sumIter ((((0 + 5) + 3) + 7) + 2) []<br/>
-&gt; (((0 + 5) + 3) + 7) + 2<br/>
-&gt; 17</code></p>

<p>mySumをsumIterを使って定義する。</p>

<p><code>mySum = sumIter 0</code></p>

<h2>反復的処理</h2>

<p>以下のような置き換えとなっている。</p>

<p><code>sumIter s (x : xs) -&gt; sumIter (s + x) xs</code></p>

<p>それぞれの引数を以下のように変化させて同じ関数に与えている。</p>

<p>蓄積含数: s -&gt; s + x<br/>
リスト: x : xs -&gt; xs</p>

<p>
蓄積変数にx足してリストから1要素けずるという操作を行うループと考えられる。
このような処理を反復的処理と呼ぶ。
Schemeを学んだことがあるのならば末尾再帰という言葉を思い出そう。
</p>

<h2>再帰的処理</h2>

<p>右結合のほうはどうだろうか。</p>

<p><code>mySum (x : xs) = x + mySum xs</code></p>

<p>
単純に引数だけを変化させた形ではない。
内側の関数mysumを実行したあとにxを足している。
単純なループにはならない。このような処理を再帰的処理と呼ぶ。
</p>

<h2>関数foldl</h2>

<p>
左からのたたみこみを抽象化した関数がある。
関数foldlは演算子(関数)と蓄積変数の初期値とリストをとりたたみこみの結果を返す。
</p>

<h3>使いかた</h3>

<p><code>% ghci<br/>
Prelude&gt; foldl (+) 0 [5, 3, 7, 2]<br/>
17</code></p>

<h3>定義</h3>

<p><code>myFoldl _ s [] = s<br/>
myFoldl op s (x : xs) = myFoldl op (s `op` x) xs</code></p>

<p>
蓄積変数sをs `op` xに更新してリストからはxを削る。
これを同じ関数に与える。ループとなる。
リストが空ならそのときの蓄積変数の値が全体の値となる。
</p>

<h3>型</h3>

<p>
蓄積変数の型は結果の値と同じ型だ。
その型はopの第1引数の型でもあり返り値の型でもある。
定義をよく見て、蓄積変数sがopの第1引数となっていること、
関数myFoldrの蓄積変数の場所にs `op` xが置かれていることを確認する。
opの第2引数の型はリストの要素の型と同じだ。
</p>

<p><code>myFoldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</code></p>

<h2>空間効率</h2>

<p>
今回定義したmySumは右結合のものも左結合のものも空間効率は悪い。
遅延評価なので足し算は必要とされるまで行われない。
つまり右結合であればx1 + (x2 + (x3 + ...))のような形に
左結合であれば(..((x1 + x2) + x3) + ...)のような形に一度完全に展開されて
それから足し算が評価される。
</p>

<h3>正格評価</h3>

<p>
右結合のほうはどうしようもない。
しかし左結合のほうはちょっとした変更で空間効率を改善できる。
以下のような形で展開が行われるsumIter'を考える。
</p>

<p><code>sumIter' 0 [5, 3, 7, 2]<br/>
sumIter' 5 [3, 7, 2]<br/>
sumIter' 8 [7, 2]<br/>
sumIter' 15 [2]<br/>
sumIter' 17 []<br/>
17</code></p>

<p>
これなら空間効率はO(1)だ。
引数の評価を先に行うことを「正格評価」と呼ぶ。
正格評価についてはここでは説明しない。
このような形でたたみこみを行う関数foldl'が用意されている。
</p>

<h2>使いわけ</h2>

<p>
今まで挙げてきた例はすべてfoldl'で書いたほうが良い。
足し算やかけ算ではいずれにしても値を求めるのにリストすべての値が必要だからだ。
foldrが威力を発揮するのは途中で計算がやめられるような場合だ。
foldrならば無限リストを扱うこともできる。
</p>

<h2>自分用のメモ</h2>

<p><code>foldl op v xs = foldr (\x k -&gt; \y -&gt; k $ y `op` x) id xs v</code></p>
<p><code>foldl' op v xs = foldr (\x k -&gt; \y -&gt; k $! y `op` x) id xs v</code></p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/product.html"
	>「たたみこみ(右)」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/polish.html"
	>「ポーランド記法電卓」へ</a>
</p>
