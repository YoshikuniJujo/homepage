二分樹を下にたどる

<p><a
href="/computer/haskell/web_lecture/for_programmer/15_binary_tree/binaryTree.hs"
>binaryTree.hs</a></p>

<h2>はじめに</h2>

<p>
制御の流れが1本道であるような再帰である「くりかえし」は
生の再帰を使わなくてもリストとそれを扱う関数で書ける。
生の再帰の力を証明するためには制御の流れが樹構造になるような
再帰関数を見る必要がある。
</p>

<h2>仕様</h2>

<p>
二分樹を下にたどっていくことで
ある要素から別の要素にたどりつけるかどうかを判定する関数を作成する。
樹の各要素は2つの枝を出すか、またはひとつも枝を出さないかのどちらかとする。
</p>

<img
alt="[樹のサンプルの画像]"
src="/computer/haskell/web_lecture/for_programmer/images/binaryTree.svg"/>

<p>
図に書いた例ではbからfには行けるがcからfには行けない。
樹を上にはたどれないのでcからaにもどれないからだ。
</p>

<h2>樹の表現</h2>

<p>
樹の要素は一文字で表現する。
樹は各要素から出る枝の集合とする。
同じ要素から出る枝はまとめて書く。
上の例のaからbとcに枝が出ていることを('a', ('b', 'c'))のように表現する。
例示した樹は以下のようになる。
</p>

<code>[('a', ('b', 'c')), ('b', ('d', 'e')), ('e', ('f', 'g'))]</code>

<p>
型は<code>[(Char, (Char, Char))]</code>となる。
これに別名をつける。
型の別名には以下の構文を使う。
</p>

<code>type [型の別名] = [型]</code>

<p>樹を表現する型の別名を型Treeとする。</p>

<p><code>type Tree = [(Char, (Char, Char))]</code></p>

<p>サンプルの樹も定義しておく。</p>

<code>sampleTree :: Tree<br/>
sampleTree = [('a', ('b', 'c')), ('b', ('d', 'e')), ('e', ('f', 'g'))]</code>

<h2>次を見つける</h2>

<p>
樹を下にたどっていくために、あるノードから出る枝の先にあるノードを求める。
例示した樹では引数'b'に対して'd'と'e'を返してほしい。
Tree型の値を辞書として考える。
辞書から鍵に対応する値をとりだせれば良い。
タプルのリストを辞書と考えたときに値を引き出す関数lookupがある。
</p>

<code>% ghci binaryTree.hs<br/>
*Main&gt; lookup 'b' sampleTree<br/>
Just ('d', 'e')<br/>
*Main&gt; lookup 'e' sampleTree<br/>
Just ('f', 'g')<br/>
*Main&gt; lookup 'd' sampleTree<br/>
Nothing</code>

<p>
ノードbからはdとeに枝がのび、ノードeからはfとgに枝がのびている。
またノードdの下には枝がないのでNothingとなる。
</p>

<h2>作成する関数の型</h2>

<p>
樹を指定しある要素からもうひとつの要素へと行けるかどうかを求める関数を作りたい。
</p>

<p><code>reachable [樹] [始点] [終点] =&gt; [真偽値]</code></p>

<p>型は以下のようになる。</p>

<code>reachable :: Tree -&gt; Char -&gt; Char -&gt; Bool</code>

<h2>基底部</h2>

<p>
基底部とは再帰しない部分だ。
再帰的に定義する必要のない部分である。
今回の例での基底部は以下の2つだ。
</p>

<ul>
<li>始点と終点が同じとき
	<ul><li>このとき経路は存在する</li></ul></li>
<li>上記以外で始点からの枝がないとき
	<ul><li>このとき経路は存在しない</li></ul></li>
</ul>

<p>
それぞれの基底部を書いてみよう。
始点と終点が同じときをガードを使って書く。
</p>

<p><code>reachable _ s e | s == e = True</code></p>

<p>
始点からの枝が存在しない場合をcase式のなかに書く。
</p>

<p><code>reachable t s e = case lookup s t of<br/>
	<span style="padding-left: 2em">Nothing -&gt; False</span></code></p>

<h2>再帰部</h2>

<p>
次に再帰部だ。
以下のように考える。
「点Xからの直接の枝が点Y, Zにのびているとき、
点Yまたは点Zから点Wまでの経路があれば、点Xから点Wまでの経路は存在する。」
case文のなかに以下を書き足せば良い。
</p>

<p><code><span style="padding-left: 2em">
	Just (l, r) -&gt; reachable t l e || reachable t r e</span></code></p>

<h2>試してみる</h2>

<p><code>% ghci binaryTree.hs<br/>
*Main&gt; reachable sampleTree 'b' 'g'<br/>
True<br/>
*Main&gt; reachable sampleTree 'c' 'f'<br/>
False</code></p>

<h2>まとめ</h2>

<p>
処理の流れが樹構造となる再帰関数の例を見た。
このような場合に「生の再帰」が威力を発揮する。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/case.html"
	>「case式」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/list_pattern_match.html"
	>「リストのパターンマッチ」へ</a>
</p>
