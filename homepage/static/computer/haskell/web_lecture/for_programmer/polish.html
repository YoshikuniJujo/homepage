ポーランド記法電卓

<p>(工事中 0%)</p>

<h2>ポーランド記法とは</h2>

<p>
演算子を被演算子の前に記述する数式の書きかただ。前置記法とも呼ぶ。
2項演算子のみならば優先順位や丸括弧なしで演算が一意に定まる。
</p>

<p>
<a href="https://ja.wikipedia.org/wiki/ポーランド記法"
	>ウィキペディア: ポーランド記法</a>
</p>

<h3>例</h3>

<p>中置記法と同じ式のポーランド記法の例である。</p>

<p><code>(1 + 5) * (2 + 3)</code></p>

<p><code>* + 1 5 + 2 3</code></p>

<h2>仕様</h2>

<p>
整数の四則演算のみを実装する。
数値や演算子を文字列のリストとしてわたす。
返り値は整数のリストのMaybe値とする。
計算が完全に終われば1要素のみのリストとなる。
演算子が足りず計算の途中ならば複数の整数がリストに残る。
数値が足りず演算が実行できないときや
演算子としても数値としても解釈できないときはNothing値を返す。
</p>

<h2>関数polish</h2>

<p><a href="/computer/haskell/web_lecture/for_programmer/codes/polish.hs"
	>polish.hs</a></p>

<h3>考えかた</h3>

<h4>例</h4>

<p>演算子や数値を前に追加していくことを考える。</p>

<ul>
<li>: []</li>
<li>3 : [3]</li>
<li>2 3: [2, 3]</li>
<li>+ 2 3: [5]</li>
<li>5 + 2 3: [5, 5]</li>
<li>1 5 + 2 3: [1, 5, 5]</li>
<li>+ 1 5 + 2 3: [6, 5]</li>
<li>* + 1 5 + 2 3: [30]</li>
</ul>

<h4>演算の追加</h4>

<p>先頭に演算子を追加すると数値リストの先頭2つに演算を適用し数値リストにもどす。</p>

<h4>数値の追加</h4>

<p>先頭に数値を追加すると数値リストの先頭に数値を追加することになる。</p>

<h3>演算子の表</h3>

<p>演算子の文字列表現と動作とを対応させる表を作る。</p>

<h4>型</h4>

<p>整数の2項演算なので動作はInteger型の値を2つとりInteger型を返す関数だ。</p>

<p><code>Integer -&gt; Integer -&gt; Integer</code></p>

<p>
文字列を鍵としこれを値とする辞書とする。
演算子の数は4つとすくないのでリストによる辞書で十分だ。
</p>

<p><code>operators :: [(String, Integer -&gt; Integer -&gt; Integer)]</code></p>

<h4>定義</h4>

<p>加減乗除のそれぞれについて文字列と動作とを対応させる。</p>

<p><code>operators = [("+", (+)), ("-", (-)), ("*", (*)), ("/", div)]</code></p>

<p>整数同士の演算なので除算には(/)ではなくdivを使用する。</p>

<h3>関数polishの再帰的な定義</h3>

<h4>型</h4>

<p><code>polish :: [String] -&gt; Maybe [Integer]</code></p>

<h4>基底部</h4>

<p>
基底として第1引数の文字列のリストが空である状態を考える。
このとき演算は成功し数値リストは空となる。
</p>

<p><code>polish [] = Just []</code></p>

<h4>再帰部</h4>

<p>まずは命令のリストをはじめの命令とそれ以外とにわける。</p>

<p><code>polish (s : ss) = ...</code></p>

<p>演算子リストから対応する演算の動作を探す。</p>

<p><code>lookup s operators</code></p>

<p>演算子リストに値が存在する場合と存在しない場合とに処理を分岐させる。</p>

<p><code>case lookup s operators of<br/>
	<span class="indent1">Just o -&gt; ...</span><br/>
	<span class="indent1">_ -&gt; ...</span>
	</code></p>

<p>
演算子リストに値が存在しなければ値sは数値と考える。
readMaybeによって数値として解釈できればJust値をそうでなければNothingとする。
文字列sを数値に変換し数値リストの先頭に追加する。
</p>

<p><code><span class="indent1">_ -&gt; case readMaybe s of</span><br/>
		<span class="indent2">Just n -&gt; maybe Nothing (Just . (n :)) $
							polish ss</span><br/>
		<span class="indent2">_ -&gt; Nothing</span></code></p>

<p>
演算子リストに値が存在したときは数値リストの先頭の2つに対して
演算子の動作を適用する。
</p>

<h3>動かしてみる</h3>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/fold_right.html"
	>「たたみこみ(右)」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/polish_fold_right.html"
	>「ポーランド記法電卓とたたみこみ(右)」へ</a>
</p>
