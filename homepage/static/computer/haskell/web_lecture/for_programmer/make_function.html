関数を作ってみる

<h2>題材</h2>

<p>
ある程度意味のある関数を作ったほうが面白いのでRSA暗号を題材とする。
Haskellにおける単純な関数について学ぶのが目的なのでRSA暗号の深い話はしない。
鍵の作りかたは説明しない。こちらで作成した鍵のペアを使う。
その鍵のペアを使う暗号化、復号化関数を作っていこう。
</p>

<h2>公開鍵暗号</h2>

<p>
王様が民衆の本音を知りたいとする。
自分の部下である大臣の評判を知りたい。
そこでメッセージを入れるための箱をたくさん作って各家庭に送る。
しかし、そのメッセージを大臣が読んでしまうとなると、民衆は本音が書けない。
箱や箱の鍵をとどけるのは大臣にしかできないとする。
さて、どうしたらいいものやら。
</p>

<p>
そこで王様は特別な箱を作らせる。
その箱はしめるときとあけるときで別々の鍵を使う。
「あけるための鍵」は王様だけが持っている。
「しめるための鍵」と箱をセットにして民衆にとどければ良い。
</p>

<p>
箱を受け取った民衆はメッセージを入れた箱を「しめるための鍵」を使ってしめる。
大臣はそれを王様に運ぶ。
途中でそれをあけようとしても、大臣の手に入る鍵は「しめるための鍵」だけである。
それらの箱をあけられるのは「あけるための鍵」を持っている王様だけだ。
</p>

<p>
これが公開鍵暗号の考えかたである。
暗号化のための鍵を公開し、メッセージを暗号化して送ってもらう。
送られてきたメッセージは自分だけが知っている復号化のための鍵で復号する。
つまり、不特定多数の人を相手に、秘密のメッセージを送ってもらうことができる。
</p>

<h2>RSA暗号とは</h2>

<p>
適切な3つの値e, d, nを選んでやることで、
非常に単純な計算で公開鍵暗号を実装することができる。
HTTPSにおける鍵の交換のために現在でも使われている方法である。
</p>

<h2>RSA暗号の計算式</h2>

<h3>Haskellの記法に慣れる</h3>

<p>
RSA暗号の暗号化と復号化に必要な計算は、平文をmとし暗号文をcとすると、
以下のようになる。
暗号化はmをe乗したものをnで割った余りを求める。これがcとなる。
復号化はcをd乗したものをnで割った余りであり、これはmにもどる。
よって必要な演算はべき乗と剰余の計算である。
この2つについてHaskellでの表記を見てみよう。
</p>

<pre><code>% ghci
Prelude&gt; 2 ^ 10
1024
Prelude&gt; 13 `mod` 5
3</code></pre>

<p>
2の10乗は'^'を使って2 ^ 10のように表す。
13を5で割った余りは13 `mod` 5のように表す。
modをバッククォートで囲んでいることに注意する。
バッククォートで囲む理由については後で説明する。
</p>

<h3>暗号化、復号をHaskellの記法で表現</h3>

<p>
RSA暗号における暗号化と復号とをHaskellの記法で表現すると以下のようになる。
</p>

<pre><code>c = m ^ e `mod` n
m = c ^ d `mod` n</code></pre>

<p>
e, d, nは適切に選んでやる必要がある。
ここでは、e = 13, d = 95497, n = 138689とする。
</p>

<h2>暗号化、復号を対話環境で試してみる</h2>

<p>
「let = 式」のようにすると対話環境内で変数を定義することができる。
</p>

<pre><code>Prelude&gt; let e = 13
Prelude&gt; let d = 95497
Prelude&gt; let n = 138689
Prelude&gt; 12345 ^ e `mod` n
47046
Prelude&gt; 47046 ^ d `mod` n
12345
Prelude&gt; 4492 ^ e `mod` n
47255
Prelude&gt; 47255 ^ d `mod` n
4492</code></pre>

<p>
暗号化された値がきちんと復号されているのがわかる。
この例では鍵として(13, 138689)を公開しておき、
95497を秘密にしておけば良い。
</p>

<h2>暗号化関数、複号関数を作成する</h2>

<p>
まずは、対話環境で直接実行してみたが、今度は関数を作成して、それを使ってみよう。
nとeの値と平文を引数として与えると暗号文を返す関数と、
nとdの値と暗号文を引数として与えると平文を返す関数を作成してみる。
以下のような内容のファイルを作成しよう。
名前はrsa.hsとしておこう。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/01_make_function/rsa.hs"
	>rsa.hs</a></p>

<pre><code>encrypt n e m = m ^ e `mod` n
decrypt n d c = c ^ d `mod` n</code></pre>

<p>
encrypt n e mやdecrypt n d cのように関数名の後に仮引数をスペースで区切って
並べていることに注目。
C言語系の言語のように引数全体を丸括弧で囲んだり、カンマで区切ったりしない。
また関数の中身の部分も波括弧で囲ったりする必要はなく、単に'='でつなげれば良い。
</p>

<p>
試してみる。
もし、ghciをすでに終了していたならば以下のようにする。
</p>

<pre><code>% ghci rsa.hs</code></pre>

<p>
ghciをまだ立ち上げたままならば以下のようにして読み込むこともできる。
</p>

<pre><code>Prelude&gt; :load rsa.hs</code></pre>

<p>
いずれにしても以下のように入力してみよう。
</p>

<pre><code>*Main&gt; encrypt 138689 13 12345
47046
*Main&gt; decrypt 138689 95497 47046
12345</code></pre>

<p>ちゃんと復号できた。</p>

<h2>まとめ</h2>

<p>
関数の定義のしかたと使いかたを見た。
それぞれ以下のようになる。
</p>

<ul>
<li>定義: [関数名] [仮引数1] [仮引数2] ... = [表現]</li>
<li>使用: [関数名] [実引数1] [実引数2] ...</li>
</ul>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/touch_ghci.html"
	>「対話環境に触れる」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/partial_application.html"
	>「部分適用」へ</a>
</p>
