仕様としての型クラス: 実装と仕様をわける

<p>(工事中 10%)</p>

<h2>修正が必要</h2>

<p>
キューの例はやめようかな。
いろいろと複雑な話が出てきてしまいそうだ。
もっと、おもちゃっぽいもののほうがいいかもしれない。
</p>

<ul>
<li>いくつかの機能を持つ型を使って何らかの演算を実行する</li>
<li>それらの機能は型によって動作が異なる</li>
<li>伝統的な「図形」の例はどうだろうか
	<ul>
	<li>それだと同じ型にまとめたくなる</li>
	</ul></li>
<li>やはり「同じこと」をやる複数の型のほうがよさそうだ
	<ul>
	<li>キューみたいな感じで、かな</li>
	</ul></li>
<li>リストとMapの2つで辞書を実装する、とかはどうだろうか
	<ul>
	<li>本質的にはいいが、関数名が同じなのでまぎらわしいな</li>
	</ul></li>
<li>暗号化の例はどうだろうか
	<ul>
	<li>たとえばシーザー暗号からもっと複雑な暗号まで</li>
	<li>でもこれだとTypeFamilies(or FunDeps)拡張が使いたくなるな</li>
	<li>暗号化ではなくCodecの例ならばどうだろうか</li>
	<li>データを保存して、そこから引き出していく感じ</li>
	</ul></li>
</ul>

<p><code>class IntStorage s where<br/>
	<span class="indent1">empty :: s</span><br/>
	<span class="indent1">store :: Int -&gt; s -&gt; s</span><br/>
	<span class="indent1">derive :: s -&gt; (Int, s)</span></code></p>

<ul>
<li>倉庫の例は結果にも引数にも「その型」が出てこないので今いちだ</li>
<li>倉庫から別の型の倉庫に値をうつしかえる関数moveってのはどうだろうか</li>
<li>シンプルで良いかもしれない</li>
</ul>

<!--
<p>
むしろ、幅優先探索にキューがあるといいよね、
それじゃキューを用意するけど...のような感じの流れがいいね。
</p>
-->

<h2>はじめに</h2>

<p>
型クラスは型の「性質」だ。
性質は特定のクラス関数を持つということで表現される。
クラス関数はその型を扱うためのAPIとも見ることができる。
型クラスは「仕様」と考えられる。
</p>

<h2>倉庫</h2>

<p><a href="/computer/haskell/web_lecture/for_programmer/codes/intStorage.hs"
	>intStorage.hs</a></p>

<p>
整数を格納する倉庫を考えよう。
整数を格納する、整数を取り出すの2つの仕事ができる。
どういう順で取り出すかは倉庫の種類によってまちまちだ。
また、同じ整数が2回格納されたときにそれを2つとして扱うか、
1つとして扱うかも倉庫の種類による。
</p>

<h2>型クラスIntStorage</h2>

<p>
型クラスIntStorageを以下のように定義する。
</p>

<p><code>class IntStorage s where<br/>
	<span class="indent1">empty :: s</span><br/>
	<span class="indent1">store :: Int -&gt; s -&gt; s</span><br/>
	<span class="indent1">derive :: s -&gt; Maybe (Int, s)</span></code></p>

<p>
空の倉庫として値emptyが定義される。
整数をたくわえる関数storeと
整数をとりだす関数deriveとが定義されればそれを整数の倉庫と考えることができる。
</p>

<p>
これらのクラス関数は「倉庫」として使える型の持つべきインターフェース、
「仕様」と考えることができる。
</p>

<h2>仕様のうえで</h2>

<p>
倉庫の実装を考えるまえに型クラスIntStorageによってあたえられた
仕様のうえでコードを書いてみよう。
</p>

<h3>値をたくわえる</h3>

<p>
適当に値をたくわえた倉庫をつくる。
</p>

<p><code>stored :: IntStorage s =&gt; s<br/>
stored = let<br/>
	<span class="indent1">s1 = store 8 empty</span><br/>
	<span class="indent1">s2 = store 5 s1</span><br/>
	<span class="indent1">s3 = store 2 s2</span><br/>
	<span class="indent1">s4 = store 10 s3</span><br/>
	<span class="indent1">s5 = store 3 s4 in</span><br/>
	<span class="indent1">s5</span></code></p>

<p>
空の倉庫に8, 5, 2, 10, 3と5個の整数をたくわえた。
順にたくわえていっている感じを出すためにあえてletを使った
変数への束縛を行った。
</p>

<h3>値をとりだす</h3>

<p>
倉庫から値を3つとりだしてみる。
これもわかりやすさのためにあえてどろくさい書きかたとする。
</p>

<p><code>derive3 :: IntStorage s =&gt; s -&gt; Maybe [Int]<br/>
derive3 s = case derive s of<br/>
	<span class="indent1">Just (l, s1) -&gt; case derive s1 of</span><br/>
	<span class="indent2">Just (m, s2) -&gt; case derive s2 of</span><br/>
	<span class="indent3">Just (n, s3) -&gt; Just [l, m, n]</span><br/>
	<span class="indent3">_ -&gt; Nothing</span><br/>
	<span class="indent2">_ -&gt; Nothing</span><br/>
	<span class="indent1">_ -&gt; Nothing</span></code></p>

<p>
関数deriveは値をとりだせればJust値をかえす。
Just値ならばさらに次の値をとりだす。
同じことをもう1回行い最後にとりだした値l, m, nをリストにして返す。
</p>

<h2>実際の倉庫</h2>

<h3>単純なリスト</h3>

<h3>ソートされた集合</h3>

<h3>リストによるキュー</h3>

<h3>奇数をさきに</h3>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/newtype.html"
	>「構文: newtype」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer"
	>「1から学ぶHaskell」トップへ</a>
</p>
