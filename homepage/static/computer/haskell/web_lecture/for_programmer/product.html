リストの要素の総積

<h2>はじめに</h2>

<p>
今度はリストに含まれる値すべてをかけ算する関数を作成する。
総和を求めるのと考えかたは同じだ。
重要なところなので、
同じことをもう一度やってみよう。
</p>

<h2>関数product</h2>

<p>
リストの要素すべてをかけ算する関数は用意されている。
</p>

<p><code>% ghci<br/>
Prelude&gt; product [3, 18, 9]<br/>
486</code></p>

<h2>関数myProduct</h2>

<p>
Integer型の値のリストに対してproductと同じ動作をする関数を作る。
</p>

<h3>型</h3>

<p>
Integer型の値のリストを引数として取りInteger型の値を返す。
</p>

<p><code>myProduct :: [Integer] -&gt; Integer</code></p>

<h3>再帰部</h3>

<p>
リストに値を追加したら結果の値はどう変化するか。
myProduct xsとmyProduct (x : xs)の関係はどうなるか。
後者は前者のx倍となるだろう。
</p>

<p><code>myProduct (x : xs) = x * myProduct xs</code></p>

<h3>基底部</h3>

<p>
空リストを基底とする。
myProduct [3, 14, 9]はmyProduct [14, 9]の3倍であり、
myProduct [14, 9]はmyProduct [9]の14倍である。
同様にmyProduct [9]がmyProduct []の9倍となれば良い。
つまりmyProduct []の値は1j。
</p>

<p><code>myProduct [] = 1</code></p>

<h3>出来上がり</h3>

<p><a href="/computer/haskell/web_lecture/for_programmer/18_product/product.hs"
	>product.hs</a></p>

<p><code>myProduct :: [Integer] -&gt; Integer<br/>
myProduct [] = 1<br/>
myProduct (x : xs) = x * myProduct xs</code></p>

<h2>関数mySumとの比較</h2>

<p>関数mySumの定義を示す。</p>

<p><code>mySum :: [Integer] -&gt; Integer<br/>
mySum [] = 0<br/>
mySum (x : xs) = x + mySum xs</code></p>

<p>
mySumとmyProductを比較する。
空リストのときの値がmySumでは0であるのに対してmyProductでは1だ。
再帰部では先頭の要素と再帰的な関数適用とをつなぐ演算子が、
mySumでは(+)でありmyProductでは(*)だ。
それ以外の全体としての枠組みは同じだ。
Haskellではメタ的な関数によってこのような枠組みを抽象化できる。
後のほうでまた触れる。
</p>

<h2>まとめ</h2>

<p>
リストを引数に取る再帰関数の作りかたの基本は以下のようになる。
</p>

<ul>
<li>空リストの場合の値を定義</li>
<li>先頭の要素と「残りの要素のリストに関数を適用したもの」を作って値を定義</li>
</ul>

<h2>課題</h2>

<ol>
<li>リストの要素数を返す関数myLengthを定義せよ
	<ul>
	<li>空リストの要素数は何か</li>
	<li>要素をひとつ追加すると要素数はどうなるか</li>
	</ul></li>
<li>関数myLengthに型宣言を追加せよ
	<ul>
	<li>型変数を使う</li>
	</ul></li>
</ol>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/sum.html"
	>「リストの要素の総和」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/fold_right.html"
	>「たたみこみ(右)」へ</a>
</p>
