リストの要素の総積

<h2>はじめに</h2>

<p>
リストに含まれる値すべてをかけ算する関数を作成する。
総和を求めるのと考えかたは同じだ。
</p>

<h2>関数product</h2>

<p><code>% ghci<br/>
Prelude&gt; product [3, 18, 9]<br/>
486</code></p>

<h2>関数myProduct</h2>

<p>関数myProductはInteger型の値のリストの要素すべての積を計算する。</p>

<h3>型</h3>

<p>Integer型の値のリストを引数としInteger型の値を返す。</p>

<p><code>myProduct :: [Integer] -&gt; Integer</code></p>

<h3>再帰部</h3>

<p>
リストに値を追加したら結果の値はどう変化するか。
結果の値はもとの値に追加した値をかけた値となるはずだ。
myProduct (x : xs)はmyProduct xsのx倍となる。
</p>

<p><code>myProduct (x : xs) = x * myProduct xs</code></p>

<h3>基底部</h3>

<p>
空リストを基底とする。
myProduct [3, 14, 9]はmyProduct [14, 9]の3倍であり、
myProduct [14, 9]はmyProduct [9]の14倍である。
同様にmyProduct [9]がmyProduct []の9倍となれば良い。
myProduct []の値を1とする。
</p>

<p><code>myProduct [] = 1</code></p>

<h3>出来上がり</h3>

<p><a href="/computer/haskell/web_lecture/for_programmer/18_product/product.hs"
	>product.hs</a></p>

<p><code>myProduct :: [Integer] -&gt; Integer<br/>
myProduct [] = 1<br/>
myProduct (x : xs) = x * myProduct xs</code></p>

<h2>関数mySumとの比較</h2>

<p><code>mySum :: [Integer] -&gt; Integer<br/>
mySum [] = 0<br/>
mySum (x : xs) = x + mySum xs</code></p>

<p>
空リストのときの値がmySumでは0でありmyProductでは1だ。
先頭の要素と再帰的な部分とをつなぐ演算子が
mySumでは(+)でありmyProductでは(*)だ。
全体としての枠組みは同じだ。
</p>

<h2>まとめ</h2>

<p>リストを引数に取る再帰関数の作りかたの基本を学んだ。</p>

<ul>
<li>空リストに対する値を定義</li>
<li>先頭の要素と「残りの要素のリストに関数を適用したもの」を使って値を定義</li>
</ul>

<h2>課題</h2>

<ol>
<li>リストの要素数を返す関数myLengthを定義せよ
	<ul>
	<li>空リストの要素数は何か</li>
	<li>要素をひとつ追加すると要素数はどうなるか</li>
	</ul></li>
<li>関数myLengthに型宣言を追加せよ
	<ul>
	<li>型変数を使う</li>
	</ul></li>
</ol>

<h2>自分用のメモ</h2>

<p>
関数lengthは課題にしないほうがいいかもしれない。
foldrの型を決めるときの例としてこれ以上の例がないので。
何か別の課題を考える必要がある。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/sum.html"
	>「リストの要素の総和」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/fold_right.html"
	>「たたみこみ(右)」へ</a>
</p>
