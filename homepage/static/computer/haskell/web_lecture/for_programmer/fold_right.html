たたみこみ(右)

<p>(工事中 20%)</p>

<h2>はじめに</h2>

<p>
リストの総和、総積、長さを求める関数を作成した。
これら3つの関数は同じ枠組みを共有している。
二引数関数を使ってリストをひとつの値に変換するという枠組みだ。
このような枠組みを「たたみこみ」と呼ぶ。
共通の枠組みは関数によって抽出することができる。
「たたみこみ」には二種類あるがここでは「右からのたたみこみ」を見てみよう。
</p>

<h2>それぞれの関数</h2>

<p>
総和、総積<!--、長さ-->を求める関数の定義をもう一度見てみよう。
</p>

<p><code>mySum [] = 0<br/>
mySum (x : xs) = x + mySum xs</code></p>

<p><code>myProduct [] = 1<br/>
myProduct (x : xs) = x * myProduct xs</code></p>

<!--
<p><code>myLength [] = 0<br/>
myLength (_ : xs) = 1 + myLength xs</code></p>
-->

<p>
これらの関数はほとんど同じ形であることがわかる。
mySumとmyProductの違いは0が1になっていること、
+が*になっていることだけだ。
</p>

<h2>右たたみこみ</h2>

<p>mySum [3, 7, 8, 4]を展開してみよう。</p>

<p><code>mySum [3, 7, 8, 4]<br/>
-&gt; mySum (3 : [7, 8, 4])<br/>
-&gt; 3 + mySum [7, 8, 4]<br/>
-&gt; 3 + mySum (7 : [8, 4])<br/>
-&gt; 3 + (7 + mySum [8, 4])<br/>
-&gt; 3 + (7 + mySum (8 : [4]))<br/>
-&gt; 3 + (7 + (8 + mySum [4]))<br/>
-&gt; 3 + (7 + (8 + mySum (4 : [])))<br/>
-&gt; 3 + (7 + (8 + (4 + mySum [])))<br/>
-&gt; 3 + (7 + (8 + (4 + 0)))</code></p>

<p>同様にmyProduct [3, 7, 8, 4]は以下のように展開できる。</p>

<p><code>3 * (7 * (8 * (4 * 1)))</code></p>

<p>
このようにmySumやmyProductはリストの要素に右結合で演算子を次々と
適用していった形になる。
このような操作を「右たたみこみ」と呼ぶ。
</p>

<h2>置き換え</h2>

<p>リスト[3, 7, 8, 4]は本質的には以下のような構造である。</p>

<p><code>3 : (7 : (8 : (4 : [])))</code></p>

<p>
上で展開した形とを比較する。
mySumでは[]を0に、(:)を(+)に置き換えていることになる。
myProductでも同様に[]を1に、(:)を(*)に置き換えている。
</p>

<p>
つまり、[]と(:)をそれぞれ何に置き換えるかを変えることで、
様々な「右たたみこみ」関数を作ることができる。
</p>

<h2>右たたみこみを抽象化する</h2>

<p>
[]を何に置き換えるか、(:)を何に置き換えるかという2点をパラメータとすると、
右たたみこみそのものを抽象化した関数を作成することができる。
つまり、右たたみこみ関数を作成する関数が作れる。
このような関数はすでに関数foldrとして標準ライブラリで定義されている。
</p>

<h2>関数foldrの使いかた</h2>

<p>
まずは使いかたから見てみよう。
mySumをfoldrを使って表してみる。
foldrは第1引数に(:)を置き換える演算子を取り、第2引数に[]を置き換える値を取る。
mySumではそれぞれ(+)と0なので以下のように定義することができる。
</p>

<p>mySum = foldr (+) 0</p>

<p>
myProductの例も見てみよう。
同様にそれぞれ(*)と1に置き換えれば良い。
</p>

<p>myProduct = foldr (*) 1</p>

<h2>関数foldrの定義</h2>

<p>
foldrの定義を見ていく。
同様の関数myFoldrを作ってみよう。
mySumとmyProductの定義を参考にする。
</p>

<p><code>mySum [] = 0<br/>
mySum (x : xs) = x + mySum xs</code></p>

<p><code>myProduct [] = 1<br/>
myProduct (x : xs) = x * mySum xs</code></p>

<p>
mySumにおける0や(+)、myProductにおける1や(*)を、
myFoldrの第1引数と第2引数に置き換えれば良い。
</p>

<p><code>myFoldr _ v [] = v<br/>
myFoldr op v (x : xs) = x `op` myFoldr op v xs</code></p>

<p>
myFoldrの定義のvを0にopを(+)に、myFoldr op vをmySumに置き換えるとmySumの定義になる。
同様にvを1にopを(*)に、myFoldr op vをmyProductに置き換えるとmyProductの定義になる。
</p>

<h2>関数foldrの型</h2>

<p>(作成中)</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/product.html"
	>「リストの要素の総積」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/right_left.html"
	>「右結合と左結合」へ</a>
</p>
