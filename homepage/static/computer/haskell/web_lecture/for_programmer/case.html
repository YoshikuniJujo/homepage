case式

<h2>はじめに</h2>

<p>
case式を使うことでより柔軟な形でのパターンマッチが可能となる。
</p>

<h2>仮引数部でのパターンマッチ</h2>

<p>
仮引数の部分でのパターンマッチは関数定義という特殊な場面でのみ使える構文糖である。
case式はより広い範囲をカバーする。
仮引数部でのパターンマッチとcase式の関係は
「関数定義」と「関数リテラル」の関係と似ている。
</p>

<h2>safeRecip</h2>

<p>
仮引数部でのパターンマッチは略記法だ。
脱糖しcase式で表現するとどうなるだろうか。
safeRecipを例にして見てみよう。
</p>

<p><code>safeRecip 0 = Nothing<br/>
safeRecp x = Just $ 1 / x</code></p>

<p>関数リテラルとcase式によって書き直す。</p>

<p><code>safeRecip = \x -&gt; case x of<br/>
	<span style="padding-left: 2em">0 -&gt; Nothing<br/>
	<span style="padding-left: 2em">_ -&gt; Just $ 1 / x</span></code></p>

<p>
上の表現は下の表現を構文糖によって書き換えたと考えられる。
</p>

<h2>case式の構文</h2>

<p>
case式の構文は以下のようになる。
</p>

<p><code>case [式0] of<br/>
	<span style="padding-left: 2em">[パターン1] -&gt; [式1]</span><br/>
	<span style="padding-left: 2em">[パターン2] -&gt; [式2]</span><br/>
	<span style="padding-left: 2em">...</span></code></p>

<p>
式0のところには単純な変数でなく複雑な式も置ける。
仮引数部を使ったパターンマッチよりも自由な書きかたができる。
</p>

<h2>レイアウトルール再び</h2>

<p>
Haskellではレイアウトルールによって明示的な{}や;を省略できる。
兄弟要素の列挙はインデントをそろえることで表現する。
[パターン1], [パターン2], ...はインデントがそろっているので並列の要素だ。
並列の要素内で複数行に分けるときはインデントを深くする。
</p>

<h2>case式でないと書きにくい例</h2>

<p>
小文字に直したときに'y'か'n'かそれ以外かをチェックする関数を見てみよう。
</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/15_5_case/checkAnswer.hs"
	>checkAnswer.hs</a></p>

<p><code>checkAnswer :: Char -&gt; Maybe Bool<br/>
checkAnswer c = case toLower c of<br/>
	<span style="padding-left: 2em">'y' -&gt; Just True</span><br/>
	<span style="padding-left: 2em">'n' -&gt; Just False</span><br/>
	<span style="padding-left: 2em">_ -&gt; Nothing</span></code></p>

<p>
引数に対して関数を適用したうえでのパターンマッチは
仮引数部でのパターンマッチでは簡単には書けない。
</p>

<h2>case式にもガードを</h2>

<p>
ガードは真偽値へのパターンマッチに対する構文糖だ。
ガードは関数にだけでなくcase式にもつけられる。
差の逆数を求める例だ。
</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/15_5_case/diffRecip.hs"
	>diffRecip.hs</a></p>

<p><code>diffRecip :: Double -&gt; Double -&gt; Maybe Double<br/>
diffRecip x y = case x - y of<br/>
	<span style="padding-left: 2em">0 -&gt; Nothing</span><br/>
	<span style="padding-left: 2em">d</span>
	<span style="padding-left: 1em">| d &gt; 0 -&gt; Just $ recip d</span><br/>
	<span style="padding-left: 4em">| otherwise -&gt; Just $ recip (- d)</span>
	</code></p>

<p>'-&gt; [式]'の代わりに'| [真偽値] -&gt; [式]'を必要なだけ置く。</p>

<h2>まとめ</h2>

<p>
関数の仮引数部分でのパターンマッチは構文糖だ。
case式はより広い範囲に適用できる。
case式の構文は以下のようになる。
</p>

<p><code>case [式0] of<br/>
	<span style="padding-left: 2em">[パターン1] -&gt; [式1]</span><br/>
	<span style="padding-left: 2em">[パターン2] -&gt; [式2]</span><br/>
	<span style="padding-left: 2em">...</span>
	</code></p>

<p>
case式にもガードをつけられる。
'-&gt; [式]'の代わりに'| [真偽値] -&gt; [式]'を必要なだけ置く。
</p>

<h2>課題</h2>

<ol>
<li></li>
</ol>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/leibniz_formula.html"
	>「ライプニッツの公式」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/binary_tree.html"
	>「二分樹を下へたどる」へ</a>
</p>
