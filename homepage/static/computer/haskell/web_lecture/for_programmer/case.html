case式

<h2>はじめに</h2>

<p>
そろそろこのあたりでcase式について学ぶことにする。
case式を学ぶとより柔軟な形でパターンマッチを使うことが可能となる。
</p>

<h2>仮引数部でのパターンマッチ</h2>

<p>
関数定義の仮引数の部分でパターンマッチを行ってきた。
関数定義内で使うという特別な場合のための構文糖だ。
case式はより広い範囲をカバーする。
仮引数部でのパターンマッチとcase式の関係は
「関数定義」と「関数リテラル」の関係と似ている。
case式はパターンマッチの王道だ。
より自由にパターンマッチが行える。
</p>

<h2>safeRecipはcase式を使うと</h2>

<p>
仮引数部でのパターンマッチは略記法である。
積極的に使っていこう。
しかし、case式でどのように書き換えられるかを知っておくと理解が深まる。
safeRecipを例にして見てみよう。
</p>

<p><code>safeRecip 0 = Nothing<br/>
safeRecp x = Just $ 1 / x</code></p>

<p>関数リテラルとcase式によって書き直す。</p>

<p><code>safeRecip = \x -&gt; case x of<br/>
	<span style="padding-left: 2em">0 -&gt; Nothing<br/>
	<span style="padding-left: 2em">_ -&gt; Just $ 1 / x</span></code></p>

<p>
下の表現がまずあり、
上の表現はそれを構文糖によって書き換えたと考えたほうがわかりやすい。
</p>

<h2>case式の構文</h2>

<p>
case式の構文は以下のようになる。
</p>

<p><code>case [式0] of<br/>
	<span style="padding-left: 2em">[パターン1] -&gt; [式1]</span><br/>
	<span style="padding-left: 2em">[パターン2] -&gt; [式2]</span><br/>
	<span style="padding-left: 2em">...</span></code></p>

<p>
式0のところに単純な変数だけでなく、たとえば計算式等を置くことができるので、
関数定義の仮引数部を使ったパターンマッチよりも、自由な書きかたが可能となる。
</p>

<h2>レイアウトルール再び</h2>

<p>
Haskellではレイアウトルールによって明示的な{}や;を使わない表現が可能となる。
基本的には兄弟要素の列挙はインデントをそろえることで表現する。
上記の[パターン1], [パターン2], ...はインデントをそろえることで
並列の要素であることが示される。
それぞれのパターン内で複数行に分ける場合はインデントを深くする必要がある。
</p>

<h2>仮引数部でのパターンマッチが使えない例</h2>

<p>
case式でないと書きにくい例を挙げる。
ある文字が小文字に直したときに'y'か'n'かそれ以外かをチェックする関数だ。
</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/15_5_case/checkAnswer.hs"
	>checkAnswer.hs</a></p>

<p><code>checkAnswer :: Char -&gt; Maybe Bool<br/>
checkAnswer c = case toLower c of<br/>
	<span style="padding-left: 2em">'y' -&gt; Just True</span><br/>
	<span style="padding-left: 2em">'n' -&gt; Just False</span><br/>
	<span style="padding-left: 2em">_ -&gt; Nothing</span></code></p>

<p>
このように引数に対して何らかの関数を適用したうえでパターンマッチをするなど、
仮引数部でのパターンマッチでは直接書けないことがある。
</p>

<h2>case式にもガードを</h2>

<p>
ガードは真偽値へのパターンマッチに対する構文糖と考えられる。
ガードは関数につけられるだけではなくcase式につけることもできる。
差の逆数を求める例を見てみよう。
</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/15_5_case/diffRecip.hs"
	>diffRecip.hs</a></p>

<p><code>diffRecip :: Double -&gt; Double -&gt; Maybe Double<br/>
diffRecip x y = case x - y of<br/>
	<span style="padding-left: 2em">0 -&gt; Nothing</span><br/>
	<span style="padding-left: 2em">d</span><br/>
	<span style="padding-left: 4em">| d &gt; 0 -&gt; Just $ recip d</span><br/>
	<span style="padding-left: 4em">| otherwise -&gt; Just $ recip (- d)</span>
	</code></p>

<p>'-&gt; [式]'の代わりに複数の'| [真偽値] -&gt; [式]'を置いてやれば良い。</p>

<h2>まとめ</h2>

<p>
関数の仮引数部分でのパターンマッチは構文糖である。
より広い範囲に適用できるcase式というものがある。
case式の構文は以下のようになる。
</p>

<p><code>case [式0] of<br/>
	<span style="padding-left: 2em">[パターン1] -&gt; [式1]</span><br/>
	<span style="padding-left: 2em">[パターン2] -&gt; [式2]</span><br/>
	<span style="padding-left: 2em">...</span>
	</code></p>

<p>
case式にもガードをつけることができる。
'-&gt; [式]'の代わりに複数の'| [真偽値] -&gt; [式]'を置けば良い。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/leibniz_formula.html"
	>「ライプニッツの公式」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/binary_tree.html"
	>「二分樹を下へたどる」へ</a>
</p>
