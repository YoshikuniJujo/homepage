パターンマッチ

<h2>パターンマッチをここで学ぶ理由</h2>

<p>
何らかの条件分岐が使えないと関数の例を挙げていくうえで不便だ。
Haskellの条件分岐の基本となるのがパターンマッチだ。
if文の動作もパターンマッチによって実現可能である。
</p>

<h2>パターンマッチとは</h2>

<p>
パターンマッチはHaskellの中核を構成する要素である。
</p>

<img
width="350"
alt="[パターンマッチの図]"
src="/computer/haskell/web_lecture/for_programmer/images/pattern_match.svg"
/>

<p>
値がパターンに適合するかどうかで処理を分岐させ、
複合的なデータ型から値を取り出すのがパターンマッチの役割である。
</p>

<h2>仮引数はパターンだ</h2>

<p>xxcryptを見てみよう。</p>

<code>xxcrypt n ed mc = mc ^ ed `mod` n</code>

<p>
ここで'='の左側にあるn, ed, mcのような変数は仮引数である。
実はこれらの変数は「パターン」であり以下のような働きをする。
</p>

<ul>
<li>すべての値にマッチ</li>
<li>マッチした値で自身を束縛</li>
</ul>

<p>
関数定義の関数名と'='のあいだには複数のパターンが置かれる。
単純な「変数」はパターンとしては上のような働きをする。
</p>

<h2>もっとパターンらしい例を</h2>

<p>
すべての値にマッチするパターンではパターンマッチの働きがよくわからない。
よりパターンマッチらしい例を見ていこう。
前回学んだMaybe型の例である。
Just 8という値があるとする。
この値を使う人はこう思う。
「失敗する可能性のある関数が適用された。その関数は成功し値は8だった」と。
Just 8のままでは値8を使うことはできない。
値の部分を取り出したい。
以下のようにする。
</p>

<code>fun (Just x) = [xを使った演算]</code>

<p>
これでJust 8という値を分解して8の部分だけを取り出せた。
Just xというパターンは以下の働きをする。
</p>

<ul>
<li>Just値だけにマッチ(Nothingにはマッチしない)</li>
<li>Just値を分解し中身の値で変数xを束縛</li>
</ul>

<p>
Just xはNothingにマッチしない。
上の定義だとfun Nothingとした場合にエラーが発生する。
以下のようにNothingの場合の定義もしておいたほうが良い。
</p>

<code>fun (Just x) = [xを使った演算]<br/>
fun Nothing = [Nothingだった場合に返す値]</code>

<h2>ワイルドカード</h2>

<p>
上の例ではJust xにマッチしない値はNothingのみだ。
またパターンNothingでは束縛される変数もない。
よって、何にでもマッチし変数束縛を行わないワイルドカードを使うとスマートだ。
</p>

<code>fun (Just x) = ...<br/>
fun _ = ...</code>

<p>
ワイルドカードは単一の'_'(アンダースコア)である。
変数束縛のない変数パターンと考えることができる。
</p>

<h2>数も文字も文字列もパターンである</h2>

<p>
数を含めリテラルもパターンとなる。
働きは、Nothingのように自分自身にマッチし何も束縛しない。
以下の関数は、
0の場合にはNothingを返し、そうでなければ逆数を求めJust値として返す。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/03_5_pattern_match/safeRecip.hs"
	>safeRecip.hs</a></p>

<code>safeRecip 0 = Nothing<br/>
safeRecip x = Just (1 / x)</code>

<p>
safeRecipを適用すると引数と0とのマッチングが試される。
マッチすればNothingを返す。
マッチしなければ引数は0ではないということなので安全に1 / xができる。
答えはJust値として返される。
試してみよう。
</p>

<pre><code>% ghci safeRecip.hs
*Main&gt; safeRecip 8
Just 0.125
*Main&gt; safeRecip 0
Nothing</code></pre>

<p>
文字列リテラルの例も見てみよう。
以下は"Yoshikuni"だけには特別に丁寧に挨拶してくれる関数である。
各自、自分の名前に置き換えて楽しもう。
本当は違うけど、ここでは、(++)は文字列連結演算子と理解しておこう。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/03_5_pattern_match/helloTo.hs"
	>helloTo.hs</a></p>

<code>helloTo "Yoshikuni" = "Good morning, sir."<br/>
helloTo n = "Hello, " ++ n ++ "!"</code>

<p>試してみよう。</p>

<code>% ghci helloTo.hs<br/>
*Main&gt; helloTo "Yoshikuni"<br/>
"Good morning, sir."<br/>
*Main&gt; helloTo "Ichiro"<br/>
"Hello, Ichiro!"</code>

<p>
最後は文字の例だ。
引数の文字が数字だったらその数を返し、そうでなかったら-1を返す。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/03_5_pattern_match/digit.hs"
	>digit.hs</a></p>

<pre><code>digit '0' = 0
digit '1' = 1
digit '2' = 2
digit '3' = 3
digit '4' = 4
digit '5' = 5
digit '6' = 6
digit '7' = 7
digit '8' = 8
digit '9' = 9
digit _ = -1</code></pre>

<h2>まとめ</h2>

<ul>
<li>パターンは値がマッチするかしないかをチェックする</li>
<li>ワイルドカードは必ずマッチするパターンである</li>
<li>変数は必ずマッチするパターンである
	<ul>
	<li>さらにマッチした値で自身を束縛する</li>
	</ul></li>
<li>パターンマッチで構成的な値から中身の値を取り出せる</li>
<li>関数定義を複数並べることで順にマッチを試すことができる</li>
</ul>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/maybe.html"
	>「Maybe型」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/guard0.html"
	>「ガード」へ</a>
</p>
