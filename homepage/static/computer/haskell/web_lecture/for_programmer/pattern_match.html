パターンマッチ

<h2>パターンマッチをここで学ぶ理由</h2>

<p>
条件分岐が使えないと関数の例を挙げるのに不便だ。
Haskellの条件分岐の基本がパターンマッチだ。
if文もパターンマッチから導ける。
</p>

<h2>パターンマッチとは</h2>

<p>パターンマッチはHaskellの中核を構成する要素のひとつだ。</p>

<img
width="350"
alt="[パターンマッチの図]"
src="/computer/haskell/web_lecture/for_programmer/images/pattern_match.svg"
/>

<p>
値がパターンに適合するかどうかで処理を分岐させ構成的なデータから値を取り出す。
</p>

<h2>仮引数はパターンだ</h2>

<p><code>xxcrypt n ed mc = mc ^ ed `mod` n</code></p>

<p>
ここで'='の左側にあるn, ed, mcのような変数は仮引数だ。
これらの変数は「パターン」である。
</p>

<ul>
<li>すべての値にマッチ</li>
<li>マッチした値がその変数を束縛する</li>
</ul>

<h2>もっとパターンらしく</h2>

<p>
すべての値にマッチするのではパターンマッチの働きがよくわからない。
よりパターンマッチらしいMaybe型の例を見る。
Just 8という値がある。
この値を使う人はこう思う。
「失敗する可能性のある関数が適用された。結果は成功で値は8だった」と。
値8を使うためには値の取り出しが必要だ。
</p>

<p><code>fun (Just x) = [xを使った演算]</code></p>

<p>Just xというパターンの働きは以下のようになる。</p>

<ul>
<li>Just値だけにマッチ(Nothingにはマッチしない)</li>
<li>Just [値]からとりだした値で変数xを束縛</li>
</ul>

<p>
Just xはNothingにマッチしないのでうえの定義だとfun Nothingのときにエラーとなる。
Nothingの定義を追加する。
</p>

<code>fun (Just x) = [xを使った演算]<br/>
fun Nothing = [Nothingだった場合に返す値]</code>

<h2>ワイルドカード</h2>

<p>
例ではJust xにマッチしない値はNothingだけだ。
パターンNothingでは束縛される変数もない。
何にでもマッチし変数束縛を行わないワイルドカードを使うとスマートだ。
</p>

<code>fun (Just x) = ...<br/>
fun _ = ...</code>

<p>
ワイルドカードは'_'(アンダースコア)で表す。
変数束縛のない変数パターンと考えられる。
</p>

<h2>パターンとしての数や文字</h2>

<p>
数などのリテラルもパターンだ。
Nothingのように値自体にマッチし何も束縛しない。
0の場合にはNothingをそうでなければ逆数を求める関数を示す。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/03_5_pattern_match/safeRecip.hs"
	>safeRecip.hs</a></p>

<code>safeRecip 0 = Nothing<br/>
safeRecip x = Just (1 / x)</code>

<p>
safeRecipを適用すると引数と0とのマッチングが試される。
マッチすればNothingを返す。
マッチしなければ引数は0ではないということだ。安全に1 / xができる。
返り値はJust値となる。
</p>

<pre><code>% ghci safeRecip.hs
*Main&gt; safeRecip 8
Just 0.125
*Main&gt; safeRecip 0
Nothing</code></pre>

<p>
文字列リテラルもパターンだ。
"Yoshikuni"だけには丁寧に挨拶させたい。
自分の名前に置き換えて楽しもう。
(++)は文字列連結演算子と考えておこう。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/03_5_pattern_match/helloTo.hs"
	>helloTo.hs</a></p>

<p><code>helloTo "Yoshikuni" = "Good morning, sir."<br/>
helloTo n = "Hello, " ++ n ++ "!"</code></p>

<p><code>% ghci helloTo.hs<br/>
*Main&gt; helloTo "Yoshikuni"<br/>
"Good morning, sir."<br/>
*Main&gt; helloTo "Ichiro"<br/>
"Hello, Ichiro!"</code></p>

<p>
文字リテラルもパターンだ。
引数の文字が数字ならその数を、そうでなかったら-1を返す。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/03_5_pattern_match/digit.hs"
	>digit.hs</a></p>

<p><code>digit '0' = 0<br/>
digit '1' = 1<br/>
digit '2' = 2<br/>
digit '3' = 3<br/>
digit '4' = 4<br/>
digit '5' = 5<br/>
digit '6' = 6<br/>
digit '7' = 7<br/>
digit '8' = 8<br/>
digit '9' = 9<br/>
digit _ = -1</code></p>

<h2>まとめ</h2>

<ul>
<li>パターンは値のマッチを試す</li>
<li>ワイルドカードは必ずマッチする</li>
<li>変数は必ずマッチする
	<ul>
	<li>マッチした値がその変数を束縛する</li>
	</ul></li>
<li>パターンマッチで構成的な値からなかの値をとりだせる</li>
<li>関数定義を並べると順にマッチを試していく</li>
</ul>

<h2>課題</h2>

<ol>
<li>Just [名前]ならば"[名前] is my friend."を、Nothingなら"I'm alone."を返す関数friendを作成せよ</li>
<li>引数が0ならばNothingをそうでなければJust [引数]を返す関数notZeroを作成せよ</li>
</ol>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/maybe.html"
	>「Maybe型」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/guard0.html"
	>「ガード」へ</a>
</p>
