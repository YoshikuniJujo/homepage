パターンマッチ

<h2>パターンマッチをここで学ぶ理由</h2>

<p>
何らかの条件分岐が使えないと関数の例を挙げていくうえで不便だ。
Haskellの条件分岐の基本となるのがパターンマッチだ。
if文の動作もパターンマッチで書ける。
</p>

<h2>パターンマッチとは</h2>

<p>パターンマッチはHaskellの中核を構成する要素のひとつだ。</p>

<img
width="350"
alt="[パターンマッチの図]"
src="/computer/haskell/web_lecture/for_programmer/images/pattern_match.svg"
/>

<p>
値がパターンに適合するかどうかで処理を分岐させ、
構成的なデータ型から値を取り出すことができる。
</p>

<h2>仮引数はパターンだ</h2>

<p>xxcryptを見てみよう。</p>

<p><code>xxcrypt n ed mc = mc ^ ed `mod` n</code></p>

<p>
ここで'='の左側にあるn, ed, mcのような変数は仮引数である。
これらの変数は「パターン」であり以下のような働きをする。
</p>

<ul>
<li>すべての値にマッチ</li>
<li>マッチした値がその変数を束縛する</li>
</ul>

<p>
関数定義の関数名と'='のあいだには複数のパターンが置かれる。
</p>

<h2>もっとパターンらしい例を</h2>

<p>
すべての値にマッチするパターンではパターンマッチの働きがよくわからない。
よりパターンマッチらしい例を見よう。
Maybe型の例だ。
Just 8という値がある。
この値を使う人はこう思う。
「失敗する可能性のある関数が適用された。その関数は成功し値は8だった」と。
Just 8のままでは値8は使えない。
値の部分を取り出したい。
</p>

<code>fun (Just x) = [xを使った演算]</code>

<p>
これでJust 8という値を分解して8の部分だけを取り出せた。
Just xというパターンは以下のような働きをする。
</p>

<ul>
<li>Just値だけにマッチ(Nothingにはマッチしない)</li>
<li>Just [値]をJustと[値]に分解しその値で変数xを束縛</li>
</ul>

<p>
Just xはNothingにマッチしないので
上の定義だとfun Nothingとした場合にエラーが発生する。
以下のようにNothingの場合の定義するほうが良い。
</p>

<code>fun (Just x) = [xを使った演算]<br/>
fun Nothing = [Nothingだった場合に返す値]</code>

<h2>ワイルドカード</h2>

<p>
上の例ではJust xにマッチしない値はNothingのみだ。
パターンNothingでは束縛される変数もない。
何にでもマッチし変数束縛を行わないワイルドカードを使うとスマートだ。
</p>

<code>fun (Just x) = ...<br/>
fun _ = ...</code>

<p>
ワイルドカードは単一の'_'(アンダースコア)である。
変数束縛のない変数パターンとも考えられる。
</p>

<h2>数も文字も文字列もパターンである</h2>

<p>
数を含めリテラルもパターンとなる。
Nothingと同じで値自体にマッチし何も束縛しない。
0の場合にはNothingを、そうでなければ逆数を求めJust値として返す関数を示す。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/03_5_pattern_match/safeRecip.hs"
	>safeRecip.hs</a></p>

<code>safeRecip 0 = Nothing<br/>
safeRecip x = Just (1 / x)</code>

<p>
safeRecipを適用すると引数と0とのマッチングが試される。
マッチすればNothingを返す。
マッチしなければ引数は0ではないということなので安全に1 / xができる。
答えはJust値として返される。
</p>

<pre><code>% ghci safeRecip.hs
*Main&gt; safeRecip 8
Just 0.125
*Main&gt; safeRecip 0
Nothing</code></pre>

<p>
文字列リテラルの例も見てみよう。
以下は"Yoshikuni"だけには特別に丁寧に挨拶してくれる関数だ。
各自、自分の名前に置き換えて楽しもう。
ここでは(++)は文字列連結演算子と考えておこう。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/03_5_pattern_match/helloTo.hs"
	>helloTo.hs</a></p>

<code>helloTo "Yoshikuni" = "Good morning, sir."<br/>
helloTo n = "Hello, " ++ n ++ "!"</code>

<p>試してみる。</p>

<code>% ghci helloTo.hs<br/>
*Main&gt; helloTo "Yoshikuni"<br/>
"Good morning, sir."<br/>
*Main&gt; helloTo "Ichiro"<br/>
"Hello, Ichiro!"</code>

<p>
最後は文字の例だ。
引数の文字が数字だったらその数を返し、そうでなかったら-1を返す。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/03_5_pattern_match/digit.hs"
	>digit.hs</a></p>

<pre><code>digit '0' = 0
digit '1' = 1
digit '2' = 2
digit '3' = 3
digit '4' = 4
digit '5' = 5
digit '6' = 6
digit '7' = 7
digit '8' = 8
digit '9' = 9
digit _ = -1</code></pre>

<h2>まとめ</h2>

<ul>
<li>パターンは値がマッチするかしないかをチェックする</li>
<li>ワイルドカードは必ずマッチするパターンである</li>
<li>変数は必ずマッチするパターンである
	<ul>
	<li>さらにマッチした値で自身を束縛する</li>
	</ul></li>
<li>パターンマッチで構成的な値から中身の値を取り出せる</li>
<li>関数定義を複数並べることで順にマッチを試すことができる</li>
</ul>

<h2>課題</h2>

<ol>
<li>引数がJust [名前]ならば"[名前] is my friend."を返しNothingなら"I'm alone."を返す関数friendを作成せよ</li>
<li>引数が0ならばNothingをそうでないならばJust [引数]を返す関数notZeroを作成せよ</li>
</ol>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/maybe.html"
	>「Maybe型」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/guard0.html"
	>「ガード」へ</a>
</p>
