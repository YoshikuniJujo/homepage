関数zipWithの紹介

<h2>はじめに</h2>

<p>
「リストの再帰的定義」で使う関数zipWithの紹介をする。ここでは使いかたのみとする。
</p>

<h2>動作</h2>

<p>関数mapをリストふたつへと拡張したものだ。</p>

<p><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code></p>

<p><code>zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code></p>

<p>
2引数関数とふたつのリストをとり、リストから1つずつ値をとりだして関数に与え結果を
リストにまとめる。
</p>

<p><code>% ghci<br/>
Prelude&gt; zipWith (+) [3, 4, 5] [6, 7, 8, 9]<br/>
[9,11,13]<br/>
Prelude&gt; :m Data.Char<br/>
Prelude Data.Char&gt; zipWith filter [isDigit, isUpper, not . isUpper]
	["1st Floor, 2nd Floor, 3rd Floor", "Haskell Brooks Curry",
		"There are many Capes.", "I will be ignored."]<br/>
["123", "HBC", "here are many apes."]</code></p>

<p>
それぞれのリストから0番目、1番目、2番目、...と値をとりだして関数に与える。
短いほうのリストの要素がなくなったら終了だ。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/atpattern.html"
	>「構文: @パターン」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/fibonacci.html"
	>「フィボナッチ数列」へ</a>
</p>
