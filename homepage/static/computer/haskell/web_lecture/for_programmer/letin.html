構文: let ... in ...

<h2>ローカル変数</h2>

<p>
ローカル変数が使いたい。
可読性のためのときもありDRY(Don't repeat yourself)原則を守るためであるときもある。
二重化による実行効率の低下を避けるためにも必要だ。
</p>

<h2>使えるよ</h2>

<p>
今までの枠組みだけでローカル変数を作って使うことは可能だ。
</p>

<p><code>% ghci<br/>
Prelude&gt; (\x -&gt; x ^ x) 5<br/>
3125</code></p>

<p>
これはローカルな変数xに5を代入したうえでxのx乗を計算している。
</p>

<h2>つまり</h2>

<p>ローカル変数と仮引数とは同じものである。</p>

<p><code>(\var -&gt; [varを使った式]) val</code></p>

<p>ローカル変数varをvalで束縛して式を評価することができる。</p>

<h2>もっとローカル変数らしく</h2>

<p>
もうすこし甘さが必要だ。
僕を含め多くの人がそう思う。
let ... in ...という構文糖を使おう。
上の形を以下のように書くことができる。
</p>

<p><code>let var = val in [varを使った式]</code></p>

<p><code>Prelude&gt; (\x -&gt; x ^ x) 5<br/>
3125<br/>
Prelude&gt; let x = 5 in x ^ x<br/>
3125</code></p>

<h2>複数のローカル定義</h2>

<h3>無名関数を使う</h3>

<p><code>(\x y -&gt; x * y) 3 5</code></p>

<h3>let ... in ...構文を使う</h3>

<p>
ここではレイアウトルールを使った書きかたを見る。
レイアウトルールを使う場合はファイルに書き込んだほうが簡単だ。
</p>

<p><code>z = let<span style="padding-left: 0.5em">x = 3</span><br/>
	<span class="indent1">y = 5 in</span><br/>
	<span class="indent1">x * y</span></code></p>

<p>
x = 3とy = 5は兄弟要素なのでインデントをそろえる。
'in x * y'の部分はletの置かれた行のインデントより深くしさえすれば良い。
</p>

<h2>まとめ</h2>

<p>
ローカル変数をよりわかりやすく使えるように構文let ... in ...が用意されている。
意味論的には関数の作成と引数への適用の範囲を越えるものではない。
単なる構文糖と考えることができる。
</p>

<h2>より高度な話題: 再帰的定義への対応</h2>

<p>
let ... in ...では変数定義部分での再帰的定義ができる。
この機能の実現のため脱糖はより複雑になっている。
ここらへんの説明は再帰関数の説明の最後に関数fixを扱ったあとに行う。
</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/letin_recursive.html"
	>let ... in ...による変数定義における再帰(スタブ)</a></p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/montecarlo_coding.html"
	>「モンテカルロ法のコーディング」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/where.html"
	>「構文: where」へ</a>
</p>
