構文: let ... in ...式

<h2>ローカル変数</h2>

<p>
ローカル変数が使いたい。
可読性のためDRY(Don't repeat yourself)原則を守るため実行効率のためにだ。
</p>

<h2>使えるよ</h2>

<p>今までの枠組みでローカル変数を作って使うことは可能だ。</p>

<p><code>% ghci<br/>
Prelude&gt; (\x -&gt; x ^ x) 5<br/>
3125</code></p>

<p>ローカル変数xに5を代入してxのx乗を計算している。</p>

<h2>つまり</h2>

<p>ローカル変数と仮引数は同じだ。</p>

<p><code>(\var -&gt; [varを使った式]) val</code></p>

<p>ローカル変数varをvalで束縛して式を評価している。</p>

<h2>もっとローカル変数らしく</h2>

<p>もうすこし甘くしないとだ。let ... in ...という構文糖がある。</p>

<p><code>let var = val in [varを使った式]</code></p>

<p><code>Prelude&gt; (\x -&gt; x ^ x) 5<br/>
3125<br/>
Prelude&gt; let x = 5 in x ^ x<br/>
3125</code></p>

<h2>複数のローカル定義</h2>

<h3>無名関数で</h3>

<p><code>(\x y -&gt; x * y) 3 5</code></p>

<h3>let ... in ...構文で</h3>

<p>レイアウトルールを使って書く。</p>

<p><code>z = let<span style="padding-left: 0.5em">x = 3</span><br/>
	<span class="indent1">y = 5 in</span><br/>
	<span class="indent1">x * y</span></code></p>

<p>
x = 3とy = 5は兄弟要素なのでインデントをそろえる。
in x * yの部分はletの置かれた行よりインデントを深くすれば良い。
</p>

<h2>まとめ</h2>

<p>
ローカル変数をよりわかりやすく使えるように構文let ... in ...がある。
意味論的には関数の作成と引数への適用の範囲を越えるものではない。
単なる構文糖だ。
</p>

<h2>より高度な話題: 再帰的定義への対応</h2>

<p>
let ... in ...では変数定義部分での再帰的定義ができる。
この機能の実現のため脱糖はより複雑になる。
詳しい説明は関数fixを扱ったあとに行う予定だ。
</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/letin_recursive.html"
	>let ... in ...による変数定義における再帰(スタブ)</a></p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/montecarlo_coding.html"
	>「モンテカルロ法のコーディング」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/where.html"
	>「構文: where節」へ</a>
</p>
