無限リスト

<h2>はじめに</h2>

<p>
「遅延性」という言葉を考えた。
「遅延評価」と「遅延データ構造」をひっくるめて「遅延性」と呼ぶ。
「遅延データ構造」の代表として「遅延リスト」がある。
無限リストは遅延性を活用したデータ構造の典型だ。
遅延性のおかげで「まず無限の長さのリストを作成し...」というコーディングができる。
</p>

<h3>終了条件を分離</h3>

<p>
多くのアルゴリズムで終了条件は非本質的な部分だ。
「大きい方から100個の素数を求める」とき
従来の言語で普通にコーディングすると「100個で終了」というコードは
「素数を求める」というアルゴリズムとからみあい分離しがたい。
無限リストを使うと「すべての素数のリストを作成しそこから100個取る」ことができる。
本質的な部分(素数を求める)から非本質的な部分(小さい方から100個取る)を分離できる。
</p>

<h2>1番小さな因数</h2>

<p><a href="/computer/haskell/web_lecture/for_programmer/12_inf_list/factor.hs"
	>factor.hs</a></p>

<p>
自然数の最小の因数を求めよう。素朴な実装とする。
2から順に割っていき余りが0になるものを探す。
</p>

<p>2以上の「すべての」整数を含む無限リストを作成する。</p>

<p><code>[2 ..]</code></p>

<p>
数nを割った余りが0になるものだけを集めたリストを作成する。
</p>

<code>filter ((== 0) . (n `mod`)) [2 ..]</code>

<p>「最小の」因数なので1番先頭を取る。</p>

<p><code>head $ filter ((== 0) . (n `mod`)) [2 ..]</code></p>

<p>nが2未満のときの無限実行を避けるためにガードでふるいわける。</p>

<p><code>factor n<br/>
	<span style="padding-left:2em">| n &lt; 2 = 1</span><br/>
	<span style="padding-left:2em">| otherwise = head $ filter ((== 0) . (n `mod`)) [2 ..]</span></code></p>

<p><code>% ghci factor.hs<br/>
*Main&gt; factor 221<br/>
13<br/>
*Main&gt; factor 100233223200127<br/>
9997777</code></p>

<h2>平方数のリスト</h2>

<p>すべての平方数のリストは以下のように作れる。</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/12_inf_list/squares.hs"
	>squares.hs</a></p>

<p><code>squares :: [Integer]<br/>
squares = map (^ 2) [0 ..]</code></p>

<p><code>ghci squares.hs<br/>
*Main&gt; take 13 squares<br/>
[0,1,4,9,16,25,36,49,64,81,100,121,144]</code></p>

<p>
関数takeは指定した数だけリストから値を取り出す。
無限リストを表示するときにはtakeを使わないと無限実行となる。
</p>

<h2>課題</h2>

<ol>
<li>すべての正の立方数(整数の3乗となる数)のリストcubesを作成せよ</li>
<li>cubesの先頭20要素を表示せよ</li>
</ol>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/list_as_data.html"
	>「データ構造としてのリスト」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/about_montecarlo.html"
	>「モンテカルロ法の説明」へ</a>
</p>
