関数リテラル

<h2>リテラルとは</h2>

<p>
コードのなかに値を「直接」書き込む表現をリテラルと呼ぶ。
'c', "hello", 123等はリテラルである。
変数や関数適用はリテラルではない。
</p>

<pre><code>% ghci
Prelude&gt; 'c'
'c'
Prelude&gt; "hello"
"hello"
Prelude&gt; 123
123</code></pre>

<h2>関数リテラルとは</h2>

<p>
ここまで学んできた関数の定義では、関数は変数を使って呼び出す必要があった。
関数リテラルを使えば、関数に名前をつけずに
その場で作りその場で使うことができる。
</p>

<h3>変数とリテラル</h3>

<p>
x = 3と定義されているときxのある場所を3で置き換えられる。
では、fun x = x ^ xのように定義されているとき
funのある場所を何で置き換えられるだろうか。
funのある場所を置き換えられるような表現、
つまり、関数の実体ともいえるものが関数リテラルだ。
</p>

<h2>関数リテラルの例</h2>

<p>fun x = x ^ xの例を見ていこう。</p>

<p><code>% ghci<br/>
Prelude&gt; let fun x = x ^ x<br/>
Prelude&gt; fun 3<br/>
27</code></p>

<p>
funの部分を関数リテラルで置き換える。
関数リテラルは\[仮引数] -&gt; [表現]という形になる。
</p>

<p><code>Prelude&gt; (\x -&gt; x ^ x) 3<br/>
27</code></p>

<h2>関数定義は構文糖だった</h2>

<p>
実は今まで見てきた関数定義は2つのことを行う構文糖だ。
</p>

<code>fun x = x ^ x</code>

<p>以下のように書き直すことができる。</p>

<code>fun = \x -&gt; x ^ x</code>

<p>
関数定義は、関数リテラルによって関数を作成し、
その関数で変数を束縛するという2つのことを一度に行う。
</p>

<h2>xxcryptの例</h2>

<p>xxcryptの定義を再掲する。</p>

<code>xxcrypt n ed mc = mc ^ ed `mod` n</code>

<p>これを関数リテラルで書くと以下のようになる。</p>

<p><code>xxcrypt = \n -&gt; (\ed -&gt; (\mc -&gt;  mc ^ ed `mod` n))</code></p>

<img
width="330"
alt="[3引数関数の図]"
src="/computer/haskell/web_lecture/for_programmer/images/three_arg_fun.svg"
/>

<p>
数値を返す関数を返す関数を返す関数ということだ。
結合性を考慮すると括弧は省略できる。
</p>

<code>xxcrypt = \n -&gt; \ed -&gt; \mc -&gt;  mc ^ ed `mod` n</code>

<h2>複数引数の省略記法</h2>

<p>上記のように引数がつながる場合には以下のような略記法がある。</p>

<code>xxcrypt = \n ed mc -&gt; mc ^ ed `mod` n</code>

<h2>まとめ</h2>

<p>関数リテラルの記法を以下に示す。</p>

<code>\[仮引数1] [仮引数2] ... -&gt; [表現]</code>

<h2>課題</h2>

<ol>
<li>金額を引数に取り消費税込みの価格を返す関数taxを作成せよ
	<ul>
	<li>整数の除算には演算子`div`が使える</li>
	<li>10 `div` 3は3を返す</li>
	</ul></li>
<li>関数taxを関数リテラルで変数束縛する形に書き換えよ</li>
<li>時間、分、秒を引数として取り秒数に変換する関数secondを作成せよ</li>
<li>関数secondを関数リテラルで変数束縛する形に書き換えよ</li>
</ol>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/partial_application.html"
	>「部分適用」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/higher_order.html"
	>「高階関数」へ</a>
</p>
