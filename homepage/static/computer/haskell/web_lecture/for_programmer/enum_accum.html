リストによる「くりかえし」: 列挙と蓄積

<h2>0からnまで整数の和</h2>

<p>
0からnまでの整数の和を求める。
</p>

<h3>手続き的に</h3>

<p>
手続き的には以下のようになる。
</p>

<ol>
<li>変数i, sを用意</li>
<li>i, sを0に初期化</li>
<li>sにiを足したものをsに代入</li>
<li>iに1を足したものをiに代入</li>
<li>iがn以下なら3へ、そうでないなら6へ</li>
<li>sを返す</li>
</ol>

<h3>リストで</h3>

<p>リストを使うと以下のようになる。</p>

<ol>
<li>0からnまでの整数を列挙したリストを作成</li>
<li>リストの要素の総和を返す</li>
</ol>

<h3>比較</h3>

<p>手続き的なほうは</p>

<ul>
<li>本当に正しいのかどうかが自明でない</li>
<li>機械の気持ちになって手続きを追う必要がある</li>
<li>正しいのはiがn以下、それともn未満、あるいはn+1以下?</li>
</ul>

<p>リストを使う方法では</p>

<ul>
<li>手続きではなく構造を記述、そのため</li>
<li>アルゴリズムが正しいことは自明</li>
</ul>

<h2>実際にやってみる</h2>

<p>
「0からnまでの整数の列挙」の段階が「列挙」であり、
「要素の総和を求める」という段階が「蓄積」だ。
0からnまでの整数の列挙は以下のように書く。
</p>

<p><code>[0 .. n]</code></p>

<p>
リストの総和を求めるには関数sumを使う。
「0からnまでの整数の総和」は以下のように計算できる。
</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/09_enum_accum/sumN.hs"
	>sumN.hs</a></p>

<pre><code>sumN :: Integer -&gt; Integer
sumN n = sum [0 .. n]</code></pre>

<p>試してみる。</p>

<pre><code>ghci sumN.hs
*Main&gt; sumN 10
55</code></pre>

<h2>まとめ</h2>

<p>
リストの要素を数え上げていく段階を列挙と呼び、
それらの要素をひとつの値にまとめる段階を蓄積と呼ぶ。
単純な「くりかえし」はリストを使った列挙と蓄積で書ける。
リストを使った「くりかえし」で表現すると手続きではなく構造自体を表せる。
</p>

<h2>課題</h2>

<ol>
<li>1からnまでの積を求める関数productNを作成せよ
	<ul>
	<li>リストの全要素の積を求める関数productを使用する</li>
	</ul></li>
</ol>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/uncurry.html"
	>「非カリー化」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/filter.html"
	>「ろ過」へ</a>
</p>
