右結合と左結合

<p>(工事中 0%)</p>

<h2>結合則</h2>

<p><code>x `op` (y `op` z) == (x `op` y) `op` z</code></p>

<p>
すべてのx, y, zについて上記の式が成り立つとき演算子`op`は結合則を満たす。
足し算やかけ算は結合則を満たす。
</p>

<p><code>x + (y + z) == (x + y) + z<br/>
x * (y * z) == (x * y) * z</code></p>

<p>引き算やわり算は結合則を満たさない。</p>

<p><code>x - (y - z) /= (x - y) - z<br/>
x / (y / z) /= (x / y) / z</code></p>

<h2>左結合での計算</h2>

<p>
足し算は結合則を満たすのでリストの要素の総和を左結合で計算することができる。
</p>

<p>5 + (3 + (7 + 2)) == ((5 + 3) + 7) + 2</p>

<h2>蓄積変数</h2>

<p>
[5, 3, 7, 2]というリストを考える。
このリストは5 : [3, 7, 2]ということだ。
右結合での演算の場合[3, 7, 2]の総和を誰かに頼んでそれに5を足せば良い。
</p>

<p>
しかし左結合での演算ではそうはいかない。
[3, 7, 2]というリストだけをもらっても次の人は何もできない。
そこで5と[3, 7, 2]とをわけて次の人にわたす。
そしてその人はもらった5と3を足して8にして8と[7, 2]を次の人にわたす。
その人は8と7を足して15としそれと[2]を次の人にわたす。
さらに17と[]がわたされた人は17を結果として返す。
</p>

<p>
右結合での計算ではリストだけをわたしていけば良かったが、
左結合での計算ではリスト以外に5, 8, 15, 17と変化していく変数を
わたしていく必要がある。
このように変化していく変数を今までの変化の結果をためていくという意味で
蓄積変数と呼ぶ。
</p>

<h2>左結合の総和</h2>

<p><code>sumIter :: Integer -&gt; [Integer] -&gt; Integer<br/>
sumIter s [] = s<br/>
sumIter s (x : xs) = sumIter (s + x) xs</code></p>

<p>
上記の例では5と[3, 7, 2]をわけて蓄積変数の初期値を5とした。
このやりかただと空リストの場合が定義できない。
初期値を0として0と[5, 3, 7, 2]をわたすようなやりかたのほうが良いだろう。
</p>

<p><code>sumIter 0 [5, 3, 7, 2]<br/>
-&gt; sumIter (0 + 5) [3, 7, 2]<br/>
-&gt; sumIter ((0 + 5) + 3) [7, 2]<br/>
-&gt; sumIter (((0 + 5) + 3) + 7) [2]<br/>
-&gt; sumIter ((((0 + 5) + 3) + 7) + 2) []<br/>
-&gt; (((0 + 5) + 3) + 7) + 2<br/>
-&gt; 17</code></p>

<p>mySumはsumIterを使って定義できる。</p>

<p><code>mySum = sumIter 0</code></p>

<h2>反復的処理</h2>

<h2>再帰的処理</h2>

<h2>空間効率</h2>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/product.html"
	>「たたみこみ(右)」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer"
	>「1から学ぶHaskell」トップへ</a>
</p>
