疑似乱数列の生成

<h2>動機</h2>

<p>
モンテカルロ法で円周率を計算しよう。
正方形内にランダムな点をプロットする必要がある。
</p>

<h2>Haskell98における疑似乱数</h2>

<p>
Haskell 98標準では疑似乱数生成ライブラリが定義されていた。
実用上いくつかの問題があるためHaskell 2010では削除されている。
Haskell Platformに含まれるrandomパッケージとして使える。
</p>

<h2>ライブラリの確認</h2>

<p>
システムにSystem.Randomライブラリがあることの確認。
</p>

<code>% ghci<br/>
Prelude&gt; :m System.Random<br/>
Prelude System.Random&gt;</code>

<p>
エラーメッセージが表示されずプロンプトにSystem.Randomが追加されれば、
ライブラリはシステムにインストールされている。
</p>

<h2>予測可能で良い</h2>

<p>
一様に分布する数列であれば予測可能な数列でも良い。
返す数列を引数で指定する関数を使う。
x座標用とy座標用に2つの数列が必要だ。
</p>

<h2>関数randoms</h2>

<p>
System.Randomライブラリにはrandoms関数がある。
以下の型を持つと考えておこう。
</p>

<code>randoms :: StdGen -&gt; [Double]</code>

<p>
StdGen型の値を与えるとDouble型の値のリストを返す。
無限リストであり永遠に続くランダム列となる。
</p>

<h2>StdGen型</h2>

<p>
StdGen型は「乱数の種」だ。
この値によって乱数は変わる。
値が同じならば同じ値が返る。
この値は関数mkStdGenでIntから生成できる。
</p>

<pre><code>mkStdGen :: Int -&gt; StdGen</code></pre>

<h2>試してみる</h2>

<code>% ghci<br/>
Prelude&gt; :m System.Random<br/>
Prelude System.Random&gt; mkStdGen 8<br/>
9 1<br/>
Prelude System.Random&gt; :t it<br/>
it :: StdGen</code>

<p>
mkStdGen 8によって'9 1'というStdGen型の値が得られる。
この値で疑似乱数列を作成する。
takeを使っていくつかだけを表示する。
</p>

<code>Prelude System.Random&gt; take 3 . randoms $ mkStdGen 8 :: [Double]<br/>
[0.6022994713892826, 0.62331532360708, 0.9885723665310981]</code>

<h2>関数randomRs</h2>

<p>
関数randomsでは生成される乱数列の範囲が指定できない。
指定した範囲内の乱数列を生成するために関数randomRsがある。
</p>

<code>randomRs :: (Double, Double) -&gt; StdGen -&gt; [Double]</code>

<p>第1引数のタプルで乱数の範囲を指定する。</p>

<code>Prelude System.Random&gt; take 3 . randomRs (2, 4) $ mkStdGen 8 :: [Double]<br/>
[3.2045989427785653, 3.24663064721416, 3.9771447330621963]
</code>

<h2>関数split</h2>

<p>
座標の指定のためにはx, yの2つのランダムな値の系列が必要だ。
「ランダムの種」を2つに分けるために関数splitがある。
</p>

<code>Prelude System.Random&gt; split $ mkStdGen 8<br/>
(10 40692, 360126 2147483398)</code>

<h2>正方形内のランダムな点</h2>

<p>
原点を中心とする1辺2の正方形内のランダムな点の列を生成する。
驚かずに「そのまま」入力してみよう。
すぐに説明する。
</p>

<p><code>Prelude System.Random&gt; :m + Control.Arrow<br/>
Prelude System.Random Control.Arrow&gt; take 3 . uncurry zip .
(randomRs (-1, 1) *** randomRs (-1, 1)) . split $ mkStdGen 8 ::
[(Double, Double)]<br/>
[(-3.18859986651685e-2, -0.4475857685951523),
(-0.4281869025678364, 0.969606436457163),
(-0.7979778666086881, -0.6623840670853804)]</code></p>

<h3>関数split</h3>

<p>1つずつ組み立てていく。</p>

<p><code>split $ mkStdGen 8</code></p>

<p>2つの乱数の種をタプルにして返す。</p>

<h3>演算子(***)</h3>

<p>
演算子(***)は2要素タプルの1要素目と2要素目の両方に関数を適用する関数だ。
(* 2) *** (+ 3)は1要素目を2倍し2要素目に3を足す関数となる。
</p>

<p><code>Prelude System.Random Control.Arrow&gt; (* 2) *** (+ 3) $ (4, 2)<br/>
(8,5)</code></p>

<p>これを使って以下のようにする。</p>

<code>(randomRs (-1, 1) *** randomRs (-1, 1)) . split $ mkStdGen 8</code>

<p>
タプルの第1要素、第2要素の両方にrandomRs (-1, 1)を適用している。
別々の系列の乱数列のタプルが返る。
型は([Double], [Double])。
</p>

<h3>関数zip</h3>

<p>
zipは2つのリストを取ってそれをタプルのリストにして返す。
型は[a] -&gt; [b] -&gt; [(a, b)]だ。
uncurryによって引数である2つのリストをタプルにまとめた。
uncurry zipの型は([a], [b]) -&gt; [(a, b)]となる。
</p>

<p><code>uncurry zip . (randomRs (-1, 1) *** randomRs (-1, 1)) . split $ mkStdGen 8</code></p>


<p>
x座標のリストとy座標のリストのタプルを、x座標とy座標から成るタプルのリストとした。
</p>

<h2>まとめ</h2>

<p>
原点を中心とする1辺2の正方形内にあるランダムな点の列は以下のように生成できる。
</p>

<code>uncurry zip . (randomRs (-1, 1) *** randomRs (-1, 1))
	. split $ mkStdGen 8</code>

<p>
乱数の種を作るために作った整数値8は適当な値だ。
実際に使うときには仮引数としてパラメータ化する。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/about_montecarlo.html"
	>「モンテカルロ法の説明」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/montecarlo_coding.html"
	>「モンテカルロ法のコーディング」へ</a>
</p>
