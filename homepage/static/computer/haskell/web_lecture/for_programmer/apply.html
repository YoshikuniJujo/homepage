関数適用

<h2>演算子($)</h2>

<h3>動作</h3>

<p>
演算子($)は関数を値に適用する。
f $ xとするとxにfを適用する。
f xと同じだ。
</p>

<p><code>% ghci</br>
Prelude&gt; recip 8</br>
0.125</br></p>

<img
height="130"
alt="[単純な関数の図]"
src="/computer/haskell/web_lecture/for_programmer/images/simple_function.svg"
/>


<p><code>Prelude&gt; recip $ 8</br>
0.125</br></p>

<img
height="130"
alt="[演算子applyの図]"
src="/computer/haskell/web_lecture/for_programmer/images/operator_apply.svg"
/>

<p><code>Prelude&gt; ($) recip 8</br>
0.125</code></p>

<img
height="130"
alt="[関数applyの図]"
src="/computer/haskell/web_lecture/for_programmer/images/function_apply.svg"
/>

<h3>使い道</h3>

<p>
f $ xがf xと同じならf xと書けば良い。
演算子($)は何のためにあるのだろう。
いくつかの答えがある。ひとつは「丸括弧の省略」だ。
recip (1 + 3)のような表現をrecip $ 1 + 3に書き換えられる。
複雑な表現ではこの書き換えでコードが読みやすくなる。
($)は結合力が最弱で右結合だ。
f $ ...と書くと...の部分が全体としてfの引数になることが保証される。
</p>

<h3>型</h3>

<code>($) recip 8</code>

<p>
関数recipの型をDouble -&gt; Double、値8をDoubleと考える。
($)はDouble -&gt; DoubleとDoubleを引数としDoubleを返す。
</p>

<p><code>($) :: (Double -&gt; Double) -&gt; Double -&gt; Double</code></p>

<p>oddは「奇数である」ことを確認する関数だ。整数を取って真偽値を返す。</p>

<pre><code>($) odd 11</code></pre>

<p>
oddをInteger -&gt; Boolとし11をIntegerとする。
</p>

<p><code>($) :: (Integer -&gt; Bool) -&gt; Integer -&gt; Bool</code></p>

<p>
($)の第1引数である関数の引数と($)の第2引数の型は同じだ。
($)の第1引数である関数の返り値と($)の返り値も同じだ。
それぞれ型変数a, bで表す。
</p>

<p><code>($) :: (a -&gt; b) -&gt; a -&gt; b</code></p>

<h2>まとめ</h2>

<p>
関数適用演算子($)を学んだ。
f $ xで値xに関数fを適用する。
不要な演算子のように思えるが括弧の数を減らすのに使える。
</p>

<h2>課題</h2>

<ol>
<li>recip ((3 + 5) / 2)を演算子($)で書き直せ</li>
<li>第1引数の値に第2引数の関数を適用する関数applyを定義せよ</li>
<li>[挑戦問題] 演算子($)と関数idの関係について考えよ</li>
</ol>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/const.html"
	>「値を無視する関数」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/dot.html"
	>「関数合成」へ</a>
</p>
