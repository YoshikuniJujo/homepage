ライプニッツの公式(円周率を求める)

<h2>はじめに</h2>

<p>
簡単な例を挙げて再帰関数について学ぼう。
ここでちょっとしたジレンマに直面する。
初学者にわかりやすい例を挙げる必要がある。
しかし、初学者にわかりやすい例だと、再帰を直接使うメリットはない。
リストを使ったほうがきれいに書ける。
とりあえず、ここではリストを使ったほうが良い例で我慢しておき、
その次にリストでは解決できない例について学ぶことにしよう。
</p>

<h2>ライプニッツの公式とは</h2>

<p>
円周率を4で割った値は以下のようになる。
証明はここでは行わない。
</p>

<code>1 - 1 / 3 + 1 / 5 - 1 / 7 + 1 / 9 - ...</code>

<p>
符号を反転させながら分母を[1, 3, 5, 7, 9 ...]と増やしていく。
非常に単純な級数である。
ただし収束が遅いため実用的ではない。
</p>

<h2>再帰関数を使う</h2>

<p><a href="/computer/haskell/web_lecture/for_programmer/14_leibniz/leibnizRec.hs"
	>leibnizRec.hs</a></p>

<h3>円周率の4分の1がわかれば</h3>

<p>
「...が定義されているとすると」という仮定を受け入れることが、
再帰関数を理解するコツである。
その練習のためにこう言ってみよう。
「円周率の4分の1の近似値を求める関数が定義されているとすると」。
</p>

<p>
この関数には上記の級数の何個目まで計算するかを示すパラメータが必要だ。
このパラメータは「何個」を表すので整数値Integerとするべきだが、
計算の便宜を考えて実数値Doubleとしておこう。
</p>

<p>
円周率の4分の1の近似値を求める関数estPi4が定義されているとすると、
円周率の近似値を求める関数estPiは以下のように定義できる。
</p>

<code>estPi :: Double -&gt; Double<br/>
estPi n = 4 * estPi4 n</code>

<p>
この定義からはnを消すことができる。
以下のようにできる。
</p>

<code>estPi = (4 *) . estPi4</code>

<p>
このように仮引数を使わない書きかたをポイントフリースタイルと呼ぶ。
ポイントフリースタイルを使うことで直接的な定義となる。
上の例では「estPiはestPi4をした結果を4倍する」と考えられる。
</p>

<h3>関数estPi4</h3>

<p>
関数estPi4が今回の本題。
これを再帰関数として定義してみよう。
まず以下のようにひとつずつ見ていってみる。
</p>

<code>estPi4 0 = 1<br/>
estPi4 1 = 1 - 1 / 3<br/>
estPi4 2 = 1 - 1 / 3 + 1 / 5<br/>
estPi4 3 = 1 - 1 / 3 + 1 / 5 - 1 / 7<br/>
estPi4 4 = 1 - 1 / 3 + 1 / 5 - 1 / 7 + 1 / 9<br/>
...
</code>

<p>
これらを隣接する値同士を比較すると、以下のような関係が見つけられる。
</p>

<code>estPi4 0 = 1<br/>
estPi4 1 = estPi4 0 - 1 / 3<br/>
estPi4 2 = estPi4 1 + 1 / 5<br/>
estPi4 3 = estPi4 2 - 1 / 7<br/>
estPi4 4 = estPi4 3 + 1 / 9<br/>
...</code>

<p>
引数が奇数のときには引き算を行い、偶数のときには足し算を行っている。
また引いたり足したりする数は引数をnとすると2 * n + 1になっている。
よって以下のように書き直せるだろう。
(**)は第2引数が実数だった場合のべき乗演算子である。
第2引数が整数だった場合のべき乗演算子は(^)だったが、
これら2つは意味が異なるため別々の演算子となっている。
</p>

<code>estPi4 0 = 1<br/>
estPi4 1 = estPi4 0 + (- 1) ** 1 / (2 * 1 + 1)<br/>
estPi4 2 = estPi4 1 + (- 1) ** 2 / (2 * 2 + 1)<br/>
estPi4 3 = estPi4 2 + (- 1) ** 3 / (2 * 3 + 1)<br/>
estPi4 4 = estPi4 3 + (- 1) ** 4 / (2 * 4 + 1)<br/>
...<br/>
estPi4 n = estPi4 (n - 1) + (- 1) ** n / (2 * n + 1)</code>

<p>
このようにestPi4 0以外はnを使った表現にまとめることができる。
上記のうちestPi4 0とestPi4 nだけを抜き出せば実際のHaskellの関数定義となる。
</p>

<code>estPi4 0 = 1<br/>
estPi4 n = estPi4 (n - 1) + (- 1) ** n / (2 * n + 1)</code>

<h3>試してみる</h3>

<p>対話環境で試してみよう。</p>

<code>% ghci leibnizRec.hs<br/>
*Main&gt; estPi 10<br/>
3.232315809405594<br/>
*Main&gt; estPi 100<br/>
3.1514934010709914<br/>
*Main&gt; estPi 100000<br/>
3.1416026534897203<br/>
*Main&gt; estPi 10000000<br/>
3.1415927535898396<br/>
*Main&gt; pi<br/>
3.141592753589793
</code>

<p>
円周率に近づいていっているのがわかる。
</p>

<h2>リストを使う</h2>

<p><a href="/computer/haskell/web_lecture/for_programmer/14_leibniz/leibnizList.hs"
	>leibnizList.hs</a></p>

<p>
学習のために上では生の再帰を使ったが、
このような例ではリストを利用したほうが「きれいに」書ける。
</p>

<p>
0以上の整数のリストを作り、その要素すべてを以下の関数で置換する。
</p>

<code>\k -&gt; (- 1) ** k / (2 * k + 1)</code>

<p>
結果としてできたリストからn個取り出し、その総和を求めれば良い。
</p>

<code>estPi n = sum . take n $ map (\k -&gt; (- 1) ** k / (2 * k + 1)) [0 ..]</code>

<p>
さらにポイントフリースタイルにしてみよう。
</p>

<code>estPi = sum . (`take` map (\k -&gt; (- 1) ** k / (2 * k + 1)) [0 ..])</code>

<p>
生の再帰を使うバージョンにくらべて、
コーディングの文字数自体はむしろ増えているが、こちらのほうが「きれい」だ。
</p>

<h2>グラフ</h2>

<p>
収束の様子を示したグラフは以下のようになる。
波の振幅ははじはは急激に小さくなるが、
その後がなかなか小さくならない。
収束が遅いことを示している。
</p>

<a href="/computer/haskell/web_lecture/for_programmer/images/leibniz.svg"
><img
alt="ライプニッツの公式における円周率への収束のグラフ"
width="350"
src="/computer/haskell/web_lecture/for_programmer/images/leibniz.svg"/></a>

<h2>まとめ</h2>

<p>
再帰関数の定義のしかたを見た。
基底となる定義(今回は0)と漸化式の部分を定義することで、
自然数の範囲においてすべての場合を求めることができる。
単純な例だったので、このような場合にはリストを使ったほうが簡単だ。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/whats_rec_fun.html"
	>「再帰関数とは」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/binary_tree.html"
	>「二分樹を下へたどる」へ</a>
</p>
