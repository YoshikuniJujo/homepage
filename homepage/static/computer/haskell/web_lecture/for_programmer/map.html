リストによる「くりかえし」: 転写

<h2>3倍したものの総和</h2>

<p>
「0から3nまでの整数のうち3の倍数であるものの総和」は、
「0からnの整数を3倍したものの総和」と同じである。
列挙したものを変換したうえで蓄積するという構造を取るアルゴリズムはよくある。
これを実現するためには、
リストの各要素に同じ関数を適用した結果のリストが得られれば良い。
これを行う関数mapが用意されている。
</p>

<h2>転写</h2>

<p>
mapは第1引数としてリストの要素のすべてに適用するための関数を取る。
今回は引数を3倍する関数を使う。
求める関数は以下のようになる。
</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/11_map/sum3N.hs"
	>sum3N.hs</a></p>

<pre><code>sum3N :: Integer -&gt; Integer
sum3N n = sum $ map (* 3) [0 .. n]</code></pre>

<p>試してみる。</p>

<pre><code>% ghci sum3N.hs
*Main&gt; sum3N 10
165</code></pre>

<h2>ろ過と転写の両方を使う例</h2>

<p>
ろ過と転写の両方を使う例として、0からnの数のうち5の倍数ではないものを、
3倍したものの総和を求める例を作成する。
上述のsum3Nの整数を列挙後に「5の倍数でない」でろ過すれば良い。
</p>

<pre><code>sum3N5 :: Integer -&gt; Integer
sum3N5 n = sum . filter ((/= 0) . (`mod` 5)) $ map (* 3) [0 .. n]</code></pre>

<p>
sumとfilter ...とを関数合成したうえで、map ...に適用していることに注意する。
試してみる。</p>

<pre><code>*Main&gt; sum3N5 10
120</code></pre>

<h2>リストによる「くりかえし」のまとめ</h2>

<p>
リストによって「くりかえし」を実現するためには以下のような段階を踏む。
</p>

<ol>
<li>列挙</li>
<li>複数のろ過・転写</li>
<li>蓄積</li>
</ol>

<p>
具体的な「リスト」を次々に変化させていくという、わかりやすいメタファーで
「くりかえし」を実現することができる。
書きやすく、読みやすく、検証しやすいためバグが入りにくいコーディングができる。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/filter.html"
	>「ろ過」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/list_efficiency.html"
	>「リストによる『くりかえし』の実行効率」へ</a>
</p>
