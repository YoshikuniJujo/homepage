構文: レイアウトルール

<h2>はじめに</h2>

<p>
case式やlet式、where節はインデントで構文を表現している。
Haskell 2010 reportの2.7節で概要が説明されている。
10.3節では正確な仕様が規定されている。
インデントルールを使わないで明示的に{}や;を記述することもできる。
</p>

<p>
概要と仕様について学ぶが細かい話は雰囲気がわかる程度で良い。
再帰関数と代数的データ型と入出力を学んだあとに仕様からレイアウトルールを
解釈する関数をHaskellで実装する予定だ。
</p>

<p><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7"
	>Haskell 2010 report: 2.7 Layout</a></p>

<p><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3"
	>Haskell 2010 report: 10.3 Layout</a></p>

<h2>概要</h2>

<h3>どっちも</h3>

<p>
Haskellではレイアウトルールを使うことも明示的に{}と;を使うこともできる。
混ぜても良い。
</p>

<h3>レイアウトルールの仕組み</h3>

<p>レイアウトによって{}と;を適切な位置に追加する。</p>

<h3>レイアウトルールの開始</h3>

<p>レイアウトルールは以下のキーワードのあとに{が省略されたときに始まる。</p>

<p><code>where, let, do, of</code></p>

<p>
キーワードdoはモナドを学んだあとに説明する。
{の省略を見つけるとその次に来る語のインデントを記録する。
また、その語の前に{を追加しておく。
</p>

<h3>続き</h3>

<p>
空白行やより深いインデントは「続き」であることを意味する。
;は追加されない。
</p>

<h3>次の要素</h3>

<p>
インデントルールのはじめで記録されたのと同じ深さのインデントのとき、
次の要素として解釈される。
;が追加される。
</p>

<h3>終了</h3>

<p>
インデントが浅くなったときそのレイアウトルールは終了となる。
}が追加される。
</p>

<h3>開始後すぐに終了</h3>

<p>
インデントルールがネストしたときに内側のルール開始後すぐに終了することがある。
インデントルールを開始するキーワードのあとの語がすぐ外側のルールのインデントと
同じかまたはより浅いインデントだったときは内側のルールはすぐに終了することになる。
このとき{}が追加される。
</p>

<h3>構文エラーによる終了</h3>

<p>
上記以外でも}が追加されるときがある。
}を追加しないと構文エラーになるような場合には}の追加が試される。
</p>

<h3>インデントルールのなかの明示的な{}</h3>

<p>
明示的な{}でかこまれた内部では外側のインデントルールは適用されない。
</p>

<h2>仕様</h2>

<p>
以下に正確な仕様を記述する。
仕様書に厳密な記述があるということがわかれば良い。
なんとなくの理解で十分だ。
</p>

<h3>前処理</h3>

<p>
以下のようにしてトークン{n}と&lt;n&gt;を追加する。
</p>

<ul>
<li>let, where, do, ofのあとに{が続かないとき
	<ul>
	<li>次の語があればそのインデントをnとして{n}を</li>
	<li>ファイルの終わりであれば{0}を</li>
	</ul></li>
<li>ファイルの先頭がキーワードmoduleでも{でもないとき
	<ul>
	<li>先頭に{n}を</li>
	</ul></li>
<li>行のなかで語の前に空白以外ないとき
	<ul>
	<li>その語の前にそのインデントをnとして&lt;n&gt;を</li>
	</ul></li>
</ul>

<p>
それぞれ追加する。
タブは8タブとして扱う。
1文字目から始まる語のインデントを1として考える。0ではない。
</p>

<h3>関数L</h3>

<p>前処理後のトークン列に対して以下のような関数Lを適用する。</p>

<p><code>L (&lt;n&gt; : ts) (m : ms) = ; : (L ts (m : ms)) <span style="padding-left: 2em">if n = m</span><br/>
		<span style="padding-left: 11em">= } : (L (&lt;n&gt; : ts) ms) <span style="padding-left: 1em">if n &lt; m</span></span></br/>
L (&lt;n&gt; : ts) ms <span style="padding-left: 3em">= L ts ms</span><br/>
L ({n} : ts) (m : ms) = { : (L ts (n : m : ms)) if n &gt; m<br/>
L ({n} : ts) [] <span style="padding-left: 3em">= { : (L ts [n]) <span style="padding-left: 4.5em">if n &gt; 0</span></span><br/>
L ({n} : ts) ms <span style="padding-left: 3em">= { : } : (L (&lt;n&gt; : ts) ms)</span><br/>
L (} : ts) (0 : ms) <span style="padding-left: 1em">= } : (L ts ms)</span><br/>
L (} : ts) ms <span style="padding-left: 4em">= parse-error</span><br/>
L ({ : ts) ms <span style="padding-left: 4em">= { : (L ts (0 : ms))</span><br/>
L (t : ts) (m : ms) <span style="padding-left: 1em">= } : (L (t : ts) ms)</span><br/>
		<span class="indent4">if m /= 0 and parse-error(t)</span><br/>
L (t : ts) ms <span style="padding-left: 4em">= t : (L ts ms)</span><br/>
L [] [] <span style="padding-left: 7em">= []</span><br/>
L [] (m : ms) <span style="padding-left: 4em">= } : L [] ms <span style="padding-left: 5em">if m /= 0</span></span></code></p>

<h4>&lt;n&gt;</h4>

<p>
&lt;n&gt;は次のトークンのインデントを表す。
mは現在のインデントルールのインデント値だ。
nとmが等しければ(if n = m)、次の要素が始まるので;を追加する(; : ...)。
nがmより小さければ(if n &lt; m)、インデントルールのスコープが終了する。
}を追加しmをひとつ削る(} : (L (&lt;n&gt; : ts) ms))。
&lt;n&gt;が次のスコープのインデントより小さいあいだそれをくりかえす。
それ以外、つまりnがmsの先頭の値より大きいかまたはmsが空のときは
&lt;n&gt;は無視される(L ts ms)。
これはより深いインデントによって要素が継続することを表している。
</p>

<h4>{n}</h4>

<p>
{n}はインデントルールの始まるときのインデントを示す。
現在のスコープよりも深いとき(if n &gt; m)または現在インデントルールのスコープ外に
あるとき(L ({n} : ts) [])、{を追加しnを現在のインデント値とする(n : m : ms)。
現在のスコープよりも浅いとき{}を追加してから現在のスコープの動作を行う。
</p>

<h4>}</h4>

<p>
トークン}があったら現在のインデント値が0ならばそのまま}を残す。
「現在のインデント値が0」ということは明示的な{}のなかにいることを示している。
インデント値がそれ以外の値であれば暗黙の{に対する明示的な}ということになり、
パースエラーとなる。
</p>

<h4>{</h4>

<p>
明示的なトークン{が入力されたなら現在のインデント値を0とする。
</p>

<h4>パースエラー</h4>

<p>
インデントが0でないスコープ、つまり暗黙の{}のなかにいるときに
次のトークンでパースエラーとなるような場合には}を追加する。
</p>

<h4>そのまま</h4>

<p>
それ以外のトークン(L (t : ts) ns)に対してはそのまま(t : (L ts ms))
</p>

<h4>入力の終了</h4>

<p>
明示的、暗黙のどちらのスコープよりも外(L [] [])にあれば終了する。
また暗黙のスコープ(if m /= 0)にあればそのスコープについては問題ない。
明示的なスコープ(m = 0)のときはパースエラーとなる。
</p>

<h2>まとめ</h2>

<p>
Haskellではレイアウトルールを使うことも使わないこともできる。
レイアウトルールは{}と;の追加という形で定義される。
厳密な定義があるが感覚的に理解しやすいルールとなっている。
実際にいろいろと試してみて体で覚えるのが良いだろう。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/ifthenelse.html"
	>「構文: if式」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/whats_rec_fun.html"
	>「再帰関数とは」へ</a>
</p>
