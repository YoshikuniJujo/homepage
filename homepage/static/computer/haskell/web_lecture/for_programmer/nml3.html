NML(Nano Markup Language): 3. 他の型からの変換

<p><a href="/computer/haskell/web_lecture/for_programmer/codes/Books.hs"
	>Books.hs</a></p>

<h2>はじめに</h2>

<p>
Nml型の値から[Book]型の値への変換を見た。
次は[Book]型からNml型の値への変換を見る。
</p>

<h2>スタブ</h2>

<p>スタブを先に作っておく。</p>

<p><code>fromBooklist :: [Book] -&gt; String<br/>
fromBooklist = undefined</code></p>

<p><code>fromBooklistNml :: [Book] -&gt; Nml<br/>
fromBooklistNml = undefined</code></p>

<p><code>fromBook :: Book -&gt; Nml<br/>
fromBook = undefined</code></p>

<p>
関数fromBooklistはNmlから文字列への変換関数を
モジュールNmlに作成したあとに定義する。
</p>

<h2>関数fromBook</h2>

<p>
Book型の値をNml型の値、つまりTree String型の値に変換する。
</p>

<p><code>fromBook :: Book -&gt; Nml<br/>
fromBook b = Node "book" [<br/>
	<span class="indent1">Node "title" [Node (title b) []],</span><br/>
	<span class="indent1">Node "author" [Node (author b) []] ]</span></code></p>

<h2>関数fromBooklistNml</h2>

<p><code>fromBooklist :: [Book] -&gt; Nml<br/>
fromBooklistNml = Node "books" . map fromBook</code></p>

<h2>まとめ</h2>

<p>
たいていにおいてデコードにくらべてエンコードは簡単だ。
エンコードされる値はエンコード後の値よりもより構造がはっきりしているためだ。
エンコードされると値はよりフラットな構造となる。
Books型の値からNml型へそしてString型へとエンコードしていく。
最終的なString型の値は完全にフラットな文字のリストである。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/nml2.html"
	>「NML(2): 他の型への変換」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/nml4.html"
	>「NML(4): 表示」へ</a>
</p>
