NML(Nano Markup Language): 3. 他の型からの変換

<p><a href="/computer/haskell/web_lecture/for_programmer/codes/Books.hs"
	>Books.hs</a></p>

<h2>はじめに</h2>

<p>[Book]型をNml型にエンコードする。</p>

<h2>スタブ</h2>

<p>関数fromBooklistのスタブを作っておく。</p>

<p><code>fromBooklist :: [Book] -&gt; String<br/>
fromBooklist = undefined</code></p>

<p>
関数fromBooklistはNmlから文字列への変換関数を
モジュールNmlに作成したあとに定義する。
</p>

<h2>関数fromBook</h2>

<p>
Book型の値をNml型の値、つまりTree String型の値に変換する。
</p>

<p><code>fromBook :: Book -&gt; Nml<br/>
fromBook b = Node "book" [<br/>
	<span class="indent1">Node "title" [Node (title b) []],</span><br/>
	<span class="indent1">Node "author" [Node (author b) []] ]</span></code></p>

<h2>関数fromBooklistNml</h2>

<p><code>fromBooklist :: [Book] -&gt; Nml<br/>
fromBooklistNml = Node "books" . map fromBook</code></p>

<h2>まとめ</h2>

<p>
デコードにくらべてエンコードは簡単だ。
もとになる値はエンコード後の値よりも構造がはっきりしている。
エンコードされると値の構造はよりフラットになる。
Books型の値からNml型へそしてString型へとエンコードしていくが、
String型の値はフラットな文字のリストだ。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/nml2.html"
	>「NML(2): 他の型への変換」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/nml4.html"
	>「NML(4): 表示」へ</a>
</p>
