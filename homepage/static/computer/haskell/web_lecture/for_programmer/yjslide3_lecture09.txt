第9回 リストの再帰的定義

はじめに
* 前回はリストを作成する関数を見た
* 今回は引数無しで直接無限リストを作成する方法を見る

フィボナッチ数列
* フィボナッチ数列とは
	- 次の数が前の2項の和となる数列
	0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 ...
* 以下のように計算される
	- 0, 1のつぎは0 + 1で1
	- 1, 1のつぎは1 + 1で2
	- 1, 2のつぎは1 + 2で3
	- 2, 3のつぎは2 + 3で5
	- 3, 5のつぎは3 + 5で8
	- 5, 8のつぎは5 + 8で13
	- 8, 13のつぎは8 + 13で21

戦略
* フィボナッチ数列の最初の要素を落としたtfibsを考える
* 以下の式が成り立つ
		fibs  = 0, 1, 1, 2, 3,  5,  8, 13 ...
	+	tfibs = 1, 1, 2, 3, 5,  8, 13, 21 ...
	----------------------------------------------
	   fibs = 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ...
* つまりfibsは0, 1のあとに
	fibsとtfibsのそれぞれの要素を足したもの

新たに必要になる構文
* 以下のような例を考える
	dupHead (x : xs) = x : (x : xs)
* xとxsに分割したうえで再度(x : xs)で結合している
* ここの重複をなくしたい、つまり
* 変数への束縛と同時にパターンマッチしたい
* '@'を使えば実現できる
	dupHead xa@(x : xs) = x : xa

新たに必要になる関数
* 2つのリストの各要素を
	演算子で結合した値を要素とするリストが欲しい
* そのための関数が用意されている
	zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
	*Main> zipWith (*) [1, 2, 3] [4, 5, 6]

フィボナッチ数列
* fibsとtfibsがすでにあるとしてfibsは以下のようになる
	fibs = 0 : 1 : zipWith (+) fibs tfibs
* fibsはこれで定義されるがtfibsがまだ定義できていない
* tfibsはfibsのtail部分なので
	fibs@(_ : tfibs) = 0 : 1 : zipWith (+) fibs tfibs

フィボナッチ数列
* lectures/lecture09を作成しそこに移動
* fib.hsに以下を書き込み
	fibs, tfibs :: [Integer]
	fibs@(_ : tfibs) = 0 : 1 : zipWith (+) fibs tfibs
* 別ウィンドウで
	% ghci fib.hs
	*Main> take 30 fibs

まとめ
* リストそのものを再帰的に定義することができる
* フィボナッチ数列の直接的な定義を見た
