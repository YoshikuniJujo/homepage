まとめ: 関数

<h2>関数定義</h2>

<h3>書式</h3>

<p>[関数名] [仮引数1] [仮引数2] ... = [値]</p>

<h3>例</h3>

<p><code>foo x y = (x - 1) * y - (x + 3)</code></p>

<h3>試してみる</h3>

<p><code>% ghci<br/>
Prelude&gt; let foo x y = (x - 1) * y - (x + 3)</code></p>

<h2>関数の使用</h2>

<h3>書式</h3>

<p>[関数名] [引数1] [引数2] ...</p>

<h3>例</h3>

<p><code>foo 8 5</code></p>

<h3>試してみる</h3>

<p><code>Prelude&gt; foo 8 5<br/>
24</code></p>

<h2>多引数関数の正体</h2>

<p>
Haskellには多引数関数はない。
「2引数x, yをとり値zを返す関数のようなもの」は
「引数xをとり「引数yをとり値zを返す関数」を返す関数」だ。
</p>

<h3>試してみる</h3>

<p><code>Prelude&gt; (foo 8) 5<br/>
24</code></p>

<p>foo 8が返した関数に値5をわたす。関数適用は左結合なので丸括弧は省略できる。</p>

<h2>高階関数</h2>

<p>高階関数とは</p>

<ul>
<li>関数を引数にとる</li>
<li>関数を返す</li>
</ul>

<p>
のどちらかまたは両方の関数だ。
前者は制御構造として使える。後者は多引数関数と考えられる。
</p>

<h3>例</h3>

<p><code>twice f x = f (f x)</code></p>

<h3>試してみる</h3>

<p><code>Prelude&gt; let twice f x = f (f x)<br/>
Prelude&gt; twice succ 8<br/>
10</code></p>

<h2>関数リテラル</h2>

<h3>書式</h3>

<p>\[引数1] [引数2] ... -&gt; [値]</p>

<h3>関数定義との関係</h3>

<p>関数定義は関数リテラルによる関数の作成と変数束縛の2つを同時にする構文糖だ。</p>

<h3>例</h3>

<p><code>bar = \x y -&gt; (x - 1) * y - (x + 3)</code></p>

<h3>試してみる</h3>

<p><code>Prelude&gt; let bar = \x y -&gt; (x - 1) * y - (x + 3)<br/>
Prelude&gt; bar 8 5<br/>
24</code></p>

<h2>演算子</h2>

<p>
演算子は2引数関数だ。中置記法である。
演算子は丸括弧で関数に、関数はバッククォートで演算子になる。
変換は定義、呼び出しのどちらでも有効だ。
</p>

<h3>例</h3>

<p><code>10 `mod` 3</code></p>
<p><code>(+) 5 8</code></p>

<h3>試してみる</h3>

<p><code>Prelude&gt; 10 `mod` 3<br/>
1<br/>
Prelude&gt; (+) 5 8<br/>
13</code></p>

<h2>パターンマッチ</h2>

<p>パターンマッチによって分岐と値のとりだしができる。</p>

<h3>例</h3>

<p><code>baz (Just x) = x * 2<br/>
baz _ = 0</code></p>

<h2>ガード</h2>

<p>Bool値へのパターンマッチには特別な構文が用意されている。</p>

<p><code>qux x<br/>
	<span class="indent1">| x &lt;= 0 = 0</span><br/>
	<span class="indent1">| otherwise = x * 2</span></code></p>

<h2>まとめ</h2>

<p>
関数の記法や多引数関数は幻であること、
パターンマッチやガードによるコードの分岐を学んだ。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/type_summary.html"
	>「型」へ</a>
</p>
