まとめ: 関数

<h2>関数定義</h2>

<h3>書式</h3>

<p>[関数名] [仮引数1] [仮引数2] ... = [値]</p>

<h3>例</h3>

<p><code>foo x y = (x - 1) * y - (x + 3)</code></p>

<h3>試してみる</h3>

<p><code>% ghci<br/>
Prelude&gt; let foo x y = (x - 1) * y - (x + 3)</code></p>

<h2>関数の使用</h2>

<h3>書式</h3>

<p>[関数名] [引数1] [引数2] ...</p>

<h3>例</h3>

<p><code>foo 8 5</code></p>

<h3>試してみる</h3>

<p><code>Prelude&gt; foo 8 5<br/>
24</code></p>

<h2>多引数関数の正体</h2>

<p>
Haskellでは多引数関数というものはない。
二引数x yをとり値zを返す関数のように見えるものは本当は
引数xをとり「引数yをとり値zを返す関数」を返す関数である。
</p>

<h3>試してみる</h3>

<p><code>Prelude&gt; (foo 8) 5<br/>
24</code></p>

<p>
foo 8が返した関数に値5をわたしている。
関数適用が右結合なので括弧を省略できる。
</p>

<h2>高階関数</h2>

<p>高階関数とは</p>

<ul>
<li>関数を引数にとる</li>
<li>関数を返す</li>
</ul>

<p>
のどちらかまたは両方の関数である。
後者は多引数関数として扱える。
前者は制御構造のように使える。
</p>

<h3>例</h3>

<p><code>twice f x = f (f x)</code></p>

<h3>試してみる</h3>

<p><code>Prelude&gt; let twice f x = f (f x)<br/>
Prelude&gt; twice succ 8<br/>
10</code></p>

<h2>関数リテラル</h2>

<h3>書式</h3>

<p>\[引数1] [引数2] ... -&gt; [値]</p>

<h3>関数定義との関係</h3>

<p>関数定義は関数リテラルによる関数の作成と変数束縛の2つを同時に行う構文糖だ。</p>

<h3>例</h3>

<p><code>bar = \x y -&gt; (x - 1) * y - (x + 3)</code></p>

<h3>試してみる</h3>

<p><code>Prelude&gt; let bar = \x y -&gt; (x - 1) * y - (x + 3)<br/>
Prelude&gt; bar 8 5<br/>
24</code></p>

<h2>演算子</h2>

<p>
演算子は2引数関数と同じだ。
ただし中置記法となる。
演算子は丸括弧でくくると関数になり、関数はバッククォートでくくると演算子となる。
これらの変換は定義、呼び出しのどちらでも有効だ。
</p>

<h3>例</h3>

<p><code>10 `mod` 3</code></p>
<p><code>(+) 5 8</code></p>

<h3>試してみる</h3>

<p><code>Prelude&gt; 10 `mod` 3<br/>
1<br/>
Prelude&gt; (+) 5 8<br/>
13</code></p>

<h2>パターンマッチ</h2>

<p>パターンマッチによって分岐と値のとりだしができる。</p>

<h3>例</h3>

<p><code>baz (Just x) = x * 2<br/>
baz _ = 0</code></p>

<h2>ガード</h2>

<p>Bool値へのパターンマッチには特別な構文が用意されている。</p>

<p><code>qux x<br/>
	<span class="indent1">| x &lt;= 0 = 0</span><br/>
	<span class="indent1">| otherwise = x * 2</span></code></p>

<h2>まとめ</h2>

<p>
関数についておさらいした。
関数の記法について学び、多引数関数は幻であることを学んだ。
パターンマッチによるコードの分岐も見た。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/type_summary.html"
	>「型」へ</a>
</p>
