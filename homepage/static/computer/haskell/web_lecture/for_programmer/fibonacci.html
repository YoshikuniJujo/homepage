フィボナッチ数列

<p><a href="/computer/haskell/web_lecture/for_programmer/codes/fibonacci.hs"
	>fibonacci.hs</a></p>

<h2>はじめに</h2>

<p>
さて、これからご覧いただくのはHaskellの美しさだ。
これはすばらしく美しい。
刮目せよ。
</p>

<h2>フィボナッチ数列とは</h2>

<p><code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...</code></p>

<h3>とりあえず隣り同士の差を</h3>

<p>
これは一体どういうルールで並んでいるのだろうか。
数列を見たらまずはとりあえず隣りの数同士の差をとってみよう。
1 - 0 = 1, 1 - 1 = 0, 2 - 1 = 1, 3 - 2 = 1, 5 - 3 = 2, ...
</p>

<p><code>1, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ...</code></p>

<p>はじめの1以外はもとの数列と同じ数列になった。</p>

<h3>どういうことだ</h3>

<p>
どうしてこうなるのか。
フィボナッチ数列の項は直前ふたつの項の和となっているからだ。
</p>

<ul>
<li>0 + 1 = 1</li>
<li>1 + 1 = 2</li>
<li>1 + 2 = 3</li>
<li>2 + 3 = 5</li>
<li>3 + 5 = 8</li>
<li>5 + 8 = 13</li>
<li>8 + 13 = 21</li>
<li>13 + 21 = 34</li>
<li>21 + 34 = 55</li>
<li>34 + 55 = 89</li>
<li>55 + 89 = 144</li>
</ul>

<h3>つまり</h3>

<p>
フィボナッチ数列とは0, 1から始まりそれぞれの項が直前の2項の和になっている数列だ。
</p>

<h2>美しさへの序曲</h2>

<p>
さてそろそろ美しさを語るときが近づいてきたようだ。
以下の式を見てみよう。
</p>

<p><code><span style="padding-left: 3em">0 1 1 2 3 05 08 13 21 34 055 089 144 ...</span><br/>
+<span style="padding-left: 2.5em">1 1 2 3 5 08 13 21 34 55 089 144 233 ...</span><br/>
-----------------------------------------------------<br/>
<span style="padding-left: 1em">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 ...</span></code></p>

<h3>つまり</h3>

<p>
フィボナッチ数列は0, 1のあとに自身と自身の頭をとったものの和が続いたものだ。
</p>

<h2>定義</h2>

<p><code>fibs, tfibs :: [Integer]<br/>
fibs@(_ : tfibs) = 0 : 1 : zipWith (+) fibs tfibs</code></p>

<p>ghci fibonacci.hs<br/>
*Main&gt; take 15 fibs<br/>
[0,1,1,2,3,5,8,13,21,34,55,89,144,233,377]</p>

<h2>まとめ</h2>

<p>フィボナッチ数列のこの定義は非常に美しい。</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/zipwith.html"
	>「関数zipWithの紹介」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/map_def.html"
	>「関数map」へ</a>
</p>
