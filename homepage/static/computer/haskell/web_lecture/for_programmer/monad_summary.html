モナド: まとめ

<p>(工事中 60%)</p>

<h2>はじめに</h2>

<p>ファンクター、アプリカティブファンクター、モナドについて学んだ。</p>

<h2>階層関係</h2>

<p>
ファンクター、アプリカティブファンクター、モナドの順に制約が厳しくなる。
モナドならばアプリカティブファンクターだし、アプリカティブファンクターならば
ファンクターだ。
</p>

<h2>型クラス</h2>

<p>それぞれの型クラス宣言は</p>

<p><code>class Functor f where<br/>
	<span class="indent1">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span></code></p>

<p><code>class Functor f =&gt; Applicative f where<br/>
	<span class="indent1">pure :: a -&gt; f a</span><br/>
	<span class="indent1">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span></code></p>

<p><code>class Applicative m =&gt; Monad m where<br/>
	<span class="indent1">return :: a -&gt; m a</span><br/>
	<span class="indent1">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span></code></p>

<p>のようになる。</p>

<h2>意味</h2>

<p>
それぞれの意味は以下のようになる。
ファンクターはなかの値に対して関数適用ができる。
アプリカティブファンクターは複数の文脈つきの値に対して多引数関数が適用できる。
モナドは引数をとり文脈つきの値を返す関数同士を関数合成と似た形で合成できる。
</p>

<h2>規則</h2>

<p>ファンクター、アプリカティブ、モナドはそれぞれ満たす必要のある規則がある。</p>

<h3>ファンクタ則</h3>

<ul><li><code>fmap id == id</code></li></ul>

<p>関数fmapはなかみの値のみを変化させ文脈のほうは変化させないということだ。</p>

<h3>モノイダル則(アプリカティブ)</h3>

<ul>
<li>fmap = (&lt;*&gt;) . pure</li>
<li>unit = pure ()</li>
<li>u (.**) v = pure (,) &lt;*&gt; u &lt;*&gt; v</li>
</ul>

<p>という定義されたfmap, unit, (.**)について</p>

<ul>
<li>fmap snd (unit .** v) == v</li>
<li>fmap fst (u .** unit) == u</li>
<li>fmap asl (u .** (v .** w)) = (u .** v) .** w
	<ul>
	<li>where asl (x, (y, z)) = ((x, y), z)</li>
	</ul></li>
</ul>

<p>
演算子(.**)はふたつの文脈を融合させる。
値unitは融合したときに相手の文脈を変化させない。
また融合には結合則が成り立つ。
右結合で融合させても左結合で融合させても同じということだ。
</p>

<h3>モナド則</h3>

<ul>
<li>(f &gt;=&gt; g) x = f x &gt;&gt;= g</li>
</ul>

<p>と定義された(&gt;=&gt;)について</p>

<ul>
<li>return &gt;=&gt; g == g</li>
<li>f &gt;=&gt; return == f</li>
<li>f &gt;=&gt; (g &gt;=&gt; h) == (f &gt;=&gt; g) &gt;=&gt; h</li>
</ul>

<p>
演算子(&gt;=&gt;)は引数をとって文脈つきの値を返す関数についての関数合成だ。
関数returnは合成の相手を変化させない。
合成は結合則を満たす。
右結合での合成と左結合での合成は同じ結果を返す。
</p>

<h2>いろいろなモナド</h2>

<p>
モナドはなかみには関係ない。
モナド関数を持ちそれらがモナド則を満たせばそれはモナドだ。
モナドは形式だ。
同じようにファンクター、アプリカティブファンクターも形式だ。
</p>

<p>モナドはなかみに関係ない形式なのでさまざまなモナドが作れる。</p>

<p>
失敗する可能性のある関数を結合する仕組み、
状態変化をエミュレートする仕組み、
起こりうる可能性のある演算をすべて試す仕組みなどだ。
また、モナド関数というインターフェースのみを公開するこで
一度つけた文脈を外せなくすることも可能だ。
</p>

<h2>まとめ</h2>

<p>
ファンクター、アプリカティブファンクター、モナドという高階型の持つ性質を見た。
これらの性質を表現する型クラスをつかうと
いろいろな高階型を統一的に操作する抽象度の高い関数が定義できる。
</p>

<h2>メモ</h2>

<p>
できたらファンクター、アプリカティブファンクター、モナドについて、
クラス関数を使った文脈について多相的な関数を作り、例として提示したい。
「こんなことができるよ」といった感じで。
そのとき、ふたつのやりかたが考えられる。
抽象度が高くなかの値についても多相的な関数とするか、
文脈だけ多相的としてなかみについては単相的な関数とするか、だ。
後者のほうが簡単だ。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/monad_cage.html"
	>「モナド: ライオンの檻」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/machine.html"
	>「Machine型」へ</a>
</p>
