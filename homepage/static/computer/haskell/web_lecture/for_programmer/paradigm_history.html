プログラミングパラダイムの歴史

<p>
プログラミングパラダイムの歴史の一面を見ていこう。
とくに、手続き型から関数型へのパラダイムの遷移を「状態変化との戦い」という
軸で見ていくことにする。
</p>

<small>
(注): 関数型言語における「関数」とその他の言語における「関数」とは重なる点もあるが
大きく異なるところも多々あるため、ここでは前者を「関数」と呼び、
後者を「サブルーチン」と呼ぶことにする。
</small>

<h2>配線の組み換え</h2>

<p>
ENIACというコンピュータが発表されたのが1946年、今から70年ほど前になる。
そのころのプログラミングは配線を組み換えることで行われた。
</p>

<h2>機械語</h2>

<p>
1949年のEDSACにおいて「プログラム内蔵方式」のいわゆるノイマン型の
コンピュータが作成された。
これによって「コンピュータの動作」を入力によって組み立てていくことが可能となった。
</p>

<p>
個々の動作は数値化され、その数値を入力してやることで
プログラムを実行させることができた。
当時はカードにいくつもの穴を開けて、それを機械に読み取らせることで、
機械に対する入力を行っていた。
入力方法は大きく異なるが、現在のコンピュータも、本質的なところでは、
この時代のコンピュータと変わらない。
つまり、数値を命令として受け取り、それに従って個々の動作を行っている。
</p>

<h2>アセンブラ</h2>

<p>
機械に対する命令は数値として人間が指定していた。
しかし、「足し算は何番」「引き算は何番」というふうに覚えておくよりも、
たとえば「add eax, 4(レジスタeaxに4を足す)」のような記述を数字の列に変換するほうが、
プログラムを書くのも読むのも簡単ということになり、
その変換ルールが作成された。
はじめのうちは、それを人間が機械語に翻訳していたが、
機械を走らせるのにかかるコストが低くなり、
相対的に人間にかかるコストが高くなってきたため、
その変換を機械にやらせることになった。
</p>

<p>
アセンブリ言語はほぼ機械語と一対一対応と考えられる。
それでも、もどり番地と引数をスタックに記憶させたうえで、
指定の番地へのジャンプ命令を実行することで、
現在のサブルーチンの動作を実現することはできる。
</p>

<h2>構造化プログラミング</h2>

<p>
アセンブリ言語では実際の機械の動作を反映して、
実行するコード行に次々にジャンプするというやりかたでコードが組まれていた。
しかし、このやりかたでは、どのコードが実行されるのかが人間にとって明確ではなく、
コードが何をするのかがわからないという問題があった。
</p>

<p>
人間にとって読みやすいコードを作成するには、
無分別なジャンプ命令ではなく、何らかの制限が必要と考えられるようになった。
そこで「無分別なジャンプ」で実現できるアルゴリズムをすべて表現できるけれど、
より扱いやすい3つの組が考えられた。それが「順接」「反復」「分岐」である。
</p>

<p>
コードの任意の個所へのジャンプを許す代わりに、
「コードを順番に実行」「条件を満たすあいだ処理をくりかえす」
「条件が成立するかどうかで行う処理を選ぶ」の3つのみを許すようにした。
</p>

<p>
このようにすることで、どのようなときに、
どのコードが実行されるかが明確にすることができた。
</p>

<h2>サブルーチン</h2>

<p>
「構造化プログラミング」とは並行する概念として、
サブルーチンという考えかたも生まれた。
コードの塊に名前をつけておき、
メインとなる処理のなかでこれを呼び出し、
実行後はメインの処理にもどる。
引数として与える値を変えることで処理を変化させることができ、
また、処理の結果、何が起きたかを返り値で示すこともできる。
</p>

<h2>手続き型言語</h2>

<p>
構造化プログラミングの考え方やサブルーチンの考えかたを取り入れたのが、
狭義の手続き型言語である。
「コードの実行」についての問題は解決された。
どのようなときに、コードのどの部分が実行されるかは誰の目にも明らかである。
</p>

<p>
「どのコードが実行されるかわからない」という問題は解決したが、
新たな問題が生じてきた。
データの問題である。
サブルーチンはデータを変化させる。
</p>

<p>
ここでひとつのサブルーチンでは処理が完結しない処理Aについて考えてみよう。
処理AはA1、A2のふたつのサブルーチンの呼び出しで完結するものとする。
このとき、サブルーチンA1が保存しておいた値をサブルーチンBが変化させてしまうとする。
するとサブルーチンA2は必要な値が変化してしまっているので、
正しい動作を行うことができなくなる。
</p>

<p>
そこで、それぞれのコードが変更できる状態を制限することにした。
いわゆる「変数のスコープ」である。
それぞれのサブルーチンが「自分だけが変更できる変数」を持つようにすれば、
他のサブルーチンからそれが変更されてしまうことはなくなる。
C言語を知っている人であればstaticをつけたローカル変数と言えばわかるだろう。
</p>

<p>
これはつまり「状態の変化」をそれぞれのサブルーチンのなかに
閉じ込めたということであり、
言ってみれば「状態を持ったサブルーチン」ということになる。
</p>

<h2>オブジェクト志向</h2>

<p>
あるサブルーチンの持っているデータを
他のサブルーチンが変化させてしまうという問題は解決した。
しかし、同じひとつのサブルーチンが複数のデータを扱うことはできない。
</p>

</p>
たとえば、トークンの切り出しをするサブルーチンを考えてみよう。
まず、そのサブルーチンに文字列を読み込み、その後はそのサブルーチンを呼び出すたびに、
ひとつずつトークンを切り出してくれるものとする。
これは、サブルーチンの持つ状態が次々と変化していくものと考えることができる。
</p>

<p>
扱っている文字列がひとつのときには問題なく動作する。
しかし、同時に複数の文字列を扱おうとしたときにこれは破綻する。
</p>

<p>
それを解決するためには、「状態を持つサブルーチン」を複数用意すれば良い。
文字列Sのトークン切り出しにはサブルーチンAを使い、
文字列Tのトークン切り出しにはサブルーチンA'を使えば良い。
</p>

<p>
それぞれのデータごとに、それぞれの「状態を持つサブルーチン」を用意してやる。
それがオブジェクト志向の中心的な考えかたである。
</p>

<h2>関数型</h2>

<p>
手続き型からオブジェクト志向へのパラダイムシフト。
それは大きな進展だった。
状態変化をオブジェクトという小部屋のなかに閉じ込めることで、
その破壊力を減少させることができた。
</p>

<p>
しかし、本質的な問題は解決されていない。
メソッドを呼び出すたびに、知らないうちに様々な状態が変化してしまう。
その変化はどこまでも広がっていく。
メソッドはブラックボックスとして扱うことができない。
つまり、内部の動作を知らなければ使うことができない。
</p>

<p>
問題はどこにあるのか。
問題はサブルーチンというものが2つの概念を混同していたというところにある。
サブルーチンは関数のようでもあり、入出力のようでもあった。
関数とは何かと何かを関連づけるものであり、
入出力とは動作である。
たとえば足し算は関数である。
1と2という数と3という数とを関連づける。
そしてたとえばファイルの内容を書き換えるのは入出力だ。
</p>

<p>
「純粋な」関数型言語ではこの2つを切り分けることに成功した。
関数は関数であり入出力は入出力であり、
サブルーチンというキメラを使う必要がなくなった。
</p>

<p>
関数を呼ぶのは安全になった。
引数と返り値だけを見れば関数のしたことはすべてわかる。
ようやくブラックボックスとして使える部品を手に入れることができたことになる。
</p>

<h2>まとめ</h2>

<p>
手続き型、オブジェクト志向、そして関数型へというパラダイムシフトを見てきた。
それは状態変化との戦いであったと言える。
関数型というパラダイムに至ってはじめて「状態変化」は我々の手に負えるレベルにまで
飼いならされたと言える。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer"
	>「1から学ぶHaskell」トップへもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/motivation.html"
	>「Haskellを学ぶ動機」へ</a>
</p>
