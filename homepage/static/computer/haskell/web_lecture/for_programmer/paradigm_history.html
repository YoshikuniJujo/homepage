プログラミングパラダイムの歴史

<p>
プログラミングパラダイムの歴史の一面を見ていく。
とくに、手続き型から関数型へのパラダイムの遷移を「状態変化との戦い」という
軸で見ていこう。
</p>

<small>
(注): 関数型言語における「関数」とその他の言語における「関数」とは重なる点もあるが
大きく異なるところもあるため、ここでは前者を「関数」と呼び、
後者を「サブルーチン」と呼ぶ。
</small>

<h2>配線の組み換え</h2>

<p>
世界初ともされるコンピュータであるENIACが発表されたのが1946年、今から70年ほど前。
プログラミングは配線の組み換えによって行われた。
</p>

<h2>機械語</h2>

<p>
1949年のEDSACにおいて「プログラム内蔵方式」の
いわゆるノイマン型コンピュータが作成された。
「コンピュータの動作」を入力によって組み立てていくことが可能となった。
個々の動作は数値化され、その数値の入力でコンピュータを制御する。
当時はたくさんの穴をあけた紙テープの読み取りによって機械への入力を行った。
現在のコンピュータも、
入力方法は変わっても、本質的にはこの時代のコンピュータと同じである。
数値を命令として受け取り指定された動作を行う。
</p>

<h2>アセンブラ</h2>

<p>
機械に対する命令は数値として人間が指定していた。
しかし、「足し算は何番」「引き算は何番」のように人間が記憶するよりも、
「add eax, 4(レジスタeaxに4を足す)」のような記述を数字の列に変換するほうが、
プログラムを書くのも読むのも簡単だ。
そのための変換ルールが作成された。
はじめのうちは、機械語への翻訳は人間の役目だったが、
機械を動かすのにかかるコストが低くなり、
人間にかかるコストが相対的に高くなってきたため、
その変換を機械にやらせるようになった。
</p>

<p>
アセンブリ言語はほぼ機械語と一対一対応である。
非常に機械に近い記述ではあるが、
もどり番地と引数を記憶してから指定番地へジャンプすることで、
サブルーチンの動作を実現できる。
</p>

<h2>構造化プログラミング</h2>

<p>
実際の機械の動作を反映して、
実行するコード行に次々にジャンプするというやりかたでコードが組まれてきた。
しかし、このやりかたでは、どのコードを実行するのかが人間にとって明白ではなく、
コードの動作がわかりにくいという問題がある。
人間が読みやすいコードの作成のためには、ジャンプ命令に対する何らかの制限が必要だ。
そこで「無分別なジャンプ」で実現できるアルゴリズムをすべて表現可能で、
より扱いやすい3つの組が考えられた。それが「順接」「反復」「分岐」だ。
コードの任意の個所へのジャンプを許す代わりに、
「コードを順番に実行」「条件を満たすあいだ処理をくりかえす」
「条件が成立するかどうかで行う処理を選ぶ」の3つのみを許す。
</p>

<p>
この制限があれば、いつどのコードを実行するかは明白だ。
</p>

<h2>サブルーチン</h2>

<p>
「構造化プログラミング」とは並行する概念として
サブルーチンという考えかたも生まれた。
コードの塊に名前をつけておき、
本流となる処理のなかでこれを呼び出し、実行後は本流にもどる。
引数として与える値を変えることで処理を変化させ、
また、処理の結果何が起きたかを返り値で示す。
</p>

<h2>手続き型言語</h2>

<p>
構造化プログラミングの考え方やサブルーチンの考えかたを取り入れたのが、
狭義の手続き型言語だ。
「コードの実行」についての問題は解決した。
コードのどの部分がいつ実行されるかは誰の目にも明らかだ。
しかし、データの問題は残る。
サブルーチンはデータを変化させる。
1つのサブルーチンで完結しない処理Aを考える。
処理AはA1、A2の2つのサブルーチンで完結する。
このとき、サブルーチンA1が保存した値をサブルーチンBが変化させてしまうとする。
するとサブルーチンA2は保存された値が変化しているので正しく動作しない。
</p>

<img
alt="サブルーチンの競合の図"
src="/computer/haskell/web_lecture/for_programmer/images/sub_a1_a2_b.svg"
/>

<p>
解決のためには、それぞれのコードが変更できる状態を制限すれば良い。
「変数のスコープ」という考えかたを取り入れる。
サブルーチンが「自分だけが変更できる変数」を使えば、
他のサブルーチンによる誤った変更はない。
C言語で言えばstaticをつけたローカル変数だ。
「状態変化」をそれぞれのサブルーチンのなかに閉じ込めた。
「サブルーチンが状態を持つ」ということだ。
</p>

<h2>オブジェクト志向</h2>

<p>
他のサブルーチンによるデータの書き変えの問題は解決した。
しかし、これだと1つのサブルーチンが複数のデータを扱うことはできない。
トークンの切り出しをするサブルーチンを考える。
サブルーチンに文字列を読み込み、その後は呼び出しのたびに
ひとつずつトークンを切り出していく。
この例では、サブルーチンの状態が次々と変化していっている。
扱っている文字列がひとつのときには問題なく動作する。
しかし、同時に複数の文字列を扱おうとしたときにこれは破綻する。
解決のためには、「状態を持つサブルーチン」を複数用意すれば良い。
文字列Sのトークン切り出しにはサブルーチンAを使い、
文字列Tのトークン切り出しにはサブルーチンA'を使う。
</p>

<p>
それぞれのデータごとに「状態を持つサブルーチン」を用意する。
これがオブジェクト志向の中心的な考えかたである。
</p>

<h2>関数型</h2>

<p>
手続き型からオブジェクト志向へのパラダイムシフト。
それは大きな進展だった。
状態変化をオブジェクトという小部屋のなかに閉じ込めることで、
その破壊力を減少させた。
しかし、本質的な解決ではない。
メソッドを呼び出すたびに、知らないうちに様々な状態が変化する。
その変化はどこまでも広がっていく。
メソッドはブラックボックスとして扱うことができない。
内部の動作を知らなければ安全に使うことができない。
問題は、サブルーチンにおいて2つの概念が混同されていたことにある。
サブルーチンは関数のようであり、入出力のようでもある。
関数とは何かと何かを関連づけるものであり、
入出力とは動作である。
たとえば足し算は関数である。
1と2という数と3という数とを関連づける。
たとえばファイルの内容を書き換えるのは入出力だ。
「純粋な」関数型言語ではこの2つを切り分けた。
関数は関数であり入出力は入出力であり、
サブルーチンというキメラを使う必要はもはやない。
</p>

<p>
関数を呼ぶのは安全だ。
引数と返り値だけを見れば関数のしたことはすべてわかる。
関数はブラックボックスとして使える部品である。
</p>

<h2>まとめ</h2>

<p>
手続き型、オブジェクト志向、そして関数型というパラダイムシフトを見てきた。
一面において、それは状態変化との戦いであったと言える。
関数型というパラダイムに至ってはじめて「状態変化」は我々の手に負えるレベルにまで
飼いならされた。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer"
	>「1から学ぶHaskell」トップへもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/motivation.html"
	>「Haskellを学ぶ動機」へ</a>
</p>
