多相関数

<h2>多相関数とは</h2>

<p>複数の型の値に適用可能な関数があり、これを多相関数と呼ぶ。</p>

<h2>関数id</h2>

<h3>動作</h3>

<p>
最も単純な多相関数に関数idがある。
まずは動作を見てみよう。
</p>

<pre><code>% ghci
Prelude&gt; id 8
8
Prelude&gt; id "hello"
"hello"
Prelude&gt; id 'c'
'c'</code></pre>

<p>
関数idは引数と同じ値を返す関数である。
つまり、id 8と書くのと8と書くのとは同じことである。
「同じ値を返す」という動作はどのような型でも可能だ。
つまり関数idはすべての型の値を引数と(し返り値と)することができる。
関数定義は以下のようになる。</p>

<pre><code>id x = x</code></pre>

<h3>使い道</h3>

<p>
関数idなんて何のためにあるの。
なんでこんな関数が標準ライブラリにあるのだろうか。
と、思うかもしれない。
しかし、この関数が意外と使えるのだ。
学習が進むといろいろな例が挙げられるのだが、
今のところは人工的な例でがまんしていただきたい。
</p>

<p>
第1引数で第2引数を割った値を返す関数を作りたい。
ただし、第1引数が0だった場合には第2引数をそのまま返すようにする。
こんな関数を作ってみよう。
素直に作ると以下のようになる。
</p>

<pre><code>devide :: Double -&gt; Double -&gt; Double
devide 0 b = b
devide a b = b / a</code></pre>

<p>
この定義はもっと簡潔にできる。
まず、2行目は演算子の部分適用を使って、<code
>devide a = (/ a)</code>のように書ける。
つまり「devide aは何かをaで割ったものである」ということだ。
それでは1行目はどうなるだろうか。
ここに関数idが使える。<code>devide 0 = id</code>となる。
これは「devide 0は引数をそのまま返す関数である」ということになる。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/05_polymorphic/id.hs"
	>id.hs</a></p>

<pre><code>devide :: Double -&gt; Double -&gt; Double
devide 0 = id
devide a = (/ a)</code></pre>

<p>
仮引数を減らすことでより「直接的」な表現になる。
対話環境で試してみよう。
</p>

<pre><code>% ghci id.hs
*Main&gt; devide 6 9
1.5
*Main&gt; devide 0 8
8.0</code></pre>

<h3>型</h3>

<p>
関数idの型はどうなっているのだろうか。
たとえばid 8では関数idの型は以下のようになる。
</p>

<pre><code>Integer -&gt; Integer</code></pre>

<p>id "hello"では以下のようになる。</p>

<pre><code>String -&gt; String</code></pre>

<p>
つまり[型X] -&gt; [型X]のような形になっていることがわかる。
引数と返り値の型が同じであれば、どのような型でも良い。
これを表現するには「型変数」が使える。
型変数は小文字で始まる識別子であり、しばしば小文字1文字で表される。
idの型は以下のようになる。
</p>

<pre><code>a -&gt; a</code></pre>

<p>
何でも良いので型aの値を取って、同じ型である型aの値を返すということだ。
対話環境で関数idの型を確認してみよう。
</p>

<pre><code>% ghci
Prelude&gt; :t id
id :: a -&gt; a</code></pre>

<h2>関数const</h2>

<h3>動作</h3>

<p>
どのような引数でも常に同じ値を返す関数を考えてみよう。
たとえば何に対しても常に0を返す関数は以下のようになる。
</p>

<pre><code>const0 _ = 0</code></pre>

<p>
あるいは何に対しても常に文字'A'を返す関数は以下のようになる。
</p>

<pre><code>constA _ = 'A'</code></pre>

<p>
これらの関数は「何に対しても常に値xを返す関数」としてまとめられるので、
以下のような関数を用意することでまとめることができる。
</p>

<pre><code>const x _ = x</code></pre>

<p>
このconstを使うことで上記2つの関数はそれぞれ以下のように書くことができる。
</p>

<pre><code>const0 = const 0
constA = const 'A'</code></pre>

<p>
constはすでに定義済みの関数なので以下のように試すことができる。
</p>

<pre><code>% ghci
Prelude&gt; const 0 4492
0
Prelude&gt; const 'A' "Hello, world!"
'A'
Prelude&gt; const 'A' 999
'A'</code></pre>

<h3>使い道</h3>

<p>
関数idの例では、割る数が0の場合、割られる数をそのまま返すという仕様にした。
今度は割る数が0の場合には0を返すような仕様にしてみよう。
素直に書くと以下のようになる。
</p>

<pre><code>devide' :: Double -&gt; Double -&gt; Double
devide' 0 _ = 0
devide' a b = b / a</code></pre>

<p>
これも関数idの例と同じように割られる数となる仮引数を省略することができる。
「devide' 0は引数に関係なく0を返す関数」とし0でないaについては
「devide' aは引数をaで割る関数」とすれば良い。
</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/05_polymorphic/const.hs"
	>const.hs</a></p>

<pre><code>devide' :: Double -&gt; Double -&gt; Double
devide' 0 = const 0
devide' a = (/ a)</code></pre>

<h3>型</h3>

<p>
関数constは、xを引数に取り「引数に関わらず常にxを返す関数」を返す関数である。
constを2引数関数としてとらえた場合、
第2引数を無視し第1引数の値を返す関数と考えることができる。
つまり、constの第1引数と返り値は同じ型である必要があるが、
第2引数は何でも良いということになる。
つまり以下のような型になるだろう。
</p>

<pre><code>a -&gt; b -&gt; a</code></pre>

<h2>演算子($)</h2>

<h3>動作</h3>

<p>
演算子($)は関数を値に適用する演算子である。
f $ xとするとxにfを適用するという意味になる。
これはf xと同じことだ。
対話環境で試してみよう。
</p>

<pre><code>% ghci
Prelude&gt; recip 8
0.125
Prelude&gt; recip $ 8
0.125
Prelude&gt; ($) recip 8
0.125</code></pre>

<h3>使い道</h3>

<p>
f $ xがf xと同じなら、f xと書けば良い。
演算子($)の存在理由は一体どこに?
</p>

</p>
いくつかの答えがあるがその答えのうちのひとつは「丸括弧の省略」にある。
たとえばrecip (1 + 3)のような表現があった場合にrecip $ 1 + 3のように書ける。
表現が複雑になってくると、
このような書き換えによってコードが読みやすくなる。
また、($)は結合力が最弱であり、しかも右結合なので、
f $ ...のように書かれている場合、
...の内容が全体としてfの引数になることが保証される。
これは可読性を向上させる有効な手段となる。
</p>

<h3>型</h3>

<p>
($)の型について考えてみよう。
まずは以下の型について見てみる。
</p>

<pre><code>($) recip 8</code></pre>

<p>
recipはDouble -&gt; Doubleとし、8をDoubleと考えると、
($)はDouble -&gt; DoubleとDoubleを引数として取りDoubleを返すので、
型は以下のようになる。
</p>

<pre><code>(Double -&gt; Double) -&gt; Double -&gt; Double</code></pre>

<p>
別の例を考えようoddは「奇数である」ことを確認する関数であり、
整数を取って真偽値を返す。
以下の例を見てみよう。
</p>

<pre><code>($) odd 11</code></pre>

<p>
oddをInteger -&gt; Boolとし、11をIntegerとすると、
この場合の($)の型は以下のようになる。
</p>

<pre><code>(Integer -&gt; Bool) -&gt; Integer -&gt; Bool</code></pre>

<p>
($)の第1引数である関数の引数と($)の第2引数の型は同じでなければならない。
また($)の第1引数である関数の返り値と($)の返り値も同じでなければならない。
よって($)の型は以下のようになるだろう。
</p>

<pre><code>($) :: (a -&gt; b) -&gt; a -&gt; b</code></pre>

<h2>演算子(.)</h2>

<h3>動作</h3>

<p>
演算子(.)は関数を合成する演算子である。
f . gとすると引数にgを適用した結果にfを適用する関数となる。
たとえば3足して2をかける関数は以下のように書ける。
</p>

<pre><code>(* 2) . (+ 3)</code></pre>

<p>試してみよう。</p>

<pre><code>% ghci
Prelude&gt; ((* 2) . (+ 3)) 8
22</code></pre>

<h3>定義</h3>

<p>演算子(.)の定義は以下のようになる。</p>

<pre><code>(f . g) x = f (g x)</code></pre>

<p>以下のように書いても同じことだ。</p>

<pre><code>(.) f g x = f (g x)</code></pre>

<p>
第3引数xに第2引数である関数gを適用し、その結果である(g x)に第1引数である
fを適用している。
</p>

<h3>使い道</h3>

<p>RSA暗号の例で作ったxxcryptは以下のような定義だった。</p>

<pre><code>xxcrypt n ed mc = mc ^ ed `mod` n</code></pre>

<p>これを部分適用と関数合成を使うと以下のように書き換えることができる。</p>

<pre><code>xxcrypt n ed = (`mod` n) . (^ ed)</code></pre>

<p>「ed乗してnの剰余を取る」と読むことができる。</p>

<h3>型</h3>

<p>
(.)の型について見ていこう。
以下のような式を考える。
</p>

<pre><code>f . g</code></pre>

<p>同じことだがわかりやすさのために関数的な書きかたにしてみる。</p>

<pre><code>(.) f g</code></pre>

<p>
gの返り値をfの引数として渡すのでそれらは同じである必要がある。
それを満たすように、gの型をa -&gt; bとし、fの型をb -&gt; cとする。
結果としてできるf . gの引数はgの引数を引数としfの返り値を返り値とする。
よって以下のようになる。
</p>

<pre><code>f :: b -&gt; c
g :: a -&gt; b
f . g :: a -&gt; c</code></pre>

<p>
演算子(.)は引数としてf, gを取って返り値としてf . gを返す関数である。
よって(.)の型は以下のようになる。
</p>

<pre><code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code></pre>

<h2>まとめ</h2>

<p>
いくつかの多相関数を見てきた。
多相関数の多くは、ある意味では制御構造と呼べる。
とくに関数を引数に取る関数によって、普通に関数を定義するだけで、
独自の制御構造を作成することができる。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/type_driven.html"
	>「型駆動開発」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer"
	>「1から学ぶHaskell」トップへ</a>
</p>
