多相関数

<h2>多相関数とは</h2>

<p>
複数の型の値を引数や返り値とすることができる関数を多相関数と呼ぶ。
</p>

<h2>関数id</h2>

<h3>動作</h3>

<p>関数idの動作を見てみよう。</p>

<pre><code>% ghci
Prelude&gt; id 8
8
Prelude&gt; id "hello"
"hello"
Prelude&gt; id 'c'
'c'</code></pre>

<img
height="130"
alt="[関数idの図]"
src="/computer/haskell/web_lecture/for_programmer/images/function_id.svg"
/>

<p>
関数idは引数と同じ値を返す関数だ。
id 8は8と同じである。
「同じ値を返す」という動作はどのような型でも可能だ。
関数idはすべての型の値を引数とし同じ型の値を返り値とする。
関数定義は以下のようになる。</p>

<code>id x = x</code>

<h3>使い道</h3>

<p>
どう使うのか。
今の段階で理解できる例で説明する。
第1引数で第2引数を割った値を返す関数を作る。
第1引数が0のときは第2引数をそのまま返す。
</p>

<pre><code>devide :: Double -&gt; Double -&gt; Double
devide 0 b = b
devide a b = b / a</code></pre>

<p>
簡潔にしよう。
2行目は演算子の部分適用で<code>devide a = (/ a)</code>と書ける。
「devide aは引数をaで割る関数」だ。
1行目はどうなるだろうか。
関数idが使える。<code>devide 0 = id</code>とする。
「devide 0は引数をそのまま返す関数」だ。
</p>

<p><a
href="/computer/haskell/web_lecture/for_programmer/05_polymorphic/id.hs"
	>id.hs</a></p>

<pre><code>devide :: Double -&gt; Double -&gt; Double
devide 0 = id
devide a = (/ a)</code></pre>

<p>
仮引数を減らすことでより「直接的」な表現になる。
対話環境で試してみよう。
</p>

<pre><code>% ghci id.hs
*Main&gt; devide 6 9
1.5
*Main&gt; devide 0 8
8.0</code></pre>

<h3>型</h3>

<p>
関数idの型は何だろう。
たとえばInteger型の値8に対して適用されたとき、関数idの型は以下のようになる。
</p>

<pre><code>Integer -&gt; Integer</code></pre>

<p>id "hello"では以下のようになる。</p>

<pre><code>String -&gt; String</code></pre>

<p>
[型X] -&gt; [型X]のような形になっている。
引数と返り値の型が同じであればどの型でも良い。
これを表現するのに「型変数」を使う。
型変数は小文字で始まる識別子だ。
しばしば小文字1文字で表される。
idの型は以下のようになる。
</p>

<code>a -&gt; a</code>

<p>
何でも良いので型aの値を取って同じ型aの値を返す。
対話環境で関数idの型を確認してみよう。
</p>

<pre><code>% ghci
Prelude&gt; :t id
id :: a -&gt; a</code></pre>

<h2>関数const</h2>

<h3>動作</h3>

<p>
引数にかかわらず常に同じ値を返す関数を作る。
たとえば引数に何を与えても0を返す関数だ。
</p>

<code>const0 _ = 0</code>

<p>あるいは何を与えても文字'A'を返す関数でも良い。</p>

<code>constA _ = 'A'</code>

<p>
これらの関数は「何を与えても値xを返す関数」としてまとめられる。
以下の関数で生成することができる。
</p>

<p><code>const x _ = x</code></p>

<img
height="130"
alt="[関数constの図]"
src="/computer/haskell/web_lecture/for_programmer/images/function_const.svg"
/>

<p>constを使って上記2つの関数はそれぞれ以下のように書ける。</p>

<p><code>const0 = const 0<br/>
constA = const 'A'</code></p>

<p>constは定義済みの関数である。 対話環境で見てみよう。</p>

<code>% ghci<br/>
Prelude&gt; const 0 4492<br/>
0<br/>
Prelude&gt; const 'A' "Hello, world!"<br/>
'A'<br/>
Prelude&gt; const 'A' 999<br/>
'A'</code>

<h3>使い道</h3>

<p>
関数idの使い道を示した例では割る数が0のときは割られる数をそのまま返した。
今度は割る数が0の場合には0を返すことにする。
</p>

<code>devide' :: Double -&gt; Double -&gt; Double<br/>
devide' 0 _ = 0<br/>
devide' a b = b / a</code>

<p>
これも割られる数である第2引数を省略できる。
「devide' 0は何を与えても0を返す関数」であり、
「devide' aは引数をaで割る関数」だ。
</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/05_polymorphic/const.hs"
	>const.hs</a></p>

<pre><code>devide' :: Double -&gt; Double -&gt; Double
devide' 0 = const 0
devide' a = (/ a)</code></pre>

<h3>型</h3>

<p>
関数constはxを引数に取り「何を与えてもxを返す関数」を返す関数だ。
constを2引数関数として考えてみよう。
第2引数を無視し第1引数の値を返す関数となる。
constの第1引数と返り値は同じ型である必要がある。
第2引数は何でも良い。
</p>

<code>a -&gt; b -&gt; a</code>

<h2>演算子($)</h2>

<h3>動作</h3>

<p>
演算子($)は関数を値に適用する演算子だ。
f $ xとするとxにfを適用するという意味になる。
f xと同じだ。
対話環境で試してみよう。
</p>

<p><code>% ghci</br>
Prelude&gt; recip 8</br>
0.125</br></p>

<img
height="130"
alt="[単純な関数の図]"
src="/computer/haskell/web_lecture/for_programmer/images/simple_function.svg"
/>


<p><code>Prelude&gt; recip $ 8</br>
0.125</br></p>

<img
height="130"
alt="[演算子applyの図]"
src="/computer/haskell/web_lecture/for_programmer/images/operator_apply.svg"
/>

<p><code>Prelude&gt; ($) recip 8</br>
0.125</code></p>

<img
height="130"
alt="[関数applyの図]"
src="/computer/haskell/web_lecture/for_programmer/images/function_apply.svg"
/>

<h3>使い道</h3>

<p>
f $ xがf xと同じならf xと書けば良い。
演算子($)は何のためにあるのだろうか。
いくつかの答えがある。ひとつは「丸括弧の省略」だ。
recip (1 + 3)のような表現をrecip $ 1 + 3に書き換えられる。
複雑な表現ではこの書き換えでコードが読みやすくなる。
($)は結合力が最弱で右結合だ。
f $ ...と書くと...の部分が全体としてfの引数になることが保証される。
</p>

<h3>型</h3>

<p>($)の型はどうなるだろう。以下の例について見てみよう。</p>

<code>($) recip 8</code>

<p>
recipはDouble -&gt; Double、8はDoubleと考えよう。
($)はDouble -&gt; DoubleとDoubleを引数として取りDoubleを返す。
</p>

<code>(Double -&gt; Double) -&gt; Double -&gt; Double</code>

<p>
oddは「奇数である」ことを確認する関数だ。整数を取って真偽値を返す。
以下の例を見てみよう。
</p>

<pre><code>($) odd 11</code></pre>

<p>
oddをInteger -&gt; Boolとし11をIntegerとする。
この場合の($)の型は以下のようになる。
</p>

<pre><code>(Integer -&gt; Bool) -&gt; Integer -&gt; Bool</code></pre>

<p>
($)の第1引数である関数の引数と($)の第2引数の型は同じだ。
($)の第1引数である関数の返り値と($)の返り値も同じだ。
よって($)の型は以下のようになる。
</p>

<pre><code>($) :: (a -&gt; b) -&gt; a -&gt; b</code></pre>

<h2>演算子(.)</h2>

<h3>動作</h3>

<p>
演算子(.)は関数を合成する。
f . gは引数にgを適用した結果にfを適用する関数だ。
3足して2をかける関数は以下のように書ける。
</p>

<code>(* 2) . (+ 3)</code>

<p>試してみよう。</p>

<code>% ghci<br/>
Prelude&gt; ((* 2) . (+ 3)) 8<br/>
22</code>

<h3>定義</h3>

<p>演算子(.)の定義は以下のようになる。</p>

<p><code>(.) f g x = f (g x)</code></p>

<img
height="130"
alt="[関数dotの図]"
src="/computer/haskell/web_lecture/for_programmer/images/function_dot.svg"
/>

<p>
第3引数xに第2引数である関数gを適用した結果に第1引数であるfを適用する。
演算子であることを強調したければ以下のように書く。
</p>

<p><code>(f . g) x = f (g x)</code></p>

<p>あるいは</p>

<p><code>f . g = \x -&gt; f (g x)</code></p>

<img
height="130"
alt="[演算子dotの図]"
src="/computer/haskell/web_lecture/for_programmer/images/operator_dot.svg"
/>

<h3>使い道</h3>

<p>RSA暗号の例のxxcryptは以下のような定義だ。</p>

<code>xxcrypt n ed mc = mc ^ ed `mod` n</code>

<p>部分適用と関数合成で以下のように書き換えられる。</p>

<code>xxcrypt n ed = (`mod` n) . (^ ed)</code>

<p>「ed乗してnの剰余を取る」。</p>

<h3>型</h3>

<p>(.)の型はどうなるだろう。以下のような式を作る。</p>

<p><code>f . g</code></p>

<p>わかりやすさのために関数的な書きかたにする。</p>

<p><code>(.) f g</code></p>

<p>
g、fの順に適用するのでgの返り値とfの引数は同じ型だ。
gの型をa -&gt; bとしfの型をb -&gt; cとする。
結果としてできるf . gはgの引数を引数としfの返り値を返り値とする。
</p>

<p><code>f :: b -&gt; c<br/>
g :: a -&gt; b<br/>
f . g :: a -&gt; c</code></p>

<p>演算子(.)はf, gを引数としf . gを返り値とする。</p>

<p><code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code></p>

<h2>まとめ</h2>

<p>
いくつかの多相関数を見た。
多相関数は制御構造と考えられる。
独自の制御構造を単なる関数として作成することができる。
</p>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/type_driven.html"
	>「型駆動開発」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer/dist_tuple.html"
	>「タプル: 原点からの距離」へ</a>
</p>
