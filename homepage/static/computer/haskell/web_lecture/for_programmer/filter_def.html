関数filter, partition

<p>(工事中 0%)</p>

<p><a href="/computer/haskell/web_lecture/for_programmer/codes/filters.hs"
	>filters.hs</a></p>

<h2>関数filter</h2>

<h3>動作</h3>

<p>リストから条件を満たすものだけをとりだす。</p>

<p><code>% ghci<br/>
Prelude&gt; filter even [3, 8, 2, 4, 5, 9, 6, 7]<br/>
[8,2,4,6]<br/>
Prelude&gt; :m Data.Char<br/>
Prelude Data.Char&gt; filter isUpper "He And She Know Everyone Likes Lisp.\n"<br/>
"HASKELL"</code></p>

<h3>型</h3>

<p><code>filterRaw, filterF :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>

<p>
条件とリストをとり条件を満たす要素から成るリストを返す。
条件は真偽値を返す関数だ。
</p>

<h3>生の再帰</h3>

<p><code>filterRaw p (x : xs)<br/>
	<span class="indent1">| p x = x : filterRaw p xs</span><br/>
	<span class="indent1">| otherwise = filterRaw p xs</span><br/>
filterRaw _ _ = []</code></p>

<p>
xが条件を満たすとき残りの要素をろ過したリストにxを追加する。
そうでないなら残りの要素をろ過したリストをそのまま返す。
</p>

<h3>関数foldr</h3>

<p><code>filterF p = foldr (\x -&gt; if p x then (x :) else id) []</code></p>

<p>
xが条件を満たすなら第2引数にxを追加しそうでないならそのまま返す関数をfoldrに
与えている。
</p>

<h2>関数partition</h2>

<h3>動作</h3>

<p>リストを条件を満たすものと満たさないものにわける。</p>

<p><code>Prelude Data.Char&gt; :m + Data.List
Prelude Data.Char Data.List&gt; partition even [3, 8, 2, 4, 5, 9, 6, 7]<br/>
([8,2,4,6],[3,5,9,7])<br/>
Prelude Data.Char Data.List&gt; partition isUpper "He And She Know Everyone Likes Lisp.\n"<br/>
("HASKELL","e nd he now veryone ikes isp.\n")</code></p>

<h3>型</h3>

<p><code>partitionRaw, partitionF :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])</code></p>

<p>返り値は条件を満たすもののリストと満たさないもののリストのタプルとなる。</p>

<h3>生の再帰</h3>

<p><code>partitionRaw p (x : xs)<br/>
	<span class="indent1">| p x = (x : ts, es)</span><br/>
	<span class="indent1">| otherwise = (ts, x : es)</span><br/>
	<span class="indent1">where (ts, es) = partitionRaw p xs</span>
partitionRaw _ _ = ([], [])</code></p>

<p>ほげ</p>

<h3>関数foldr</h3>

<h2>まとめ</h2>

<p>
<a href="/computer/haskell/web_lecture/for_programmer/map_def.html"
	>「関数map」へもどる</a>
<a href="/computer/haskell/web_lecture/for_programmer"
	>「1から学ぶHaskell」トップへ</a>
</p>
