Lispっぽい表記: タプルのパース

<h2>何をするか?</h2>

<p>
まず、(,), (,,,)のような表記を使ってタプルを読み込むことができるようにする。
その後、そんなに難しくなければ(1, 2, 3)のような表記も読み込めるようにしよう。
</p>

<h2>(,), (,,,)のような値構築子の読み込み</h2>

<p><a href="/computer/haskell/extensions/quasiquotation/lisp/version_9/Parser.hs"
	>Parser.hs</a></p>

<pre><code>...
parseExp (OP : Comma : ts) = let
	(tpl, ts') = parseTupleCon ts in
	(conE . mkName $ "(," ++ tpl, ts')
...</code></pre>

<pre><code>parseTupleCon ::
	[Token] -&gt; (String, [Token])
parseTupleCon (CP : ts) = (")", ts)
parseTupleCon (Comma : ts) = let
	(tpl, ts') = parseTupleCon ts in
	(',' : tpl, ts')
parseTupleCon ts = error $
	"parseTupleCon: parse error: " ++
	show ts
</code></pre>

<h2>(1, 2, 3)のようなタプルの読み込み</h2>

<p>
これは'('が来て、次に式が来るというところまでは(fun arg1 arg2)という形と同じである。
よってバックトラックの必要性が生じる。
手抜きパーサなので、局所的にMaybeを使うことでバックトラックを実装することにする。
</p>

<h3>関数parseTupleExpを作成</h3>

<pre><code>parseTupleExp ::
	[Token] -&gt; ([ExpQ], [Token])
parseTupleExp ts = case parseExp ts of
	(e, CP : ts') -&gt; ([e], ts')
	(e, Comma : ts') -&gt; let
		(es, ts'') =
			parseTupleExp ts' in
		(e : es, ts'')
	_ -&gt; error $ "parseTupleExp: " ++
		"parse error: " ++ show ts</code></pre>

<h3>parseListへの変更</h3>

<p>
parseList関数がMaybe値を返すことによりバックトラック動作を実装する。
</p>

<pre><code>parseList ::
	[Token] -&gt; Maybe ([ExpQ], [Token])
parseList (Comma : _) = Nothing
parseList (CP : ts) = Just ([], ts)
parseList ts = let (e, ts') = parseExp ts in
	case parseList ts' of
		Just (es, ts'') -&gt;
			Just (e : es, ts'')
		_ -&gt; Nothing</code></pre>

<p>parseListを使っている部分を修正する。</p>

<pre><code>...
parseExp (OP : Lambda : OP : ts) = let
	(ps, ts') = parsePatList ts
	Just (es, ts'') = parseList ts' in
	(lamE ps $ last es, ts'')
...</code></pre>

<pre><code>...
parseDec (OP : Define : OP : Var v : ts) =
	let	(ps, ts') = parsePatList ts
		Just (es, ts'') =
			parseList ts' in
	(:)	&lt;$&gt; valD
			(varP $ mkName v)
			(normalB . lamE ps $
				last es)
			[]
		&lt;*&gt; parseDec ts''
...</code></pre>

<h3>関数parseListOrTupleの作成</h3>

<pre><code>parseListOrTuple :: [Token] -&gt;
	(Either [ExpQ] [ExpQ], [Token])
parseListOrTuple ts = maybe
	(first Right $ parseTupleExp ts)
	(first Left) $ parseList ts</code></pre>

<h3>関数parseExpでparseListOrTupleを使う</h3>

<pre><code>...
parseExp (OP : ts) = let
	(es, ts') = parseListOrTuple ts in
	(either (foldl1 appE) tupE es, ts')
...</code></pre>

<h2>(,), (,,,)のような構築子をパターンで使う</h2>

<p><a href="/computer/haskell/extensions/quasiquotation/lisp/version_10/Parser.hs"
	>Parser.hs</a></p>

<pre><code>...
parsePat (OP : OP : Comma : ts) = let
	(tpl, ts') = parseTupleCon ts
	(ps, ts'') = parsePatList ts' in
	(conP (mkName $ "(," ++ tpl) ps,
		ts'')
...</code></pre>

<h2>(a, b, c)のような形をパターンで使う</h2>

<p>
まずは<code>parsePat (OP : Con v : ts) = ...</code>を
parsePat (OP : ts) = parsePatOP tsのような形にする必要がある。
parsePatOPのなかではまず(Con v : ...)を試してNothingだった場合に、
タプル用のパーサを適用するといった感じ。
</p>

<h3>parsePatListがMaybe値を返すようにする</h3>

<pre><code>parsePatList ::
	[Token] -&gt; Maybe ([PatQ], [Token])
parsePatList (Comma : _) = Nothing
parsePatList (CP : ts) = Just ([], ts)
parsePatList ts = let
	(p, ts') = parsePat ts in
	first (p :) &lt;$&gt; parsePatList ts'</code></pre>

<h3>parsePatListの影響を受ける部分を修正</h3>

<pre><code>...
parseExp (OP : Lambda : OP : ts) = let
	Just (ps, ts') = parsePatList ts
	Just (es, ts'') = parseList ts' in
	(lamE ps $ last es, ts'')
...</code></pre>

<pre><code>...
parseDec (OP : Define : OP : Var v : ts) =
	let	Just (ps, ts') =
			parsePatList ts
		Just (es, ts'') =
			parseList ts' in
	(:)	&lt;$&gt; valD
			(varP $ mkName v)
			(normalB . lamE ps $
				last es)
			[]
		&lt;*&gt; parseDec ts''
...</code></pre>

<pre><code>...
parsePat (OP : OP : Comma : ts) = let
	(tpl, ts') = parseTupleCon ts
	Just (ps, ts'') =
		parsePatList ts' in
	(conP (mkName $ "(," ++ tpl) ps,
		ts'')
...</code></pre>

<h3>parsePatConを作成</h3>

<pre><code>parsePatCon ::
	[Token] -&gt; Maybe (PatQ, [Token])
parsePatCon (Con v : ts) = first
	(conP $ mkName v) &lt;$&gt;
	parsePatList ts
parsePatCon _ = Nothing</pre></code>

<h3>parseTuplePatを作成</h3>

<pre><code>parseTuplePat ::
	[Token] -&gt; ([PatQ], [Token])
parseTuplePat ts = case parsePat ts of
	(p, CP : ts') -&gt; ([p], ts')
	(p, Comma : ts') -&gt; first (p :) $
		parseTuplePat ts'
	_ -&gt; error $ "parseTuplePat: " ++
		"parse error: " ++ show ts</pre></code>

<h3>parsePatOPを作成</h3>

<pre><code>parsePatOP :: [Token] -&gt; (PatQ, [Token])
parsePatOP ts = fromMaybe
	(first tupP $ parseTuplePat ts) $
	parsePatCon ts</code></pre>

<h3>parsePatでparsePatOPを使用</h3>

<pre><code>...
parsePat (OP : ts) = parsePatOP ts
...</pre></code>

<h3>parsePatが引数無しの値構築子を解析</h3>

<pre><code>...
parsePat (Con v : ts) =
	(conP (mkName v) [], ts)
...</code></pre>

<h2>試してみる</h2>

<pre><code>% ghci useLispLike.hs
*Main&gt; :set -XQuasiQuotes
*Main&gt; [lisp| ((,,) "hoge" 88 ()) |]
("hoge",88,())
*Main&gt; [lisp| (123, 456, 789) |]
(123, 456, 789)
*Main&gt; [lisp| (fst ("hi", 25)) |]
"hi"
</code></pre>

<code>*Main&gt; let [lisp| ((,,) x y z) |] = ('c', True, ())<br/>
*Main&gt; y<br/>
True<br/>
*Main&gt; let [lisp| (Nothing, a, b) |] = (Nothing, "hello", False)<br/>
*Main&gt; a<br/>
"hello"</code>

<p>
<a href="/computer/haskell/extensions/quasiquotation/lisp/type2.html"
	>「型のパース(2)」へもどる</a>
<a href="/computer/haskell/extensions/quasiquotation/lisp/type3.html"
	>「型のパース(3)」へ</a>
</p>
