Lispっぽく表記: 代数的データ型の定義

<p>(工事中 60%)</p>

<h2>どのような表記にするか</h2>

<p>Haskellでは以下のような形になる。</p>

<pre><code>data Foo a = Bar | Baz Int | FooBar </code></pre>

<p>Lispっぽい表記では以下のようにすれば良い。</p>

<pre><code>(data (Foo a) Bar (Baz Int) FooBar)</code></pre>

<h3>deriving節</h3>

<p>
代数的データ型の定義にはderiving節が付く場合もある。
この場合の表記も考えてみよう。
以下のようにすれば良いと思う。
</p>

<pre><code>(deriving (data (Foo a) Bar (Baz Int) FooBar) Show Eq)</code></pre>

<h2>Lexer.hs</h2>

<p><a href="/computer/haskell/extensions/quasiquotation/lisp/version_15/Lexer.hs"
	>Lexer.hs</a></p>

<pre><code>data Token =
	...
	| Comma | Arrow | Type | Data | Deriving
	...</code></pre>

<pre><code>...
lexer ('d' : 'a' : 't' : 'a' : cs@(c : _))
	| not $ isAlphaNum c = Data : lexer cs
lexer ('d' : 'e' : 'r' : 'i' : 'v' : 'i' : 'n' : 'g' :
		cs@(c : _))
	| not $ isAlphaNum c = Deriving : lexer cs
...</code></pre>

<h2>Parser.hs: 代数的データ型の定義</h2>

<p><a href="/computer/haskell/extensions/quasiquotation/lisp/version_15/Parser.hs"
	>Parser.hs</a></p>

<h3>parseConstructor</h3>

<p>値構築子のパース。</p>

<pre><code>parseConstructor :: [Token] -&gt; (ConQ, [Token])
parseConstructor (Con v : ts) = (normalC (mkName v) [], ts)
parseConstructor (OP : Con v : ts) = let
	Just (tps, ts') = parseTypeList ts in
	(normalC (mkName v) $
		map (strictType notStrict) tps, ts')
parseConstructor ts = error $
	"parseConstructor: parse error: " ++ show ts</code></pre>

<h3>parseConstructors</h3>

<p>(作成中)</p>

<h3>parseVars</h3>

<p>(作成中)</p>

<h3>parseDataHead</h3>

<p>(作成中)</p>

<h3>parseDataDec</h3>

<p>(作成中)</p>

<h3>parseDataDecを使う</h3>

<p>(作成中)</p>

<h2>Parser.hs: deriving節の追加</h2>

<h3>parseCons</h3>

<p>(作成中)</p>

<h3>parseDecにderiving節を追加</h3>

<p>(作成中)</p>

<h2>試してみる</h2>

<p><a href="/computer/haskell/extensions/quasiquotation/lisp/version_15/useLispLike.hs"
	>useLispLike.hs</a></p>

<p>(作成中)</p>

<p>
<a href="/computer/haskell/extensions/quasiquotation/lisp/type_annotation.html"
	>「型注釈」へもどる</a>
<a href="/computer/haskell/extensions/quasiquotation/lisp"
	>「Lispっぽく表記」トップへ</a>
</p>
