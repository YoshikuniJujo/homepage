動的スコープと静的スコープ

<p>(工事中 0%)</p>

<h2>はじめに</h2>

<p>
環境の変化をIOを使わずに実現する。
基本的にはEnv型の値を引数としてとり返り値として返すということだ。
静的スコープを持つクロージャを実現するのにはどうしたら良いか。
それを考える必要がある。
</p>

<h2>動作</h2>

<ol>
<li>クロージャが定義されると
	<ul>
	<li>それをかこむ環境がそのクロージャに保存される</li>
	<li>その環境内の変数の値は変化する可能性がある</li>
	</ul></li>
<li>クロージャが呼び出されると
	<ul>
	<li>それが保存していた環境を現在の環境とする</li>
	<li>さらに引数や変数を含むローカルな環境が作られる</li>
	</ul></li>
</ol>

<h2>免責事項</h2>

<p>
SICPの範囲内で耐えられないくらいの時間がかかる例題がなければ
GCのことは考えない。
</p>

<h2>仕組み</h2>

<p>
クロージャの実行時に新しい環境が作られる。
それはIDをキーとした辞書に保存される。
クロージャはIDを保存し対応する環境内で変数を検索する。
それぞれのローカルな環境は上の環境を示すIDを持つ。
</p>

<h2>予想される問題</h2>

<p>
再帰的な関数ではクロージャの呼び出しの再帰が深くなる。
すると環境のIDのリストをたどりながら変数を検索する処理は、
ネストした環境の数nに対してO(n)となる。
末尾再帰関数については末尾再帰の最適化でなんとかなるが、
再帰的プロセスについては今の僕の知識ではどうしたらいいかわからない。
</p>

<h2>インターフェース</h2>

<p>
環境を代数的データ型としコンストラクタを公開しないようにする。
そして以下のインターフェースでのみアクセスするようにする。
</p>

<ul>
<li>fromList :: [(Symbol, Value)] -&gt; Env</li>
<li>insert :: Symbol -&gt; Value -&gt; Env -&gt; Env</li>
<li>set :: Symbol -&gt; Value -&gt; Env -&gt; Env</li>
<li>lookup :: Symbol -&gt; Env -&gt; Either Error Value</li>
<li>local :: Env -&gt; Env</li>
<li>exit :: Env -&gt; Either Error Env</li>
<li>getScope :: Env -&gt; Scope</li>
<li>setScope :: Scope -&gt; Env -&gt; Env</li>
</ul>

<p>
Scopeはローカルな環境を検索するIDである。
insertとsetとはinsertが現在のスコープに変数を定義するのに対して
setはその変数を含むスコープの変数を変化させる。
localは新しいスコープを作成しそのスコープにはいる。
exitは現在のスコープの外に出る。
getScopeは現在のスコープの取得でありsetScopeは現在のスコープを設定する。
</p>

<ol>
<li>クロージャを定義するときは
	<ul>
	<li>getEnvで取り出したスコープのIDをクロージャ内に保存する</li>
	</ul></li>
<li>クロージャを呼び出すときは
	<ul>
	<li>getEnvで現在のスコープを保存しておく</li>
	<li>setEnvで呼び出すクロージャのスコープ内にはいる</li>
	<li>localで新しいスコープを作成しそのなかにはいる</li>
	<li>クロージャを実行する</li>
	<li>setEnvでもとのスコープにもどる</li>
	</ul></li>
</ol>

<p>
こんな感じになるだろう。
</p>

<h2>インターフェースを合わせる</h2>

<p>
現在の動作と同じ動作のままEnvのインターフェースを合わせておく。
このようにしておくことで、
Envの内部を扱うモジュールのなかをいじることに集中できる。
</p>
