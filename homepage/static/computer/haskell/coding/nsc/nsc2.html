そんなに本気でない暗号化ソフト

<p>(<a href="/computer/haskell/coding/nsc"
>はじめに</a> <a href="/computer/haskell/coding/nsc/nsc1.html"
>その1</a> その2 <a href="/computer/haskell/coding/nsc/nsc3.html"
>その3</a> <a href="/computer/haskell/coding/nsc/nsc4.html">その4</a>)</p>

<ol>
<li><a href="#format">出力フォーマットを決定する</a> (工事中)</li>
<li><a href="#encrypt">暗号化関数</a> (工事中)</li>
<li><a href="#decrypt">復号関数</a> (工事中)</li>
<li><a href="#module">モジュールの作成</a> (工事中)</li>
<li><a href="#script">スクリプトの作成</a> (工事中)</li>
</ol>

<h2 id="format">出力フォーマットを決定する</h2>

<p>
必要な道具はそろったので出力フォーマットを決める。
以下のような条件を満たす仕様とする。
</p>

<ul>
<li>暗号化部分を含まない行は無視</li>
<li>行のなかでも暗号化部分より前の文字列は無視</li>
<li>暗号化部分の長さを指定しそれ以降の文字列は無視</li>
<li>それぞれの行を別々に暗号化、復号化できるようにする</li>
</ul>

<h3>一行のフォーマット</h3>

<p>
暗号化部分のはじまりを示すマーカーと暗号化部分の長さが必要となる。
以下のようなフォーマットとする。
</p>

<p>[マーカー] [バイト長] [Base64でエンコードされたデータ]</p>

<p>
[マーカー]は"[nsc]"とする。
[バイト長]は[]で囲った10進数とする。
</p>

<p>例: [nsc][8]aG9nZQ==</p>

<p>
[Base64でエンコードされたデータ]は以下のようなデータ構造を
エンコードしたものとする。
</p>

<p>[IV] [暗号化されたデータ]</p>

<h2 id="encrypt">暗号化関数</h2>

<h3>全体の流れ</h3>

<ol>
<li>パスワードからAESのキーを作成する</li>
<li>行単位に分割する</li>
<li>各行に対して以下を行う
	<ol>
	<li>ランダムなIVを取得する</li>
	<li>暗号化する</li>
	<li>IVと暗号化文字列を結合しBase64でエンコードする</li>
	<li>先頭に[nsc][バイト数]をつける</li>
	</ol></li>
<li>それぞれの行をひとつにまとめる</li>
</ol>

<h3>空行の扱い</h3>

<p>
空行だけは特別扱いにする。
たとえば[nsc][0]の固定にしてしまおう。
</p>

<h3>1行を扱う関数</h3>

<p>
引数はAESのキーとランダムの種と行の内容。
返り値は"[nsc][バイト数]"を付加したIVと暗号をBase64エンコードしたもの。
空行だったら"[nsc][0]"として固定する。
</p>

<pre><code>encrypt1 :: RandomGen g =&gt;
	AES -&gt; BS.ByteString -&gt; g -&gt; (BS.ByteString, g)
encrypt1 _ "" g = ("[nsc][0]", g)
encrypt1 k s g = let
	(iv, g') = randomIv k g
	cph = Base64.encode . (iv `BS.append`)
		$ encryptCBC k iv (padding (blockSize k) s) in
	("[nsc][" `BS.append` BSC.pack (show $ BS.length cph)
		`BS.append` "]" `BS.append` cph, g')</code></pre>

<p>試してみる。</p>

<pre><code>% ghci nsc.hs
*Main&gt; :set -XOverloadedStrings
*Main&gt; encrypt1 (mkAes "password") "hello" (mkStdGen 12)
("[nsc][44]q7RVfl49SvfMQJrkOuovJzVnpeM6XR5tcm+0ptx7hAg=",
1854610307 1554910725)
*Main&gt; getStdRandom $ encrypt1 (mkAes "password") "hello"
"[nsc][44]YFJLSLEN1C+hFWJWewZil7bBLUfiSTaM6TcWK3DOfn4="
</code></pre>

<h3>複数行を扱う関数</h3>

<p>monads-tfパッケージのStateモナドを使用するとスマート。</p>

<pre><code>encrypt :: RandomGen g =&gt;
	AES -&gt; BS.ByteString -&gt; g -&gt; (BS.ByteString, g)
encrypt k str = runState $ BSC.unlines &lt;$&gt; mapM
	(\s -&gt; StateT $ Identity . encrypt1 k s)
	(BSC.lines str)</code></pre>

<p>試してみる。</p>

<pre><code>% ghci nsc.hs
*Main&gt; :set -XOverloadedStrings
*Main&gt; encrypt (mkAes "password") "hello\nworld" (mkStdGen 12)
("[nsc][44]q7RVfl49SvfMQJrkOuovJzVnpeM6XR5tcm+0ptx7hAg=\n
[nsc][44]HFnaHPx5CMJvHSt003LVmKxceJGCXGjMmN39iAF7fZ8=\n",
2036434855 1827928504)
*Main&gt; getStdRandom $ encrypt (mkAes "password") "hello\nworld"
"[nsc][44]1TU+07rYthlz/aJcv+z7bjbc2x6sdtHdfOSPZotbGqI=\n
[nsc][44]sdrTZvBiU2ISQH8WTHPrJqWgyyQAkvs6+KV5p7Qh/bw=\n"
</code></pre>

<h2 id="decrypt">復号関数</h2>

<h3>全体の流れ</h3>

<ol>
<li>パスワードからAESのキーを作成する</li>
<li>プリプロセッサから[Base64でエンコードされたデータ]のリストを入手する</li>
<li>各行に対して以下を行う
	<ol>
	<li>Base64としてデコードする</li>
	<li>IVと暗号化部とに分ける
		<ul>
		<li>とりあえずIVは16バイトに決め打ち</li>
		</ul></li>
	<li>AESによる復号</li>
	</ol></li>
<li>それぞれの行をひとつにまとめる</li>
</ol>

<h3>プリプロセッサ</h3>

<p>
<a href="/computer/haskell/coding/nsc/nsc.hs">現在のコード</a>
</p>

<p>
参考: <a
href="https://hackage.haskell.org/package/bytestring-0.10.4.1/docs/Data-ByteString.html"
>Data.ByteString</a>
</p>

<p>
[nsc]を含む行だけを残し、また[nsc]以下の適切なバイト数だけを取り出す。
つまり[Base64でエンコードされたデータ]のみを取り出すということ。
より処理に近い書きかたをすれば、
「データを走査し[nsc]が出てきたらその次の[バイト数]を調べ、
そのバイト数ぶんだけのデータを読み込みリストに追加。
それをデータがなくなるまでくりかえす」となるだろう。
将来のことを考えれば\[nsc]は無視するというようにしておいたほうがベター。
でも今はまだいいか。
</p>

<p>
breakSubstring関数が使えそうだ。
</p>

<pre><code>breakSubString ::
	ByteString -&gt; ByteString -&gt; (ByteString, ByteString)</code></pre>

<p>プリプロセッサ関数decryptPPは以下のようになるだろう。</p>

<pre><code>breakNsc ::
	BS.ByteString -&gt; Maybe (BS.ByteString, BS.ByteString)
breakNsc s = case nt of
	| Just (n, t) &lt;- nt = Just $ BS.splitAt n t
	| otherwise = Nothing
	where
	nt = case BS.breakSubstring "[nsc][" s of
		(_, "") -&gt; Nothing
		(_, d) -&gt; Just $
			read . BSC.unpack *** BS.tail $
				BSC.span (/= ']') $ BS.drop 6 d
decryptPP :: BS.ByteString -&gt; [BS.ByteString]
decryptPP = unfoldr breakNsc</code></pre>

<small>
(*) ちなみにbreakNscは部分関数である。
問題はreadとBS.tailを使っているところにある。
本来ならそこらへんをきちんとチェックしてNothingを返すか、
または全体をIOでくくってちゃんとした例外を返してやるべきだ。
でも、とりあえずは「手抜き」しておく。
</small>

<h3>空行の扱い</h3>

<p>
空行は空の文字列となる。
よってIVを取り出そうとするとエラーが生じるので、
IVとそれ以下のデータに分ける際に空行をチェックしてやる必要がある。
</p>

<h3>復号関数</h3>

<pre><code>decrypt1 :: AES -&gt; BS.ByteString -&gt; Maybe BS.ByteString
decrypt1 _ "" = Just ""
decrypt1 k l = case Base64.decode l of
	Right d -&gt; let (iv, cpd) = BS.splitAt 16 d in
		Just . unpadding $ decryptCBC k iv cpd
	_ -&gt; Nothing</code></pre>

<pre><code>decrypt :: AES -&gt; BS.ByteString -&gt; BS.ByteString
decrypt k = unlines . map (decrypt1 k) . decryptPP</code></pre>

<h2 id="module">モジュールの出来上がり</h2>

<p>試行錯誤で出来上がったファイルをモジュールにしてしまおう。</p>

<pre><code>% cp nsc.hs Nsc.hs
% vi <a href="/computer/haskell/coding/nsc/Nsc.hs">Nsc.hs</a>
(module Nsc (encrypt, decrypt) whereを追加する)
% ghci -Wall Nsc.hs
*Nsc&gt; :set -XOverloadedStrings
*Nsc&gt; let k = makeKey "password"
*Nsc&gt; getStdRandom $ encrypt k "hello\nworld"
"[nsc][44]V7+wezE0rb+HwN8j7DQ8ZApWPMJdE/0hVsUD6YGgHfY=\n
[nsc][44]zcao93KGJCSeCypXISt20gurmozVUZlhKLWt9QM7u1M=\n"
*Nsc&gt; decrypt k it
Just "hello\nworld\n"
</code></pre>

<h2 id="script">実行可能ファイルを作成する</h2>

<p>UNIXの伝統に則ってフィルタとして作ることにする。</p>

<h2>暗号化スクリプト</h2>

<pre><code>% cat <a href="/computer/haskell/coding/nsc/encrypt.hs">encrypt.hs</a>
import System.Environment

import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as BSC

import Nsc

main :: IO ()
main = do
	ps : _ &lt;- getArgs
	BS.getContents
		&gt;&gt;= getStdRandom . encrypt (makeKey ps)
		&gt;&gt;= BS.putStr</code></pre>

<h2>復号スクリプト</h2>

<pre><code>% cat <a href="/computer/haskell/coding/nsc/decrypt.hs">decrypt.hs</a>
{-# LANGUAGE OverloadedStrings #-}

import Data.Maybe
import System.Environment

import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as BSC

import Nsc

main :: IO ()
main = do
	ps : _ &lt;- getArgs
	BS.interact . (fromMaybe "" .)
		. decrypt . makeKey $ BSC.pack ps</code></pre>

<h2>試してみる</h2>

<pre><code>% echo "hello\n\nworld" | runhaskell encrypt.hs password
[nsc][44]4uHh/lKbNV0PbctzgsVw9+bXnwdRfB4afzzGOFNDfPU=
[nsc][0]
[nsc][44]VQtj2/VqzyvKWV+iyKxZST40M5L+sV+6kJA1J2TkL+M=
% echo "hello\n\nworld" | runhaskell encrypt.hs password | \
runhaskell decrypt.hs password
hello

world</code></pre>

<p>
(作成中)
</p>

<p>
<a href="/computer/haskell/coding/nsc/nsc1.html">その1へ</a>
<a href="/computer/haskell/coding/nsc/nsc3.html">その3へ</a>
</p>
