Haskellとは

<ul>
<li><a href="#features">特徴</a></li>
<li><a href="#history">歴史</a></li>
</ul>

<h2 id="features">特徴</h2>

Haskellには以下の特徴がある。

<ul>
<li><a href="#first_class">第一級関数</a></li>
<li><a href="#ref_trans">参照透過</a></li>
<li><a href="#lazy">遅延性</a></li>
<li><a href="#static_typing">静的型付</a></li>
</ul>

<h3 id="first_class">第一級関数</h3>

<p>Haskellでは関数は第一級オブジェクトである。つまり以下の性質を満たす。</p>

<ul>
<li>リテラルとして表現可能</li>
<li>変数に格納可能</li>
<li>データ構造に格納可能</li>
<li>関数の引数にすることができる</li>
<li>関数の返り値にすることができる</li>
</ul>

<p>
このように関数が普通の値と同様に扱えることで、抽象度の高い表現が可能となる。
それにより、コードの二重化を回避し、簡潔にすることができる。
</p>

<h3 id="ref_trans">参照透過</h3>

<p>
関数に同じ引数を与えれば、いつでも同じ値が返ってくる。
これを参照透過と呼ぶ。
言い換えるとHaskellでは内部的な「状態」が存在しないということになる。
入出力というものは本質的に参照透過性とは相入れない。
Haskellでは参照透過性と入出力とを、妥協なく、共存させるためにIOモナドという仕組みが
使われている。
</p>

<h3 id="lazy">遅延性</h3>

<p>
Haskellでは関数の評価には遅延評価が使われている。
また、データ構造の評価にも遅延性がある。
これらの遅延性によりアルゴリズムに「本質的」な部分と、
「非本質的」な終了条件とを分離することができる。
</p>

<p>
たとえば小さいほうから100個の素数を求めるといった場合に、
100という数は非本質的な部分である。
このような場合、Haskellのように遅延性を持つ言語であれば、
まずは素数すべてのリストを作成し、そこから100個を取り出すという形で、
コードを組むことができる。
</p>

<h3 id="static_typing">静的型付</h3>

<p>
Haskellではコンパイル時に型が決定する「静的型付」が採用されている。
</p>

<p>
動的型付の利点としてもともとの意図を越えた使いかたがされるという
「偶然の協力」というものがある。
しかし、これは逆に言うとコードを使用する場合に、
その使いかたを限定することができず、
常にどこかしらに落とし穴が存在する可能性があるということだ。
</p>

<p>
静的型付ではそれとは対照的に「偶然の協力」というものはあり得ないが、
その代わりにその関数の正しさを完全に証明することができる。
また、柔軟性の範囲を厳密に決めることで「厳密な柔軟性」を実現することができる。
「型変数」や「型クラス」という仕組みは強力な道具となる。
</p>

<h2 id="history">歴史</h2>

<p>
1980年代に遅延評価する純粋関数型言語が乱立するなかで、
オープンな標準の作成が必要との合意のもと、
そのための委員会が発足した。
</p>

<p>
1990年にHaskell 1.0が作成され、それに続き、
1999年には基本ライブラリなどの定義も含むHaskell 98言語標準が発表された。
その後、いくつかの修正や拡張が行われHaskell 2010が公開された。
</p>

<p>
参考: 
<a href="http://ja.wikipedia.org/wiki/Haskell#.E6.AD.B4.E5.8F.B2">
wikipedia: Haskellの歴史</a>
</p>
