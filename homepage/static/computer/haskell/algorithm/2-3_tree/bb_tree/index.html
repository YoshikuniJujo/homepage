BB木

<p>(工事中 0%)</p>

<h2>はじめに</h2>

<p>
内容を切りわけて順に学ぶためにはじめに単相型(Int型とする)の集合を作成する。
その後多相型の集合を作成するがそのためには型族(Type Families)という言語拡張が
必要となる。
</p>

<h2>BB木(Binary B-tree)とは</h2>

<p>
B木のオーダーを3にしたものだ。B木の説明はここではしない。BB木の説明を続ける。
</p>

<h3>2分探索の効率</h3>

<p>
かたよった2分木ではそのかたよりが大きくなればなるほど探索の効率は低下しO(n)に
近づいていく。
均衡がとれた木ほど探索の効率は良くなる。
</p>

<h3>2分木</h3>

<p>どの分岐も高さが等しい2分木を考えてみよう。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/bst_15.svg"
	alt="[高さ4の完全に均衡のとれた2分木]" /></p>

<p>
このような木であると高さをnとすると2 ^ n - 1個の要素を持つ木しか作れない。
つまり1, 3, 7, 15, 31, 63 ...個の要素を持つ集合しか表現できないことになる。
どの枝も高さが等しいことが保証された木でそれ以外の個数の要素を持つ集合を表現する
にはどうしたらいいだろうか。
</p>

<h3>2-3木</h3>

<p>
ここでは「高さが等しい」という条件は変えたくないので枝分かれのしかたを変える。
「すべてのノードは2個の子を持つ」という条件を
「すべてのノードは2個または3個の子を持つ」という条件に変えてみよう。
0個や1個の子は許さない。
子が0個や1個のノードが増えるとその木を使った探索は線形探索に近づいていくからだ。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/bbtree.svg"
	alt="[2-3木の例]" /></p>

<p>
分岐が2のときにノードはひとつの要素を持つ。
その要素と比較して小さいものを左の木に、大きいものを右の木に持つ。
分岐が3のときにノードはふたつの要素を持つ。
小さいほうの要素より小さいものを左の木に、
ふたつの要素のあいだとなるものをまん中の木に、
大きいほうの要素より大きいものを右の木に持つ。
また図では省略したが末端の値の下にも本当は枝がのびていて
高さ0の木がそれぞれぶらさがっている。
</p>

<h2>検索</h2>

<p>
検索は2分探索木とほとんど同じだ。
検索する値とノードの要素の大小関係によって進む枝を選べばいい。
</p>

<h2>追加</h2>

<h3>末端への追加</h3>

<p>
検索と同様の手順で値を追加するところを決める。
末端の値は空の木をぶらさげていることを考慮すると末端に値を追加するということは
高さ0の木を高さ1の木に変換するということだ。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNull.svg"
	alt="[空の木に値を追加する図]" /></p>

<p>
末端の木への要素への追加には対称性を考えると3通りの可能性がある。
(1)値がひとつの末端への追加、(2)値がふたつの末端の左への追加、
(3)値がふたつの末端の中央への追加だ。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToBottom1.svg"
	alt="[値がひとつの末端への追加]" /></p>

<p>
値がひとつの末端の左側に新しい値を追加すると上の図のようになる。
高さ0の木(空の木:N)が高さ1の木に変換される。
この不均衡な2分木を3分木にすることで均衡を回復する。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenBottom1.svg"
	alt="[値がひとつの末端の均衡回復]" /></p>

<p>
つぎにすでに値がふたつある末端への値の追加だ。
まずは(2)の左への追加だ。
値がふたつある末端の左に値を追加すると以下のようになる。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToBottom2.svg"
	alt="[値がふたつの末端の左への追加]" /></p>

<p>木の高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenBottom2.svg"
	alt="[値がふたつの末端の左への追加後の高さをそろえる]" /></p>

<p>
3つの値を含み4つの空の木を持つ4分岐の木となる。
BB木では4分岐は許されていないので木の高さを1段高くする。
上図の緑の値を上に持ち上げれば良い。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupBottom2.svg"
	alt="[値がふたつの末端の左への追加後に木を高くする]" /></p>

<p>
次に(3)の2つの値を含む末端の中間への値の追加を見ていこう。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToBottom3.svg"
	alt="[値がふたつの末端の中央への追加]" /></p>

<p>
木の高さをそろえる。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenBottom3.svg"
	alt="[値がふたつの末端の中央への追加後の高さをそろえる]" /></p>

<p>木を一段高くする。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupBottom3.svg"
	alt="[値がふたつの末端の中央への追加後に木を高くする]" /></p>

<p>
見てきたように末端への値の追加は末端の木を2分岐から3分岐にするか、
または木の高さを1から2にするという結果となる。
</p>

<h3>上に向かって木を変形していく</h3>

<p>
末端において木の高さが1のままであれば単にその部分をおきかえるだけですむ。
木の高さが高くなったときには変形は上向きに連鎖していく。
末端で見たのと同じ変換が次々に上へと向かっていく。
</p>

<p>
(1) 変形されるノードが値ひとつ(2分岐のノード)のときを考える。
</p>

<p>左の子ノードが1段高くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNode1.svg"
	alt="[値がひとつのノードの左が高くなる]" /></p>

<p>高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenNode1.svg"
	alt="[値がひとつのノードの左が高くなったのを平坦化]" /></p>

<p>この場合、変形はこのレベルで終わる。</p>

<p>
(2) 変形されるノードが値ふたつ(3分岐のノード)で左の木が高くなるときを考える。
</p>

<p>3分岐のノードの左の子が高くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNode2.svg"
	alt="[値がふたつのノードの左が高くなる]" /></p>

<p>木の高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenNode2.svg"
	alt="[値がふたつのノードの左が高くなったのを平坦化の図]" /></p>

<p>木を1段高くする。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupNode2.svg"
	alt="[値がふたつのノードの左が高くなった結果全体が高くなるの図]" /></p>

<p>
木が高くなったのでさらに上のレベルへと変形が連鎖していく。
</p>

<p>
(3) 変形されるノードが値ふたつ(3分岐のノード)で中央の木が高くなるときを考える。
</p>

<p>3分岐のノードの中央の子が高くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNode3.svg"
	alt="[値がふたつのノードの中央が高くなるの図]" /></p>

<p>高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenNode3.svg"
	alt="[値がふたつのノードの中央が高くなったのを平坦化の図]" /></p>

<p>1段高くする。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupNode3.svg"
	alt="[値がふたつのノードの中央が高くなった結果全体が高くなるの図]" /></p>

<p>木が高くなったので上のレベルへと連鎖していく。</p>

<p>
木が高くなっていく連鎖が根まで到達すると木全体が1段高くなる。
</p>

<h3>末端と途中のノードへの操作</h3>

<p>
末端のノードへの操作と途中のノードへの操作とは実は同じである。
次の「削除」の説明ではわけずに説明する。
</p>

<h2>削除</h2>

<h3>概要</h3>

<p>
途中のノードの値の削除は左の子に含まれる値の最大値(必ず末端となる)と交換した
うえで末端から削除していく。
削除は木の高さの低下を上方向に連鎖していくことで実現できる。
木の高さの低下を上方向に伝播させるまえに木の回転によって隣りのノードから
値と子要素を融通してもらえるかチェックする必要がある。
</p>

<p>
木の高さの低下が上に伝播する場合には上のレベルの値が下のレベルに下りる。
</p>

<h3>末端の要素の削除</h3>

<h4>隣りから融通</h4>

<p>
木が低くなったときに隣りのノードから値と子となる木を融通してもらえるかを調べる。
隣りのノードに値があまっていれば木の回転によって低くなった木をうめあわせる。
左の木が低くなる前の状態を示す。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromNeighbor0.svg"
	alt="[隣りから融通の最初の状態の図]" /></p>

<p>左の木が低くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromNeighbor1.svg"
	alt="[隣りから融通の左の木が低くなった状態の図]" /></p>

<p>「木の回転」によって右から値と子となる木を融通する。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromNeighbor2.svg"
	alt="[隣りから融通されたあとの図]" /></p>

<p>
このとき木の高さはかわらないので高さを低くしていく連鎖はここで終わる。
</p>

<h4>木を低くする</h4>

<p>
隣りに値や子となる木があまっていないときには木を低くする必要がある。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromUpper0.svg"
	alt="[上から融通の最初の状態の図]" /></p>

<p>左の木が1段低くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromUpper1.svg"
	alt="[上から融通の左の木が1段低くなった状態の図]" /></p>

<p>上の値を下に下げることで下のノードをまとめる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromUpper2.svg"
	alt="[上から融通された状態の図]" /></p>

<p>木が1段低くなったので木の変形が上へ伝播していく。</p>

<h3>途中の要素の削除</h3>

<p>
途中のノードの要素を削除するのは末端の要素と入れかえたうえで
末端からその要素を削除していくのと同じことだ。
手順は以下のようになる。
</p>

<ol>
<li>左の子から最大値をとりだす</li>
<li>とりだした値で削除する値をおきかえる</li>
<li>左の子の高さが変化しなければそのまま</li>
<li>左の子が低くなったら隣りの木か上から値を融通する</li>
<li>上から融通したときには変形を上へ伝播させる</li>
</ol>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromLeaf0.svg"
	alt="[葉から融通の最初の状態の図]" /></p>

<p>
左の子から最大値をとりだす。
これは検索と削除の処理を同時に行うようなものだ。
そのとき左の子の高さが変化しないときと1段低くなるときとがある。
</p>

<p>
<img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromLeaf1.svg"
	alt="[葉から融通の左の子の高さが変化しない状態の図]" />
<img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromLeaf2.svg"
	alt="[葉から融通の左の子が1段低くなる状態の図]" />
</p>

<p>とりだした値で削除する値をおきかえる。</p>

<p>
<img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromLeaf3.svg"
	alt="[葉から融通の左の子の高さ変わらず値のおきかえ後の状態の図]" />
<img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromLeaf4.svg"
	alt="[葉から融通の左の子が1段低くなり値のおきかえ後の状態の図]" />
</p>

<p>
左の子の高さに変化のないものについては操作は終了だ。
左の子の高さが低くなったものは隣や上からの融通の操作を続ける。
</p>

<h2>単相的な集合</h2>

<p><a href="/computer/haskell/algorithm/2-3_tree/bb_tree/codes/SetBM.hs"
	>SetBM.hs</a></p>

<h3>変数名の規則</h3>

<p>値や木の変数名をその位置によって統一的な変数名で示すことにする。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/var22.svg"
	alt="[2-2の変数名規則の図]" /></p>

<p>
2分岐のときのトップレベルの要素をdとし左右の木をそれぞれl, rとする。
左の木が2分岐ならばその要素はaとし左右の木をそれぞれk, mとする。
右の木も同様に2分岐ならばその要素をgとし左右の木をq, sとする。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/var23.svg"
	alt="[2-3の変数名規則の図]" /></p>

<p>
左の木が3分岐のときその要素をa, bとし子どもの木をk, l', mとする。
右の木についても3分岐のときには要素をg, hとし子どもの木をq, r', sとする。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/var32.svg"
	alt="[3-2の変数名規則の図]" /></p>

<p>
上のレベルの木が3分岐のときその要素をc, fとする。
真ん中の木をoとし、2分岐であれば要素をdとし子どもの木をn, pとする。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/var33.svg"
	alt="[3-3の変数名規則の図]" /></p>

<p>
前ん中の木が3分岐であれば要素をd, eとし子どもの木をn, o', pとする。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/varChanged.svg"
	alt="[変更前後の変数名の図]" /></p>

<p>
上記の規則とは別に木l, o, rが変化したとき変化後の値をl', o', r'とする。
</p>

<h3>モジュール宣言など</h3>

<p><code>{-# LANGUAGE TupleSections #-}</code></p>

<p>(a ,)のようなタプルの部分適用が可能になる。</p>

<p><code>module SetBM (Set, empty, member, insert, delete) where</code></p>

<p>集合の型、空集合、検索、追加、削除を公開する。</p>

<h3>型の定義</h3>

<p><code>type Set = Tree ()</code></p>

<p><code>data Tree a = Zero a | Succ (Tree (Node a)) deriving Show<br/>
data Node a = Nd2 a Int a | Nd3 a Int a Int a deriving Show</code></p>

<p>
まずは単相的な型の集合とする。
要素はInt型のみを扱うことにする。
構築子Succを適用するごとにNodeが入れ子になっていく。
高さの異なる木を同じTree型とすることができるがそれぞれの木のなかでは
どの枝も同じ高さとなることが保証される。
</p>

<p>[あとでここに具体例と詳しい説明を置く]</p>

<h3>空集合</h3>

<p><code>empty :: Tree ()<br/>
empty = Zero ()</code></p>

<p>
空集合は高さ0の木である。
</p>

<h3>型クラス</h3>

<p><code>class IsNode a where<br/>
	<span class="indent1">memberN :: Int -&gt; a -&gt; Bool</span><br/>
	<span class="indent1">insertN :: Int -&gt; a -&gt; Either a (a, Int, a)</span><br/>
	<span class="indent1">deleteN :: Int -&gt; Node a -&gt; Either (Node a) a</span><br/>
	<span class="indent1">popMaxN :: Node a -&gt; (Int, Either (Node a) a)</span><br/>
	</code></p>

<p>
Node (Node (Node ...))のような型に対する演算が必要となる。
不定数の型構築子Nodeがネストする型に対する演算は普通の関数では表現できない。
よってaがIsNodeクラスのインスタンスであるという前提でNode aに対する演算を定義する
という方法をとる。
memberNは値の検索である。
</p>

<p>
insertNは値の追加である。
結果として高さが変わらないときと高くなるときとがある。
高くなるときは必ず2分岐でありかつより上に変形が伝播したときに分解されることが
あるのではじめから分解された形で返すことにした。
</p>

<p>
deleteNは値の削除である。
結果として木の高さが変わらないかまたはあるいは低くなる。
</p>

<p>
popMaxNは最大値とそれを削除した木を返す。
木は低くなるときもある。
これはdeleteNが途中のノードから値を削除するときに使われる。
</p>

<h3>ユニット型はNodeである</h3>

<p>ユニット型を空の木として枝の先端として使う。</p>

<p><code>class IsNode a where<br/>
	<span class="indent1">memberN _ _ = False</span><br/>
	<span class="indent1">insertN v _ = Right ((), v, ())</span><br/>
	<span class="indent1">deleteN v t@(Nd2 _ d _)</span><br/>
		<span class="indent2">| v == d = Right ()</span><br/>
		<span class="indent2">| otherwise = Left t</span><br/>
	<span class="indent1">deleteN v t@(Nd3 _ c _ f _)</span><br/>
		<span class="indent2">| v == c = Left $ Nd2 () f ()</span><br/>
		<span class="indent2">| v == f = Left $ Nd2 () c ()</span><br/>
		<span class="indent2">| otherwise = Left t</span><br/>
	<span class="indent1">popMaxN (Nd2 _ d _) = (d, Right ())</span><br/>
	<span class="indent1">popMaxN (Nd3 _ c _ f _) = (f, Left $ Nd2 () c ())</span>
	</code></p>

<p>
空集合は何を検索してもFalseとなる。
空の木に値を追加すると必ず木は高く(0から1)なり左右に空の木を持つ木となる。
値の削除は存在しない値を削除しようとするともとの木を返すことにする。
実際に削除が行われるときには2分岐の木だと木の高さは低く(1から0)となる。
3分岐の木であれば2分岐の木となり高さは変わらない。
最大値のとりだしも削除と似たようなものだ。
</p>

<p>[ここから書き始めること]</p>

<p>[コードの解説n]は実際の内容を考えながらちゃんとしたタイトルにつけかえる。</p>

<h3>[コードの解説2]</h3>

<h3>[コードの解説3]</h3>

<h2>多相型版</h2>

<p><a href="/computer/haskell/algorithm/2-3_tree/bb_tree/codes/SetB.hs"
	>SetB.hs</a></p>
