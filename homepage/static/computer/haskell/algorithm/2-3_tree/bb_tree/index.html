BB木

<p>(工事中 0%)</p>

<p>
<a href="/computer/haskell/algorithm/2-3_tree/bb_tree/codes/SetBM.hs"
	>SetBM.hs</a>
<a href="/computer/haskell/algorithm/2-3_tree/bb_tree/codes/SetB.hs"
	>SetB.hs</a>
</p>

<h2>はじめに</h2>

<p>
内容を切りわけて順に学ぶためにはじめに単相型(Int型とする)の集合を作成する。
その後多相型の集合を作成するがそのためには型族(Type Families)という言語拡張が
必要となる。
</p>

<h2>BB木(Binary B-tree)とは</h2>

<p>
B木のオーダーを3にしたものだ。B木の説明はここではしない。BB木の説明を続ける。
</p>

<h3>2分探索の効率</h3>

<p>
かたよった2分木ではそのかたよりが大きくなればなるほど探索の効率は低下しO(n)に
近づいていく。
均衡がとれた木ほど探索の効率は良くなる。
</p>

<h3>2分木</h3>

<p>どの分岐も高さが等しい2分木を考えてみよう。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/bst_15.svg"
	alt="[高さ4の完全に均衡のとれた2分木]" /></p>

<p>
このような木であると高さをnとすると2 ^ n - 1個の要素を持つ木しか作れない。
つまり1, 3, 7, 15, 31, 63 ...個の要素を持つ集合しか表現できないことになる。
どの枝も高さが等しいことが保証された木でそれ以外の個数の要素を持つ集合を表現する
にはどうしたらいいだろうか。
</p>

<h3>2-3木</h3>

<p>
ここでは「高さが等しい」という条件は変えたくないので枝分かれのしかたを変える。
「すべてのノードは2個の子を持つ」という条件を
「すべてのノードは2個または3個の子を持つ」という条件に変えてみよう。
0個や1個の子は許さない。
子が0個や1個のノードが増えるとその木を使った探索は線形探索に近づいていくからだ。
</p>

<p>[ここに2-3木の例を置く]</p>

<h3>要素はノードに置く</h3>

<h2>多相型版</h2>
