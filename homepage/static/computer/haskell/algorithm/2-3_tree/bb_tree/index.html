BB木

<p>(工事中 0%)</p>

<p>
<a href="/computer/haskell/algorithm/2-3_tree/bb_tree/codes/SetBM.hs"
	>SetBM.hs</a>
<a href="/computer/haskell/algorithm/2-3_tree/bb_tree/codes/SetB.hs"
	>SetB.hs</a>
</p>

<h2>はじめに</h2>

<p>
内容を切りわけて順に学ぶためにはじめに単相型(Int型とする)の集合を作成する。
その後多相型の集合を作成するがそのためには型族(Type Families)という言語拡張が
必要となる。
</p>

<h2>BB木(Binary B-tree)とは</h2>

<p>
B木のオーダーを3にしたものだ。B木の説明はここではしない。BB木の説明を続ける。
</p>

<h3>2分探索の効率</h3>

<p>
かたよった2分木ではそのかたよりが大きくなればなるほど探索の効率は低下しO(n)に
近づいていく。
均衡がとれた木ほど探索の効率は良くなる。
</p>

<h3>2分木</h3>

<p>どの分岐も高さが等しい2分木を考えてみよう。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/bst_15.svg"
	alt="[高さ4の完全に均衡のとれた2分木]" /></p>

<p>
このような木であると高さをnとすると2 ^ n - 1個の要素を持つ木しか作れない。
つまり1, 3, 7, 15, 31, 63 ...個の要素を持つ集合しか表現できないことになる。
どの枝も高さが等しいことが保証された木でそれ以外の個数の要素を持つ集合を表現する
にはどうしたらいいだろうか。
</p>

<h3>2-3木</h3>

<p>
ここでは「高さが等しい」という条件は変えたくないので枝分かれのしかたを変える。
「すべてのノードは2個の子を持つ」という条件を
「すべてのノードは2個または3個の子を持つ」という条件に変えてみよう。
0個や1個の子は許さない。
子が0個や1個のノードが増えるとその木を使った探索は線形探索に近づいていくからだ。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/bbtree.svg"
	alt="[2-3木の例]" /></p>

<p>
分岐が2のときにノードはひとつの要素を持つ。
その要素と比較して小さいものを左の木に、大きいものを右の木に持つ。
分岐が3のときにノードはふたつの要素を持つ。
小さいほうの要素より小さいものを左の木に、
ふたつの要素のあいだとなるものをまん中の木に、
大きいほうの要素より大きいものを右の木に持つ。
また図では省略したが末端の値の下にも本当は枝がのびていて
高さ0の木がそれぞれぶらさがっている。
</p>

<h3>検索</h3>

<p>
検索は2分探索木とほとんど同じだ。
検索する値とノードの要素の大小関係によって進む枝を選べばいい。
</p>

<h3>追加</h3>

<h4>末端への追加</h4>

<p>
検索と同様の手順で値を追加するところを決める。
末端の値は空の木をぶらさげていることを考慮すると末端に値を追加するということは
高さ0の木を高さ1の木に変換するということだ。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNull.svg"
	alt="[空の木に値を追加する図]" /></p>

<p>
末端の木への要素への追加には対称性を考えると3通りの可能性がある。
(1)値がひとつの末端への追加、(2)値がふたつの末端の左への追加、
(3)値がふたつの末端の中央への追加だ。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToBottom1.svg"
	alt="[値がひとつの末端への追加]" /></p>

<p>
値がひとつの末端の左側に新しい値を追加すると上の図のようになる。
高さ0の木(空の木:N)が高さ1の木に変換される。
この不均衡な2分木を3分木にすることで均衡を回復する。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenBottom1.svg"
	alt="[値がひとつの末端の均衡回復]" /></p>

<p>
つぎにすでに値がふたつある末端への値の追加だ。
まずは(2)の左への追加だ。
値がふたつある末端の左に値を追加すると以下のようになる。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToBottom2.svg"
	alt="[値がふたつの末端の左への追加]" /></p>

<p>木の高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenBottom2.svg"
	alt="[値がふたつの末端の左への追加後の高さをそろえる]" /></p>

<p>
3つの値を含み4つの空の木を持つ4分岐の木となる。
BB木では4分岐は許されていないので木の高さを1段高くする。
上図の緑の値を上に持ち上げれば良い。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupBottom2.svg"
	alt="[値がふたつの末端の左への追加後に木を高くする]" /></p>

<p>
次に(3)の2つの値を含む末端の中間への値の追加を見ていこう。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToBottom3.svg"
	alt="[値がふたつの末端の中央への追加]" /></p>

<p>
木の高さをそろえる。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenBottom3.svg"
	alt="[値がふたつの末端の中央への追加後の高さをそろえる]" /></p>

<p>木を一段高くする。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupBottom3.svg"
	alt="[値がふたつの末端の中央への追加後に木を高くする]" /></p>

<p>
見てきたように末端への値の追加は末端の木を2分岐から3分岐にするか、
または木の高さを1から2にするという結果となる。
</p>

<h4>上に向かって木を変形していく</h4>

<p>
末端において木の高さが1のままであれば単にその部分をおきかえるだけですむ。
木の高さが高くなったときには変形は上向きに連鎖していく。
末端で見たのと同じ変換が次々に上へと向かっていく。
</p>

<p>
(1) 変形されるノードが値ひとつ(2分岐のノード)のときを考える。
</p>

<p>左の子ノードが1段高くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNode1.svg"
	alt="[値がひとつのノードの左が高くなる]" /></p>

<p>高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenNode1.svg"
	alt="[値がひとつのノードの左が高くなったのを平坦化]" /></p>

<p>この場合、変形はこのレベルで終わる。</p>

<p>
(2) 変形されるノードが値ふたつ(3分岐のノード)で左の木が高くなるときを考える。
</p>

<p>3分岐のノードの左の子が高くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNode2.svg"
	alt="[値がふたつのノードの左が高くなる]" /></p>

<p>木の高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenNode2.svg"
	alt="[値がふたつのノードの左が高くなったのを平坦化の図]" /></p>

<p>木を1段高くする。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupNode2.svg"
	alt="[値がふたつのノードの左が高くなった結果全体が高くなるの図]" /></p>

<p>
木が高くなったのでさらに上のレベルへと変形が連鎖していく。
</p>

<p>
(3) 変形されるノードが値ふたつ(3分岐のノード)で中央の木が高くなるときを考える。
</p>

<p>3分岐のノードの中央の子が高くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNode3.svg"
	alt="[値がふたつのノードの中央が高くなるの図]" /></p>

<p>高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenNode3.svg"
	alt="[値がふたつのノードの中央が高くなったのを平坦化の図]" /></p>

<p>1段高くする。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupNode3.svg"
	alt="[値がふたつのノードの中央が高くなった結果全体が高くなるの図]" /></p>

<p>木が高くなったので上のレベルへと連鎖していく。</p>

<p>
木が高くなっていく連鎖が根まで到達すると木全体が1段高くなる。
</p>

<h3>削除</h3>

<h3>多相型版</h3>
