BB木

<p>(工事中 0%)</p>

<p>
<a href="/computer/haskell/algorithm/2-3_tree/bb_tree/codes/SetBM.hs"
	>SetBM.hs</a>
<a href="/computer/haskell/algorithm/2-3_tree/bb_tree/codes/SetB.hs"
	>SetB.hs</a>
</p>

<h2>はじめに</h2>

<p>
内容を切りわけて順に学ぶためにはじめに単相型(Int型とする)の集合を作成する。
その後多相型の集合を作成するがそのためには型族(Type Families)という言語拡張が
必要となる。
</p>

<h2>BB木(Binary B-tree)とは</h2>

<p>
B木のオーダーを3にしたものだ。B木の説明はここではしない。BB木の説明を続ける。
</p>

<h3>2分探索の効率</h3>

<p>
かたよった2分木ではそのかたよりが大きくなればなるほど探索の効率は低下しO(n)に
近づいていく。
均衡がとれた木ほど探索の効率は良くなる。
</p>

<h3>2分木</h3>

<p>どの分岐も高さが等しい2分木を考えてみよう。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/bst_15.svg"
	alt="[高さ4の完全に均衡のとれた2分木]" /></p>

<p>
このような木であると高さをnとすると2 ^ n - 1個の要素を持つ木しか作れない。
つまり1, 3, 7, 15, 31, 63 ...個の要素を持つ集合しか表現できないことになる。
どの枝も高さが等しいことが保証された木でそれ以外の個数の要素を持つ集合を表現する
にはどうしたらいいだろうか。
</p>

<h3>2-3木</h3>

<p>
ここでは「高さが等しい」という条件は変えたくないので枝分かれのしかたを変える。
「すべてのノードは2個の子を持つ」という条件を
「すべてのノードは2個または3個の子を持つ」という条件に変えてみよう。
0個や1個の子は許さない。
子が0個や1個のノードが増えるとその木を使った探索は線形探索に近づいていくからだ。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/bbtree.svg"
	alt="[2-3木の例]" /></p>

<p>
分岐が2のときにノードはひとつの要素を持つ。
その要素と比較して小さいものを左の木に、大きいものを右の木に持つ。
分岐が3のときにノードはふたつの要素を持つ。
小さいほうの要素より小さいものを左の木に、
ふたつの要素のあいだとなるものをまん中の木に、
大きいほうの要素より大きいものを右の木に持つ。
また図では省略したが末端の値の下にも本当は枝がのびていて
高さ0の木がそれぞれぶらさがっている。
</p>

<h2>検索</h2>

<p>
検索は2分探索木とほとんど同じだ。
検索する値とノードの要素の大小関係によって進む枝を選べばいい。
</p>

<h2>追加</h2>

<h3>末端への追加</h3>

<p>
検索と同様の手順で値を追加するところを決める。
末端の値は空の木をぶらさげていることを考慮すると末端に値を追加するということは
高さ0の木を高さ1の木に変換するということだ。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNull.svg"
	alt="[空の木に値を追加する図]" /></p>

<p>
末端の木への要素への追加には対称性を考えると3通りの可能性がある。
(1)値がひとつの末端への追加、(2)値がふたつの末端の左への追加、
(3)値がふたつの末端の中央への追加だ。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToBottom1.svg"
	alt="[値がひとつの末端への追加]" /></p>

<p>
値がひとつの末端の左側に新しい値を追加すると上の図のようになる。
高さ0の木(空の木:N)が高さ1の木に変換される。
この不均衡な2分木を3分木にすることで均衡を回復する。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenBottom1.svg"
	alt="[値がひとつの末端の均衡回復]" /></p>

<p>
つぎにすでに値がふたつある末端への値の追加だ。
まずは(2)の左への追加だ。
値がふたつある末端の左に値を追加すると以下のようになる。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToBottom2.svg"
	alt="[値がふたつの末端の左への追加]" /></p>

<p>木の高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenBottom2.svg"
	alt="[値がふたつの末端の左への追加後の高さをそろえる]" /></p>

<p>
3つの値を含み4つの空の木を持つ4分岐の木となる。
BB木では4分岐は許されていないので木の高さを1段高くする。
上図の緑の値を上に持ち上げれば良い。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupBottom2.svg"
	alt="[値がふたつの末端の左への追加後に木を高くする]" /></p>

<p>
次に(3)の2つの値を含む末端の中間への値の追加を見ていこう。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToBottom3.svg"
	alt="[値がふたつの末端の中央への追加]" /></p>

<p>
木の高さをそろえる。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenBottom3.svg"
	alt="[値がふたつの末端の中央への追加後の高さをそろえる]" /></p>

<p>木を一段高くする。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupBottom3.svg"
	alt="[値がふたつの末端の中央への追加後に木を高くする]" /></p>

<p>
見てきたように末端への値の追加は末端の木を2分岐から3分岐にするか、
または木の高さを1から2にするという結果となる。
</p>

<h3>上に向かって木を変形していく</h3>

<p>
末端において木の高さが1のままであれば単にその部分をおきかえるだけですむ。
木の高さが高くなったときには変形は上向きに連鎖していく。
末端で見たのと同じ変換が次々に上へと向かっていく。
</p>

<p>
(1) 変形されるノードが値ひとつ(2分岐のノード)のときを考える。
</p>

<p>左の子ノードが1段高くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNode1.svg"
	alt="[値がひとつのノードの左が高くなる]" /></p>

<p>高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenNode1.svg"
	alt="[値がひとつのノードの左が高くなったのを平坦化]" /></p>

<p>この場合、変形はこのレベルで終わる。</p>

<p>
(2) 変形されるノードが値ふたつ(3分岐のノード)で左の木が高くなるときを考える。
</p>

<p>3分岐のノードの左の子が高くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNode2.svg"
	alt="[値がふたつのノードの左が高くなる]" /></p>

<p>木の高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenNode2.svg"
	alt="[値がふたつのノードの左が高くなったのを平坦化の図]" /></p>

<p>木を1段高くする。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupNode2.svg"
	alt="[値がふたつのノードの左が高くなった結果全体が高くなるの図]" /></p>

<p>
木が高くなったのでさらに上のレベルへと変形が連鎖していく。
</p>

<p>
(3) 変形されるノードが値ふたつ(3分岐のノード)で中央の木が高くなるときを考える。
</p>

<p>3分岐のノードの中央の子が高くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/addToNode3.svg"
	alt="[値がふたつのノードの中央が高くなるの図]" /></p>

<p>高さをそろえる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/flattenNode3.svg"
	alt="[値がふたつのノードの中央が高くなったのを平坦化の図]" /></p>

<p>1段高くする。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/levelupNode3.svg"
	alt="[値がふたつのノードの中央が高くなった結果全体が高くなるの図]" /></p>

<p>木が高くなったので上のレベルへと連鎖していく。</p>

<p>
木が高くなっていく連鎖が根まで到達すると木全体が1段高くなる。
</p>

<h3>末端と途中のノードへの操作</h3>

<p>
末端のノードへの操作と途中のノードへの操作とは実は同じである。
次の「削除」の説明ではわけずに説明する。
</p>

<h2>削除</h2>

<h3>概要</h3>

<p>
途中のノードの値の削除は左の子に含まれる値の最大値(必ず末端となる)と交換した
うえで末端から削除していく。
削除は木の高さの低下を上方向に連鎖していくことで実現できる。
木の高さの低下を上方向に伝播させるまえに木の回転によって隣りのノードから
値と子要素を融通してもらえるかチェックする必要がある。
</p>

<p>
木の高さの低下が上に伝播する場合には上のレベルの値が下のレベルに下りる。
</p>

<h3>末端の要素の削除</h3>

<h4>隣りから融通</h4>

<p>
木が低くなったときに隣りのノードから値と子となる木を融通してもらえるかを調べる。
隣りのノードに値があまっていれば木の回転によって低くなった木をうめあわせる。
左の木が低くなる前の状態を示す。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromNeighbor0.svg"
	alt="[隣りから融通の最初の状態の図]" /></p>

<p>左の木が低くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromNeighbor1.svg"
	alt="[隣りから融通の左の木が低くなった状態の図]" /></p>

<p>「木の回転」によって右から値と子となる木を融通する。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromNeighbor2.svg"
	alt="[隣りから融通されたあとの図]" /></p>

<p>
このとき木の高さはかわらないので高さを低くしていく連鎖はここで終わる。
</p>

<h4>木を低くする</h4>

<p>
隣りに値や子となる木があまっていないときには木を低くする必要がある。
</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromUpper0.svg"
	alt="[上から融通の最初の状態の図]" /></p>

<p>左の木が1段低くなる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromUpper1.svg"
	alt="[上から融通の左の木が1段低くなった状態の図]" /></p>

<p>上の値を下に下げることで下のノードをまとめる。</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromUpper2.svg"
	alt="[上から融通された状態の図]" /></p>

<p>木が1段低くなったので木の変形が上へ伝播していく。</p>

<h3>途中の要素の削除</h3>

<p>
途中のノードの要素を削除するのは末端の要素と入れかえたうえで
末端からその要素を削除していくのと同じことだ。
手順は以下のようになる。
</p>

<ol>
<li>左の子から最大値をとりだす</li>
<li>とりだした値で削除する値をおきかえる</li>
<li>左の子の高さが変化しなければそのまま</li>
<li>左の子が低くなったら隣りの木か上から値を融通する</li>
<li>上から融通したときには変形を上へ伝播させる</li>
</ol>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromLeaf0.svg"
	alt="[葉から融通の最初の状態の図]" /></p>

<p>
左の子から最大値をとりだす。
これは検索と削除の処理を同時に行うようなものだ。
そのとき左の子の高さが変化しないときと1段低くなるときとがある。
</p>

<p>
<img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromLeaf1.svg"
	alt="[葉から融通の左の子の高さが変化しない状態の図]" />
<img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromLeaf2.svg"
	alt="[葉から融通の左の子が1段低くなる状態の図]" />
</p>

<p>とりだした値で削除する値をおきかえる。</p>

<p>
<img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromLeaf3.svg"
	alt="[葉から融通の左の子の高さ変わらず値のおきかえ後の状態の図]" />
<img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/fromLeaf4.svg"
	alt="[葉から融通の左の子が1段低くなり値のおきかえ後の状態の図]" />
</p>

<p>
左の子の高さに変化のないものについては操作は終了だ。
左の子の高さが低くなったものは隣や上からの融通の操作を続ける。
</p>

<h2>変数名の規則</h2>

<p>[ここから書き始めること]</p>

<p><img	src="/computer/haskell/algorithm/2-3_tree/bb_tree/images/var22.svg"
	alt="[2-2の変数名規則の図]" /></p>

<p>[コードの解説n]は実際の内容を考えながらちゃんとしたタイトルにつけかえる。</p>

<h2>[コードの解説2]</h2>

<h2>[コードの解説3]</h2>

<h2>多相型版</h2>
