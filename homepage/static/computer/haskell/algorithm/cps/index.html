継続渡しスタイル(CPS)

<p>(工事中 0%)</p>

<h2>CPSとは</h2>

<h3>関数型的説明</h3>

<p>
継続渡しスタイルとは引数とともに「続けて行う計算」を渡すことによって
「関数から返った値」に対して続けて関数を適用することをエミュレートするものだ。
</p>

<p><code>f(g(x))</code></p>

<p>のようにする代わりに</p>

<p><code>g'(x, f)</code></p>

<p>のようにする。</p>

<h3>手続き型的説明</h3>

<p>
関数を呼び出すときに引数とともに「その後に行う手続き」を渡すことによって
その関数からもどったあとにさらに手続きを実行することをエミュレートするものだ。
</p>

<p><code>A<br/>
B<br/>
f(x)<br/>
C<br/>
D</code></p>

<p>のようなコードを</p>

<p><code>A<br/>
B<br/>
f(x, [C, D])</code></p>

<p>のようにする。</p>

<h2>CPSでコードはどうなるか</h2>

<p>
手続き型的コードを関数型の枠組みで行うことができる。
「手続き型的コード」からCPSにすれば「より関数型的」となり、
「関数型的コード」からCPSにすれば「より手続き型的」なコードとなる。
</p>

<h2>CPSの使い道</h2>

<p>
関数型的な枠組みでbreak文や分岐を実装することができる。
</p>

<h2>手続き型的なコードを関数型的な枠組みで考えると</h2>

<p>以下のようにA, B, C, Dのような手続き型的なコードがあるとする。</p>

<p><code>A<br/>
B<br/>
C<br/>
D</code></p>

<p>
これらの手続き型的なコードは状態を引数にとり状態を返り値としてかえす関数と
考えることができる。
すると上のようなコードは以下のように考えられる。
</p>

<p><code>D(C(B(A(S0)))</code></p>

<p>これをCPSに変換すると</p>

<p><code>A'(S0,D.C.B)<br/>
A'(S0,\S1-&gt;D(C(B(S1)))<br/>
A'(S0,\S1-&gt;B'(S1,D.C))<br/>
A'(S0,\S1-&gt;B'(S1,\S2-&gt;D(C(S2))))<br/>
A'(S0,\S1-&gt;B'(S1,\S2-&gt;C'(S2,D)))<br/>
A'(S0,\S1-&gt;B'(S1,\S2-&gt;C'(S2,\S3-&gt;D(S3))<br/>
A'(S0,\S1-&gt;B'(S1,\S2-&gt;C'(S2,\S3-&gt;D'(S3,id))))</code></p>

<h3>Haskellで</h3>

<p><code>d . c . b $ a s0</code></p>

<p><code>a' s0 $ \s1 -&gt; b' s1 $ \s2 -&gt; c' s2 $ \s3 -&gt; d' s3 id</code></p>

<p>引数を逆にすると</p>

<p><code>a' (\s1 -&gt; b' (\s2 -&gt; c' (\s3 -&gt; d' id s3) s2) s1) s0<br/>
a' (b' (c' (d' id))) s0<br/>
(a' . b' . c' . d' $ id) s0</code></p>
