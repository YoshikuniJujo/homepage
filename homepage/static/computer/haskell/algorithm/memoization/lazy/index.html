Haskell: 遅延型を利用したメモ化

<p>(工事中 2%)</p>

<h2>弱頭部正規形までの評価</h2>

<p>
Haskellでは代数的データ型の中身についても、
必要になるまでは評価しないという特徴がある。
正式に言うと弱頭部正規形までの評価ということになる。
これを利用することで効率的なメモ化を簡潔なコードで行うことが可能になる。
この手法はパックラット構文解析に使用されている。
</p>

<h2>メモ化のために必要な条件</h2>

<p>
メモ化するためにはメモリ上の表現として同一である必要がある。
たとえば、以下のような場合にはg 3は一度しか実行されず、
ある意味ではメモ化されていると言うことができる。
</p>

<pre><code>let f x = x + x in f $ g 3</code></pre>

<p>
しかし、以下の場合には1回目のg 3と2回目のg 3とは別々に評価される。
つまりメモ化されていないと言える。
</p>

<pre><code>g 3 + g 3</code></pre>

<p>
つまり、関数の引数が同一であったとしても、
もともとの表記上で同一でなければ、その都度別々に評価される。
</p>

<h2>単純な例</h2>

<p>
フィボナッチ数列の素直な定義として以下のようなものがある。
</p>

<pre><code>fib 0 = 0
fib 1 = 1
fib n = fib (n - 2) + fib (n - 1)</code></pre>

<p>
しかし、これは評価に指数関数時間が必要となる。
これを以下のように書き換えることができる。
</p>

<pre><code>fib = (fibs !!)
fibs@(_ : tfibs) = 0 : 1 : zipWith (+) fibs tfibs</code></pre>

<p>
これはメモ化による最適化の一例である。
</p>

<h2>バックトラック</h2>

<p>
何かの作業がうまくいかなかったときに、すこしもどって、
もう一度やりなおすといったアルゴリズムがある。
たとえばある場所に行きたいとき、
ある道順で行って行き止まりになってしまったとする。
そしたらその直前の交差点までもどり別の道を行く。
その交差点から行けるすべての道を試してもたどりつけなかったならば、
さらに前の交差点までもどり同じことをくりかえす。
これがバックトラックである。
</p>

<p>
全ての交差点で道が2又に分かれている道を考える。
すると試す回数は、目的地までの距離(交差点の数)をnとして、
だいたい2^n程度になる。
つまり、バックトラックを愚直に実装すると最悪の場合、指数関数時間が
かかってしまうことになる。
</p>

<h3>結果が位置とルールから完全に決まるような場合</h3>

<p>
ある入力列をたどりながら、値を蓄積していっているような状況を考える。
</p>

<p>(作成中)<p>
