目次案3

<p>(工事中 0%)</p>

<h2>目次案</h2>

<h3>第I部: 関数型プログラミングについて</h3>

<ul>
<li>古くて新しい「関数型プログラミング」
	<ul>
	<li>「関数型」のルーツはコンピュータより古い</li>
	<li>学問の世界とプログラミング
		<ul>
		<li>車輪の両輪: 研究と実践</li>
		</ul></li>
	<li>処理の複雑化によってきちんとした理論が必要になる
		<ul>
		<li>並行・並列コンピューティングなど</li>
		<li>厳密さと簡潔さによって複雑さを制御する
			<ul>
			<li>数学的な道具によって脳の力を補強する</li>
			<li>あなたの脳の力を何倍にもするツール</li>
			</ul></li>
		</ul></li>
	</ul></li>
<li>「関数型プログラミング」の特徴
	<ul>
	<li>「関数型」の意味するもの
		<ul>
		<li>モダンな言語には「関数型」と「手続き型」の特徴がある</li>
		<li>「関数型」の機能を拡張し「手続き型」の機能を制限する</li>
		<li>より「関数型」の比重が高いものが「関数型言語」</li>
		</ul></li>
	<li>「関数型プログラミング」の2つの側面
		<ul>
		<li>「手続き型」の機能の制限</li>
		<li>「関数型」の機能の拡張</li>
		</ul></li>
	<li>式の評価
		<ul>
		<li>動作と評価</li>
		<li>純粋手続き型言語: アセンブリ言語</li>
		<li>C言語の関数型的機能</li>
		<li>モダンな言語における二重化: Rubyで具体例を</li>
		</ul></li>
	<li>第1級関数
		<ul>
		<li>最近の言語ではありふれた機能</li>
		<li>高階関数</li>
		<li>第1級関数使用の有無の例
			<ul>
			<li>Rubyで第1級関数を使うと簡潔に書けるという具体例</li>
			</ul></li>
		</ul></li>
	<li>参照透過性
		<ul>
		<li>本来なら当たり前のこと</li>
		<li>参照透過性の有無の例
			<ul>
			<li>Rubyで状態変化が問題になる具体例</li>
			</ul></li>
		<li>評価と動作の分離</li>
		<li>Rubyで評価と動作を分離する例</li>
		</ul></li>
	<li>遅延性
		<ul>
		<li>「関数型」の機能の拡張のひとつの方向</li>
		<li>遅延評価(必要呼びという評価戦略)
			<ul>
			<li>Rubyでmyifが簡単には書けないという例
				<ul>
				<li>myif(true, 88, 95 / 0)のような例で</li>
				</ul></li>
			</ul></li>
		<li>弱頭部正規形までの評価
			<ul>
			<li>コラム
				<ul>
				<li>遅延評価という言葉の誤解</li>
				<li>正規形とは</li>
				<li>頭部正規形とは</li>
				<li>弱頭部正規形とは</li>
				</ul></li>
			<li>本質と終了条件の分離</li>
			</ul></li>
		</ul></li>
	<li>静的型付け
		<ul>
		<li>「関数型」の機能の拡張のひとつの方向</li>
		<li>型付きラムダ計算</li>
		<li>定義域と値域が決まる</li>
		<li>動的型付けではつねに「失敗の可能性」が残る
			<ul>
			<li>ありとあらゆる値に対して定義されている必要がある</li>
			<li>Rubyによる具体例</li>
			</ul></li>
		</ul></li>
	</ul></li>
</ul>

<h3>第II部: Haskellを学ぶ</h3>

<ul>
<li>バイナリエディタは絵も描けるし作曲もできるけど
	<ul>
	<li>Rubyは関数型的書きかたも手続き的書きかたもできる</li>
	<li>お絵描きソフトは作曲はできないが
		バイナリエディタよりも絵が描きやすい</li>
	<li>Haskellは手続き的書きかたを排除することで関数型的書きかたがしやすい</li>
	<li>関数型プログラミングを学ぶにはHaskellを学ぶのが一番簡単</li>
	</ul></li>
<li>GHCの導入: ごくごく簡単な説明(基本的には自分でやって)</li>
<li>関数
	<ul>
	<li>対話環境に触れる</li>
	<li>関数を作る</li>
	<li>...</li>
	</ul></li>
<li>型</li>
<li>多相関数</li>
<li>タプル</li>
<li>リストによる「くりかえし」</li>
<li>確認のための例題: モンテカルロ法</li>
<li>追加の構文1</li>
<li>再帰関数の基本</li>
<li>リストを引数とする再帰関数</li>
<li>リストを作成する再帰関数</li>
<li>リストの再帰的定義</li>
<li>リストを扱う標準的な関数
	<ul>
	<li>うまくFoldable等の説明を避ける</li>
	</ul></li>
<li>確認のための例題: 単純なパーサ</li>
<li>代数的データ型</li>
<li>確認のための例題: Nano Markup Language</li>
<li>型クラス</li>
<li>確認のための例題: オートマトンの例</li>
<li>モノイド</li>
<li>ファンクター</li>
<li>アプリカティブファンクター</li>
<li>モナド
	<ul>
	<li>MaybeモナドやStateモナドの例を挙げる</li>
	<li>モナドは実はアプリカティブファンクターであることを示す</li>
	</ul></li>
<li>IOモナド</li>
<li>ファイル入出力</li>
<li>ネットワークとのやりとり</li>
<li>作ってみよう: 考え中</li>
</ul>

<h2>第III部: まとめ</h2>

<p>
内容は考え中。
「よくがんばりました。さあとびだそう」的な感じ。
</p>

<h2>メモ</h2>

<p>ラムダ計算は1930年代に考案された。</p>

<p>世界最初の汎用コンピュータであるENIACは1946年に発表された。</p>
